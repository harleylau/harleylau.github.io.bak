<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Redis源码剖析--列表t_list实现 | Harley_Lau</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Redis中的列表对象比较特殊，在版本3.2之前，列表底层的编码是 ziplist 和 linkedlist 实现的， 但是在版本3.2之后，重新引入了一个 quicklist 的数据结构，列表的底层都由quicklist实现。 这边是在看源码和实际验证的时候发现的区别，然后上网查证。由于目前使用的redis基本都在3.2了， 而且老版本肯定会被取代， 所以我们只分析3.2版本之后的实现。对于老版">
<meta name="keywords" content="redis,源码">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis源码剖析--列表t_list实现">
<meta property="og:url" content="https://harleylau.github.io/2018/05/10/Redis源码剖析-列表t-list实现/index.html">
<meta property="og:site_name" content="Harley_Lau">
<meta property="og:description" content="Redis中的列表对象比较特殊，在版本3.2之前，列表底层的编码是 ziplist 和 linkedlist 实现的， 但是在版本3.2之后，重新引入了一个 quicklist 的数据结构，列表的底层都由quicklist实现。 这边是在看源码和实际验证的时候发现的区别，然后上网查证。由于目前使用的redis基本都在3.2了， 而且老版本肯定会被取代， 所以我们只分析3.2版本之后的实现。对于老版">
<meta property="og:updated_time" content="2018-05-29T02:12:49.131Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Redis源码剖析--列表t_list实现">
<meta name="twitter:description" content="Redis中的列表对象比较特殊，在版本3.2之前，列表底层的编码是 ziplist 和 linkedlist 实现的， 但是在版本3.2之后，重新引入了一个 quicklist 的数据结构，列表的底层都由quicklist实现。 这边是在看源码和实际验证的时候发现的区别，然后上网查证。由于目前使用的redis基本都在3.2了， 而且老版本肯定会被取代， 所以我们只分析3.2版本之后的实现。对于老版">
  
    <link rel="alternate" href="/atom.xml" title="Harley_Lau" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Harley_Lau</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://harleylau.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Redis源码剖析-列表t-list实现" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/10/Redis源码剖析-列表t-list实现/" class="article-date">
  <time datetime="2018-05-10T01:53:08.000Z" itemprop="datePublished">2018-05-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Redis源码剖析--列表t_list实现
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Redis中的列表对象比较特殊，在版本3.2之前，列表底层的编码是 ziplist 和 linkedlist 实现的， 但是在版本3.2之后，重新引入了一个 quicklist 的数据结构，列表的底层都由quicklist实现。</p>
<p>这边是在看源码和实际验证的时候发现的区别，然后上网查证。由于目前使用的redis基本都在3.2了， 而且老版本肯定会被取代， 所以我们只分析3.2版本之后的实现。对于老版本的列表实现，一笔带过吧。 </p>
<p>在老版本中，当列表对象可以同时满足以下两个条件时， 列表对象使用 ziplist 编码：</p>
<ul>
<li>列表对象保存的所有字符串元素的长度都小于 64 字节；</li>
<li>列表对象保存的元素数量小于 512 个；</li>
</ul>
<p>不能满足这两个条件的列表对象需要使用 linkedlist 编码。当这两个条件任何一个不满足的时候，就会有一个格式的转换。</p>
<p>对于quicklist的结构，下节中在具体分析，先来看下list的实现。</p>
<h2 id="List的结构"><a href="#List的结构" class="headerlink" title="List的结构"></a>List的结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/* Structure to hold list iteration abstraction. */</div><div class="line">typedef struct &#123;</div><div class="line">    robj *subject;</div><div class="line">    unsigned char encoding;</div><div class="line">    unsigned char direction; /* Iteration direction */</div><div class="line">    quicklistIter *iter;</div><div class="line">&#125; listTypeIterator;</div><div class="line"></div><div class="line">/* Structure for an entry while iterating over a list. */</div><div class="line">typedef struct &#123;</div><div class="line">    listTypeIterator *li;</div><div class="line">    quicklistEntry entry; /* Entry in quicklist */</div><div class="line">&#125; listTypeEntry;</div></pre></td></tr></table></figure>
<p>List的结构其实就是定义了一个列表的头节点， 以及一个迭代器指针，指针中指定了编码格式和迭代方向。</p>
<h2 id="List命令"><a href="#List命令" class="headerlink" title="List命令"></a>List命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>BLPOP key1 [key2 ] timeout</td>
<td>移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td>
</tr>
<tr>
<td>BRPOP key1 [key2 ] timeout</td>
<td>移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td>
</tr>
<tr>
<td>BRPOPLPUSH source destination timeout</td>
<td>从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它；如但果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td>
</tr>
<tr>
<td>LINDEX key index</td>
<td>通过索引获取列表中的元素</td>
</tr>
<tr>
<td>LINSERT key BEFORE</td>
<td>AFTER pivot value</td>
<td>在列表的元素前或者后插入元素</td>
</tr>
<tr>
<td>LLEN key</td>
<td>获取列表长度</td>
</tr>
<tr>
<td>LPOP key</td>
<td>移出并获取列表的第一个元素</td>
</tr>
<tr>
<td>LPUSH key value1 [value2]</td>
<td>将一个或多个值插入到列表头部</td>
</tr>
<tr>
<td>LPUSHX key value</td>
<td>将一个或多个值插入到已存在的列表头部</td>
</tr>
<tr>
<td>LRANGE key start stop</td>
<td>获取列表指定范围内的元素</td>
</tr>
<tr>
<td>LREM key count value</td>
<td>移除列表元素</td>
</tr>
<tr>
<td>LSET key index value</td>
<td>通过索引设置列表元素的值</td>
</tr>
<tr>
<td>LTRIM key start stop</td>
<td>对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。</td>
</tr>
<tr>
<td>RPOP key</td>
<td>移除并获取列表最后一个元素</td>
</tr>
<tr>
<td>RPOPLPUSH source destination</td>
<td>移除列表的最后一个元素，并将该元素添加到另一个列表并返回</td>
</tr>
<tr>
<td>RPUSH key value1 [value2]</td>
<td>在列表中添加一个或多个值</td>
</tr>
<tr>
<td>RPUSHX key value</td>
<td>为已存在的列表添加值</td>
</tr>
</tbody>
</table>
<h2 id="List命令实现"><a href="#List命令实现" class="headerlink" title="List命令实现"></a>List命令实现</h2><h3 id="push命令实现"><a href="#push命令实现" class="headerlink" title="push命令实现"></a>push命令实现</h3><p>lpush和rpush分别调用的下边的两个函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// lpush操作</div><div class="line">void lpushCommand(client *c) &#123;</div><div class="line">    pushGenericCommand(c,LIST_HEAD);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// rpush操作</div><div class="line">void rpushCommand(client *c) &#123;</div><div class="line">    pushGenericCommand(c,LIST_TAIL);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到， 这两个操作其实都是调用的pushGenericCommand这个函数实现， 不同的点是指定了是从HEAD的位置push一个数据还是从TAIL的位置push一个数据。接下来来看pushGenericCommand的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">void pushGenericCommand(client *c, int where) &#123;</div><div class="line">    int j, pushed = 0;</div><div class="line">    // 现在数据库中查找是否已经存在了该键</div><div class="line">    robj *lobj = lookupKeyWrite(c-&gt;db,c-&gt;argv[1]);</div><div class="line">    // 如果已经存在了该键，验证该键是否是list类型，如果不是的话，返回错误</div><div class="line">    if (lobj &amp;&amp; lobj-&gt;type != OBJ_LIST) &#123;</div><div class="line">        addReply(c,shared.wrongtypeerr);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    // 遍历剩余的参数</div><div class="line">    for (j = 2; j &lt; c-&gt;argc; j++) &#123;</div><div class="line">        // 如果该键不存在，创建一个quicklist</div><div class="line">        if (!lobj) &#123;</div><div class="line">            lobj = createQuicklistObject();</div><div class="line">            quicklistSetOptions(lobj-&gt;ptr, server.list_max_ziplist_size,</div><div class="line">                                server.list_compress_depth);</div><div class="line">            // 将创建的键添加到对应的db</div><div class="line">            dbAdd(c-&gt;db,c-&gt;argv[1],lobj);</div><div class="line">        &#125;</div><div class="line">        // 执行push操作</div><div class="line">        listTypePush(lobj,c-&gt;argv[j],where);</div><div class="line">        // 个数加1</div><div class="line">        pushed++;</div><div class="line">    &#125;</div><div class="line">    // 返回添加的节点数量</div><div class="line">    addReplyLongLong(c, (lobj ? listTypeLength(lobj) : 0));</div><div class="line">    // 至少有一个添加成功则进行操作</div><div class="line">    if (pushed) &#123;</div><div class="line">        char *event = (where == LIST_HEAD) ? &quot;lpush&quot; : &quot;rpush&quot;;</div><div class="line">        // 发送键修改信号</div><div class="line">        signalModifiedKey(c-&gt;db,c-&gt;argv[1]);</div><div class="line">        // 发送事件通知</div><div class="line">        notifyKeyspaceEvent(NOTIFY_LIST,event,c-&gt;argv[1],c-&gt;db-&gt;id);</div><div class="line">    &#125;</div><div class="line">    // 服务器的脏数据个数增加</div><div class="line">    server.dirty += pushed;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>内部最终还是调用了一个listTypePush的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">/* The function pushes an element to the specified list object &apos;subject&apos;,</div><div class="line"> * at head or tail position as specified by &apos;where&apos;.</div><div class="line"> *</div><div class="line"> * There is no need for the caller to increment the refcount of &apos;value&apos; as</div><div class="line"> * the function takes care of it if needed. */</div><div class="line">void listTypePush(robj *subject, robj *value, int where) &#123;</div><div class="line">    // 判断类型是否为quciklist，不是的话返回错误</div><div class="line">    if (subject-&gt;encoding == OBJ_ENCODING_QUICKLIST) &#123;</div><div class="line">        int pos = (where == LIST_HEAD) ? QUICKLIST_HEAD : QUICKLIST_TAIL;</div><div class="line">        // 解码数据</div><div class="line">        value = getDecodedObject(value);</div><div class="line">        // 得到数据的长度</div><div class="line">        size_t len = sdslen(value-&gt;ptr);</div><div class="line">        // 调用quicklistPush插入数据</div><div class="line">        quicklistPush(subject-&gt;ptr, value-&gt;ptr, len, pos);</div><div class="line">        // 将数据项对象的引用次数减1，也就是释放value</div><div class="line">        decrRefCount(value);</div><div class="line">    &#125; else &#123;</div><div class="line">        serverPanic(&quot;Unknown list encoding&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>pop的操作其实跟push的操作很相似，比较容易读懂。List的操作比较有特点的一项是阻塞操作，可以来分析一下。</p>
<h3 id="阻塞pop操作的实现"><a href="#阻塞pop操作的实现" class="headerlink" title="阻塞pop操作的实现"></a>阻塞pop操作的实现</h3><p>首先，一样是调用了最上层的两个函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// blpop</div><div class="line">void blpopCommand(client *c) &#123;</div><div class="line">    blockingPopGenericCommand(c,LIST_HEAD);</div><div class="line">&#125;</div><div class="line">// brpop</div><div class="line">void brpopCommand(client *c) &#123;</div><div class="line">    blockingPopGenericCommand(c,LIST_TAIL);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>他们其实都是调用blockingPopGenericCommand来实现的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">/* Blocking RPOP/LPOP */</div><div class="line">void blockingPopGenericCommand(client *c, int where) &#123;</div><div class="line">    robj *o;</div><div class="line">    mstime_t timeout;</div><div class="line">    int j;</div><div class="line"></div><div class="line">    // 取出timeout参数</div><div class="line">    if (getTimeoutFromObjectOrReply(c,c-&gt;argv[c-&gt;argc-1],&amp;timeout,UNIT_SECONDS)</div><div class="line">        != C_OK) return;</div><div class="line">    // 遍历参数</div><div class="line">    for (j = 1; j &lt; c-&gt;argc-1; j++) &#123;</div><div class="line">        // 查看数据库中是否存在该键</div><div class="line">        o = lookupKeyWrite(c-&gt;db,c-&gt;argv[j]);</div><div class="line">        if (o != NULL) &#123;</div><div class="line">            // 如果存在，判断该键是否是list类型，不是的话报错</div><div class="line">            if (o-&gt;type != OBJ_LIST) &#123;</div><div class="line">                addReply(c,shared.wrongtypeerr);</div><div class="line">                return;</div><div class="line">            &#125; else &#123;</div><div class="line">                // 当前列表非空，直接执行pop操作</div><div class="line">                if (listTypeLength(o) != 0) &#123;</div><div class="line">                    /* Non empty list, this is like a non normal [LR]POP. */</div><div class="line">                    char *event = (where == LIST_HEAD) ? &quot;lpop&quot; : &quot;rpop&quot;;</div><div class="line">                    robj *value = listTypePop(o,where);</div><div class="line">                    serverAssert(value != NULL);</div><div class="line"></div><div class="line">                    addReplyMultiBulkLen(c,2);</div><div class="line">                    addReplyBulk(c,c-&gt;argv[j]);</div><div class="line">                    addReplyBulk(c,value);</div><div class="line">                    decrRefCount(value);</div><div class="line">                    notifyKeyspaceEvent(NOTIFY_LIST,event,</div><div class="line">                                        c-&gt;argv[j],c-&gt;db-&gt;id);</div><div class="line">                    // 如果当前key弹出一个值之后为空，删除这个列表</div><div class="line">                    if (listTypeLength(o) == 0) &#123;</div><div class="line">                        dbDelete(c-&gt;db,c-&gt;argv[j]);</div><div class="line">                        notifyKeyspaceEvent(NOTIFY_GENERIC,&quot;del&quot;,</div><div class="line">                                            c-&gt;argv[j],c-&gt;db-&gt;id);</div><div class="line">                    &#125;</div><div class="line">                    signalModifiedKey(c-&gt;db,c-&gt;argv[j]);</div><div class="line">                    server.dirty++;</div><div class="line"></div><div class="line">                    /* Replicate it as an [LR]POP instead of B[LR]POP. */</div><div class="line">                    rewriteClientCommandVector(c,2,</div><div class="line">                        (where == LIST_HEAD) ? shared.lpop : shared.rpop,</div><div class="line">                        c-&gt;argv[j]);</div><div class="line">                    return;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* If we are inside a MULTI/EXEC and the list is empty the only thing</div><div class="line">     * we can do is treating it as a timeout (even with timeout 0). */</div><div class="line">    if (c-&gt;flags &amp; CLIENT_MULTI) &#123;</div><div class="line">        addReply(c,shared.nullmultibulk);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* If the list is empty or the key does not exists we must block */</div><div class="line">    // 参数中的所有键都不存在，则阻塞这些键</div><div class="line">    blockForKeys(c, c-&gt;argv + 1, c-&gt;argc - 2, timeout, NULL);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到， 当指定的list存在于当前数据库中且list不为空，就会执行一次普通的pop操作；但是当指定的list键不存在，或者该list为空，就会阻塞该操作。就是上边代码中的最后一句。</p>
<p>接下去，就是看redis如何处理这个被阻塞的操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">/* Set a client in blocking mode for the specified key, with the specified</div><div class="line"> * timeout */</div><div class="line"> // 设置键的阻塞状态</div><div class="line">void blockForKeys(client *c, robj **keys, int numkeys, mstime_t timeout, robj *target) &#123;</div><div class="line">    dictEntry *de;</div><div class="line">    list *l;</div><div class="line">    int j;</div><div class="line"></div><div class="line">    c-&gt;bpop.timeout = timeout;</div><div class="line">    c-&gt;bpop.target = target;</div><div class="line"></div><div class="line">    if (target != NULL) incrRefCount(target);</div><div class="line"></div><div class="line">    // 遍历所有的key</div><div class="line">    for (j = 0; j &lt; numkeys; j++) &#123;</div><div class="line">        /* If the key already exists in the dict ignore it. */</div><div class="line">        // 如果当前键存在，则忽略；反之则添加该键</div><div class="line">        // bpop.keys记录所有造成客户端阻塞的键</div><div class="line">        if (dictAdd(c-&gt;bpop.keys,keys[j],NULL) != DICT_OK) continue;</div><div class="line">        //当前的key引用计数加1</div><div class="line">        incrRefCount(keys[j]);</div><div class="line"></div><div class="line">        /* And in the other &quot;side&quot;, to map keys -&gt; clients */</div><div class="line">        // blocking_keys是一个字典，其键为造成阻塞的键，值是一个链表，记录所有被该键阻塞的客户端</div><div class="line">        // 查找当前造成阻塞的键</div><div class="line">        de = dictFind(c-&gt;db-&gt;blocking_keys,keys[j]);</div><div class="line">        if (de == NULL) &#123;</div><div class="line">            // 如果不存在，需要新创建一个， 并加入到blocking_keys中</div><div class="line">            int retval;</div><div class="line"></div><div class="line">            /* For every key we take a list of clients blocked for it */</div><div class="line">            l = listCreate();</div><div class="line">            // 将键和新创建的列表加入</div><div class="line">            retval = dictAdd(c-&gt;db-&gt;blocking_keys,keys[j],l);</div><div class="line">            incrRefCount(keys[j]);</div><div class="line">            serverAssertWithInfo(c,keys[j],retval == DICT_OK);</div><div class="line">        &#125; else &#123;</div><div class="line">            // 如果存在，获取该键的值，即客户端列表</div><div class="line">            l = dictGetVal(de);</div><div class="line">        &#125;</div><div class="line">        // 将当前的客户端加入的该键的阻塞列表中</div><div class="line">        listAddNodeTail(l,c);</div><div class="line">    &#125;</div><div class="line">    // 阻塞该客户端</div><div class="line">    blockClient(c,BLOCKED_LIST);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上边的代码中，可以看到客户端分别用来c-&gt;bpop.xxxx 和 c-&gt;db-&gt;blocking_keys用来保存被阻塞的键，以及阻塞的键和客户端的对应关系。</p>
<p>他们的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">// server.h</div><div class="line">typedef struct client &#123;</div><div class="line">    //client当前使用的数据库</div><div class="line">    redisDb *db;   /* Pointer to currently SELECTed DB. */</div><div class="line"></div><div class="line">    //阻塞状态</div><div class="line">    blockingState bpop;     /* blocking state */</div><div class="line">    //其他成员省略</div><div class="line">&#125; client;</div><div class="line"></div><div class="line">// 阻塞状态结构体</div><div class="line">typedef struct blockingState &#123;</div><div class="line">    mstime_t timeout;      // 阻塞超时时间</div><div class="line">    dict *keys;           // 记录所有造成客户端阻塞的键</div><div class="line">    robj *target;         // 目标选项，target在执行RPOPLPUSH命令时使用，</div><div class="line">    /* BLOCKED_WAIT */</div><div class="line">    int numreplicas;        /* Number of replicas we are waiting for ACK. */</div><div class="line">    long long reploffset;   /* Replication offset to reach. */</div><div class="line">&#125; blockingState;</div><div class="line">typedef struct redisDb &#123;</div><div class="line">    dict *blocking_keys;        // 记录所有造成阻塞的键，及其相应的客户端</div><div class="line">    // ...其他参数省略</div><div class="line">&#125; redisDb;</div><div class="line"></div><div class="line">typedef struct redisDb &#123;</div><div class="line">    //正处于阻塞状态的键</div><div class="line">    dict *blocking_keys;        /* Keys with clients waiting for data (BLPOP) */</div><div class="line">    //可以解除阻塞的键</div><div class="line">    dict *ready_keys;           /* Blocked keys that received a PUSH */</div><div class="line">&#125; redisDb;</div></pre></td></tr></table></figure>
<p>redisDb里边利用了一个名为blocking_keys的dict来存储每个阻塞的键，以及等待该键的客户端的对应关系。</p>
<p>做完这些之后，这个客户端就被阻塞了。 那么这个客户端如何从阻塞状态重新回复到非阻塞状态呢。 一个当时是等待的时间超过了timeout的时间，从阻塞状态恢复； 另一个则是其他的客户端往这个列表中插入了数据，正好是当前阻塞的客户端所需要的，当前客户端收到信号之后，从阻塞状态中恢复。</p>
<p>根据我的理解， 如果是客户端超时被解阻塞，调用的是这个函数：</p>
<h4 id="超时解阻塞"><a href="#超时解阻塞" class="headerlink" title="超时解阻塞"></a>超时解阻塞</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">//解阻塞一个正在阻塞中的client</div><div class="line">void unblockClientWaitingData(client *c) &#123;</div><div class="line">    dictEntry *de;</div><div class="line">    dictIterator *di;</div><div class="line">    list *l;</div><div class="line"></div><div class="line">    serverAssertWithInfo(c,NULL,dictSize(c-&gt;bpop.keys) != 0);</div><div class="line">    //创建一个字典的迭代器，指向的是造成client阻塞的键所组成的字典</div><div class="line">    di = dictGetIterator(c-&gt;bpop.keys);</div><div class="line">    /* The client may wait for multiple keys, so unblock it for every key. */</div><div class="line">    //因为client可能被多个key所阻塞，所以要遍历所有的键</div><div class="line">    while((de = dictNext(di)) != NULL) &#123;</div><div class="line">        robj *key = dictGetKey(de); //获得key对象</div><div class="line"></div><div class="line">        /* Remove this client from the list of clients waiting for this key. */</div><div class="line">        //根据key找到对应的列表类型值，值保存着被阻塞的client，从中找c-&gt;db-&gt;blocking_keys中寻找</div><div class="line">        l = dictFetchValue(c-&gt;db-&gt;blocking_keys,key);</div><div class="line">        serverAssertWithInfo(c,key,l != NULL);</div><div class="line">        // 将阻塞的client从列表中移除</div><div class="line">        listDelNode(l,listSearchKey(l,c));</div><div class="line">        /* If the list is empty we need to remove it to avoid wasting memory */</div><div class="line">        //如果当前列表为空了，则从c-&gt;db-&gt;blocking_keys中将key删除</div><div class="line">        if (listLength(l) == 0)</div><div class="line">            dictDelete(c-&gt;db-&gt;blocking_keys,key);</div><div class="line">    &#125;</div><div class="line">    dictReleaseIterator(di);    //释放迭代器</div><div class="line"></div><div class="line">    /* Cleanup the client structure */</div><div class="line">    //清空bpop.keys的所有节点</div><div class="line">    dictEmpty(c-&gt;bpop.keys,NULL);</div><div class="line">    //如果保存有新添加的元素，则应该释放</div><div class="line">    if (c-&gt;bpop.target) &#123;</div><div class="line">        decrRefCount(c-&gt;bpop.target);</div><div class="line">        c-&gt;bpop.target = NULL;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果是其他的客户端插入了一个数据，则是调用下边的函数：</p>
<h4 id="插入解阻塞"><a href="#插入解阻塞" class="headerlink" title="插入解阻塞"></a>插入解阻塞</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">// 如果客户端因为等待某个 key 被阻塞，那么将此key加入到server.ready_keys中</div><div class="line">// 这个列表最终会被 handleClientsBlockedOnLists() 函数处理。</div><div class="line">void signalListAsReady(redisDb *db, robj *key) &#123;</div><div class="line">    readyList *rl;</div><div class="line">    // 如果在所有造成客户端阻塞的键中找不到此键，则不作处理</div><div class="line">    if (dictFind(db-&gt;blocking_keys,key) == NULL) return;</div><div class="line">    // 这个键已经存在于ready_keys中了，则不作处理</div><div class="line">    if (dictFind(db-&gt;ready_keys,key) != NULL) return;</div><div class="line">    </div><div class="line">    // 创建一个新的readylists结构，保存键和数据库</div><div class="line">    // 然后将该结构添加到server.ready_keys中</div><div class="line">    rl = zmalloc(sizeof(*rl));</div><div class="line">    rl-&gt;key = key;</div><div class="line">    rl-&gt;db = db;</div><div class="line">    // 该键的索引加1</div><div class="line">    incrRefCount(key);</div><div class="line">    listAddNodeTail(server.ready_keys,rl);</div><div class="line">    // 同样，将key添加到db-&gt;ready_keys中</div><div class="line">    incrRefCount(key);</div><div class="line">    serverAssert(dictAdd(db-&gt;ready_keys,key,NULL) == DICT_OK);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在将所有可用的key加入到ready_keys之后，会有统一的函数去检查哪些客户端等待着这些key，然后将他们解阻塞</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div></pre></td><td class="code"><pre><div class="line">/* 遍历server.ready_keys中所有已经准备好的key，同时在c-&gt;db-&gt;blocking_keys中</div><div class="line"> 遍历所有由此键造成阻塞的客户端，如果key不为空的话，就从key中弹出一个元素返回给客户端并解除该客户端的阻塞状态，直到server.ready_keys为空，或没有因该key而阻塞的客户端为止 */</div><div class="line">/* This function should be called by Redis every time a single command,</div><div class="line"> * a MULTI/EXEC block, or a Lua script, terminated its execution after</div><div class="line"> * being called by a client.</div><div class="line"> *</div><div class="line"> * All the keys with at least one client blocked that received at least</div><div class="line"> * one new element via some PUSH operation are accumulated into</div><div class="line"> * the server.ready_keys list. This function will run the list and will</div><div class="line"> * serve clients accordingly. Note that the function will iterate again and</div><div class="line"> * again as a result of serving BRPOPLPUSH we can have new blocking clients</div><div class="line"> * to serve because of the PUSH side of BRPOPLPUSH. */</div><div class="line">void handleClientsBlockedOnLists(void) &#123;</div><div class="line">    while(listLength(server.ready_keys) != 0) &#123;</div><div class="line">        list *l;</div><div class="line"></div><div class="line">        /* Point server.ready_keys to a fresh list and save the current one</div><div class="line">         * locally. This way as we run the old list we are free to call</div><div class="line">         * signalListAsReady() that may push new elements in server.ready_keys</div><div class="line">         * when handling clients blocked into BRPOPLPUSH. */</div><div class="line">        l = server.ready_keys;</div><div class="line">        server.ready_keys = listCreate();</div><div class="line"></div><div class="line">        while(listLength(l) != 0) &#123;</div><div class="line">            listNode *ln = listFirst(l);</div><div class="line">            readyList *rl = ln-&gt;value;</div><div class="line"></div><div class="line">            /* First of all remove this key from db-&gt;ready_keys so that</div><div class="line">             * we can safely call signalListAsReady() against this key. */</div><div class="line">            dictDelete(rl-&gt;db-&gt;ready_keys,rl-&gt;key);</div><div class="line"></div><div class="line">            /* If the key exists and it&apos;s a list, serve blocked clients</div><div class="line">             * with data. */</div><div class="line">            robj *o = lookupKeyWrite(rl-&gt;db,rl-&gt;key);</div><div class="line">            if (o != NULL &amp;&amp; o-&gt;type == OBJ_LIST) &#123;</div><div class="line">                dictEntry *de;</div><div class="line"></div><div class="line">                /* We serve clients in the same order they blocked for</div><div class="line">                 * this key, from the first blocked to the last. */</div><div class="line">                de = dictFind(rl-&gt;db-&gt;blocking_keys,rl-&gt;key);</div><div class="line">                if (de) &#123;</div><div class="line">                    list *clients = dictGetVal(de);</div><div class="line">                    int numclients = listLength(clients);</div><div class="line"></div><div class="line">                    while(numclients--) &#123;</div><div class="line">                        listNode *clientnode = listFirst(clients);</div><div class="line">                        client *receiver = clientnode-&gt;value;</div><div class="line">                        robj *dstkey = receiver-&gt;bpop.target;</div><div class="line">                        int where = (receiver-&gt;lastcmd &amp;&amp;</div><div class="line">                                     receiver-&gt;lastcmd-&gt;proc == blpopCommand) ?</div><div class="line">                                    LIST_HEAD : LIST_TAIL;</div><div class="line">                        robj *value = listTypePop(o,where);</div><div class="line"></div><div class="line">                        if (value) &#123;</div><div class="line">                            /* Protect receiver-&gt;bpop.target, that will be</div><div class="line">                             * freed by the next unblockClient()</div><div class="line">                             * call. */</div><div class="line">                            if (dstkey) incrRefCount(dstkey);</div><div class="line">                            unblockClient(receiver);</div><div class="line"></div><div class="line">                            if (serveClientBlockedOnList(receiver,</div><div class="line">                                rl-&gt;key,dstkey,rl-&gt;db,value,</div><div class="line">                                where) == C_ERR)</div><div class="line">                            &#123;</div><div class="line">                                /* If we failed serving the client we need</div><div class="line">                                 * to also undo the POP operation. */</div><div class="line">                                    listTypePush(o,value,where);</div><div class="line">                            &#125;</div><div class="line"></div><div class="line">                            if (dstkey) decrRefCount(dstkey);</div><div class="line">                            decrRefCount(value);</div><div class="line">                        &#125; else &#123;</div><div class="line">                            break;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                if (listTypeLength(o) == 0) &#123;</div><div class="line">                    dbDelete(rl-&gt;db,rl-&gt;key);</div><div class="line">                &#125;</div><div class="line">                /* We don&apos;t call signalModifiedKey() as it was already called</div><div class="line">                 * when an element was pushed on the list. */</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            /* Free this item. */</div><div class="line">            decrRefCount(rl-&gt;key);</div><div class="line">            zfree(rl);</div><div class="line">            listDelNode(l,ln);</div><div class="line">        &#125;</div><div class="line">        listRelease(l); /* We have the new list on place at this point. */</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://harleylau.github.io/2018/05/10/Redis源码剖析-列表t-list实现/" data-id="cjhvc3fp800053m68h06irtc2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/">redis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码/">源码</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/05/31/Redis源码剖析-quicklist/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Redis源码剖析--quicklist
        
      </div>
    </a>
  
  
    <a href="/2018/05/09/Redis源码剖析-字符串t-string实现/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Redis源码剖析--字符串t_string实现</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JWT/">JWT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tornado/">Tornado</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tornado/">tornado</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/websocket/">websocket</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/二维码/">二维码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/源码/">源码</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/JWT/" style="font-size: 10px;">JWT</a> <a href="/tags/Python/" style="font-size: 10px;">Python</a> <a href="/tags/Tornado/" style="font-size: 10px;">Tornado</a> <a href="/tags/redis/" style="font-size: 20px;">redis</a> <a href="/tags/tornado/" style="font-size: 15px;">tornado</a> <a href="/tags/websocket/" style="font-size: 10px;">websocket</a> <a href="/tags/二维码/" style="font-size: 10px;">二维码</a> <a href="/tags/源码/" style="font-size: 20px;">源码</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/05/31/Redis源码剖析-quicklist/">Redis源码剖析--quicklist</a>
          </li>
        
          <li>
            <a href="/2018/05/10/Redis源码剖析-列表t-list实现/">Redis源码剖析--列表t_list实现</a>
          </li>
        
          <li>
            <a href="/2018/05/09/Redis源码剖析-字符串t-string实现/">Redis源码剖析--字符串t_string实现</a>
          </li>
        
          <li>
            <a href="/2018/02/12/tornado-websocket实现二维码扫描/">tornado websocket实现二维码扫描</a>
          </li>
        
          <li>
            <a href="/2018/02/12/tornado之WebSocket/">tornado之WebSocket</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 Harley Liu<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>