<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Redis源码剖析-dict字典 | Harley_Lau</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="改换一下策略，不直接介绍源码，打算先整体介绍一下思路，然后再根据源码解释具体的实现。  如图所示，一个dict字典中由两个hashtable组成，分别为ht[0]和ht[1]，用到的基本上都是ht[0]。 那么ht[1]什么时候用到呢？因为hash算出来的索引值是有可能重复的，也就是说不同的dictEntry有可能位于同一个hashtable的槽内，如果拥有的dictEntry的数量和slot的数">
<meta name="keywords" content="redis,源码">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis源码剖析-dict字典">
<meta property="og:url" content="https://harleylau.github.io/2017/07/31/Redis源码剖析-dict字典/index.html">
<meta property="og:site_name" content="Harley_Lau">
<meta property="og:description" content="改换一下策略，不直接介绍源码，打算先整体介绍一下思路，然后再根据源码解释具体的实现。  如图所示，一个dict字典中由两个hashtable组成，分别为ht[0]和ht[1]，用到的基本上都是ht[0]。 那么ht[1]什么时候用到呢？因为hash算出来的索引值是有可能重复的，也就是说不同的dictEntry有可能位于同一个hashtable的槽内，如果拥有的dictEntry的数量和slot的数">
<meta property="og:image" content="https://harleylau.github.io/2017/07/31/Redis源码剖析-dict字典/dict.png">
<meta property="og:updated_time" content="2017-08-02T08:09:25.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Redis源码剖析-dict字典">
<meta name="twitter:description" content="改换一下策略，不直接介绍源码，打算先整体介绍一下思路，然后再根据源码解释具体的实现。  如图所示，一个dict字典中由两个hashtable组成，分别为ht[0]和ht[1]，用到的基本上都是ht[0]。 那么ht[1]什么时候用到呢？因为hash算出来的索引值是有可能重复的，也就是说不同的dictEntry有可能位于同一个hashtable的槽内，如果拥有的dictEntry的数量和slot的数">
<meta name="twitter:image" content="https://harleylau.github.io/2017/07/31/Redis源码剖析-dict字典/dict.png">
  
    <link rel="alternate" href="/atom.xml" title="Harley_Lau" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Harley_Lau</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://harleylau.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Redis源码剖析-dict字典" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/31/Redis源码剖析-dict字典/" class="article-date">
  <time datetime="2017-07-31T08:36:53.000Z" itemprop="datePublished">2017-07-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Redis源码剖析-dict字典
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>改换一下策略，不直接介绍源码，打算先整体介绍一下思路，然后再根据源码解释具体的实现。</p>
<p><img src="/2017/07/31/Redis源码剖析-dict字典/dict.png" alt="logo"></p>
<p>如图所示，一个dict字典中由两个hashtable组成，分别为ht[0]和ht[1]，用到的基本上都是ht[0]。 那么ht[1]什么时候用到呢？因为hash算出来的索引值是有可能重复的，也就是说不同的dictEntry有可能位于同一个hashtable的槽内，如果拥有的dictEntry的数量和slot的数量的比值超过了5，相当于平均每个slot拥有5个以上的dictEntry的时候，就需要重新rehash整个dict。</p>
<p>扩展或者收缩dict的时候，并不是一次性完成的， 因为如果dict中拥有大量数据的时候，一次性的操作有可能会影响正式的服务。</p>
<p>所以redis采取的策略是分布式的rehash。 利用rehashidx来记录当前进行到了哪个索引，下一次的rehash从这个索引开始。那什么时候进行rehash呢，有两种策略， 一种是在指定时间内执行固定步数；另一种是在每次对当前dict进行查询、修改的时候，每一次操作都附带完成一个索引值的rehash。这样就把整体的rehash时间平摊到了各个小操作中。</p>
<p>在rehash的过程中，如果执行查询操作，两个ht都需要查询；修改和删除也需要操作两个ht，插入的时候，只需要插入到ht[1]，这样就保证了ht[0]里边的键值对只少不多。</p>
<h2 id="Dict定义"><a href="#Dict定义" class="headerlink" title="Dict定义"></a>Dict定义</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">typedef struct dict &#123;</div><div class="line">    dictType *type;  // 类型特定函数</div><div class="line">    void *privdata;  // 私有数据</div><div class="line">    dictht ht[2];    // 2个哈希表</div><div class="line">    // rehash 索引</div><div class="line">    // 当 rehash 不在进行时，值为 -1</div><div class="line">    long rehashidx; /* rehashing not in progress if rehashidx == -1 */</div><div class="line">    // 目前正在运行的安全迭代器的数量</div><div class="line">    unsigned long iterators; /* number of iterators currently running */</div><div class="line">&#125; dict;</div></pre></td></tr></table></figure>
<p>dictType保存一些用于操作特定类型键值对的函数，定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">typedef struct dictType &#123;</div><div class="line">    // 计算哈希值的函数</div><div class="line">    uint64_t (*hashFunction)(const void *key);</div><div class="line">    // 复制键的函数</div><div class="line">    void *(*keyDup)(void *privdata, const void *key);</div><div class="line">    // 复制值的函数</div><div class="line">    void *(*valDup)(void *privdata, const void *obj);</div><div class="line">    // 比较键的函数</div><div class="line">    int (*keyCompare)(void *privdata, const void *key1, const void *key2);</div><div class="line">    // 销毁键的函数</div><div class="line">    void (*keyDestructor)(void *privdata, void *key);</div><div class="line">    // 销毁值的函数</div><div class="line">    void (*valDestructor)(void *privdata, void *obj);</div><div class="line">&#125; dictType;</div></pre></td></tr></table></figure>
<p>dicht哈希表，所有的键值对保存在里边，定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">typedef struct dictht &#123;</div><div class="line">    dictEntry **table;  // 哈希数组</div><div class="line">    unsigned long size;  // 总的哈希表大小</div><div class="line">    // 哈希表大小掩码，用于计算索引值</div><div class="line">    // 总是等于 size - 1</div><div class="line">    unsigned long sizemask;  </div><div class="line">    unsigned long used;  // 该哈希表已有节点的数量</div><div class="line">&#125; dictht;</div></pre></td></tr></table></figure>
<p>dictEntry则保存了每一个具体的键值对，定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">typedef struct dictEntry &#123;</div><div class="line">    // 键</div><div class="line">    void *key;</div><div class="line">    union &#123;</div><div class="line">        void *val;</div><div class="line">        uint64_t u64;</div><div class="line">        int64_t s64;</div><div class="line">        double d;</div><div class="line">    &#125; v; // 值</div><div class="line">    // 指向下一个结点，因为hash值有可能冲突，冲突的时候链表形式保存在同一个索引后边</div><div class="line">    struct dictEntry *next;</div><div class="line">&#125; dictEntry;</div></pre></td></tr></table></figure>
<h2 id="Dict操作"><a href="#Dict操作" class="headerlink" title="Dict操作"></a>Dict操作</h2><h3 id="判断是否需要进行rehash"><a href="#判断是否需要进行rehash" class="headerlink" title="判断是否需要进行rehash"></a>判断是否需要进行rehash</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">/* Resize the table to the minimal size that contains all the elements,</div><div class="line"> * but with the invariant of a USED/BUCKETS ratio near to &lt;= 1 */</div><div class="line">int dictResize(dict *d)</div><div class="line">&#123;</div><div class="line">    int minimal;</div><div class="line">    // 不能在关闭 rehash 或者正在 rehash 的时候调用</div><div class="line">    if (!dict_can_resize || dictIsRehashing(d)) return DICT_ERR;</div><div class="line">    // 查看已经使用了多少结点，最少分配DICT_HT_INITIAL_SIZE=4个结点</div><div class="line">    // 否则，计算让比率接近 1：1 所需要的最少节点数量</div><div class="line">    minimal = d-&gt;ht[0].used;</div><div class="line">    if (minimal &lt; DICT_HT_INITIAL_SIZE)</div><div class="line">        minimal = DICT_HT_INITIAL_SIZE;</div><div class="line">    return dictExpand(d, minimal);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Expand or create the hash table */</div><div class="line">/*</div><div class="line"> * 创建一个新的哈希表，并根据字典的情况，选择以下其中一个动作来进行：</div><div class="line"> *</div><div class="line"> * 1) 如果字典的 0 号哈希表为空，那么将新哈希表设置为 0 号哈希表</div><div class="line"> * 2) 如果字典的 0 号哈希表非空，那么将新哈希表设置为 1 号哈希表，</div><div class="line"> *    并打开字典的 rehash 标识，使得程序可以开始对字典进行 rehash</div><div class="line"> *</div><div class="line"> * size 参数不够大，或者 rehash 已经在进行时，返回 DICT_ERR 。</div><div class="line"> *</div><div class="line"> * 成功创建 0 号哈希表，或者 1 号哈希表时，返回 DICT_OK 。</div><div class="line"> */</div><div class="line">int dictExpand(dict *d, unsigned long size)</div><div class="line">&#123;</div><div class="line">    dictht n; /* the new hash table */</div><div class="line">    // 计算大于size的第一个2的N次方的值，用来当作新的哈希表的大小</div><div class="line">    unsigned long realsize = _dictNextPower(size);</div><div class="line"></div><div class="line">    /* the size is invalid if it is smaller than the number of</div><div class="line">     * elements already inside the hash table */</div><div class="line">    if (dictIsRehashing(d) || d-&gt;ht[0].used &gt; size)</div><div class="line">        return DICT_ERR;</div><div class="line"></div><div class="line">    /* Rehashing to the same table size is not useful. */</div><div class="line">    // 如果新表大小跟老表一样， 没有进行expand的需要</div><div class="line">    if (realsize == d-&gt;ht[0].size) return DICT_ERR;</div><div class="line"></div><div class="line">    /* Allocate the new hash table and initialize all pointers to NULL */</div><div class="line">    n.size = realsize;</div><div class="line">    n.sizemask = realsize-1;</div><div class="line">    n.table = zcalloc(realsize*sizeof(dictEntry*));</div><div class="line">    n.used = 0;</div><div class="line"></div><div class="line">    /* Is this the first initialization? If so it&apos;s not really a rehashing</div><div class="line">     * we just set the first hash table so that it can accept keys. */</div><div class="line">     // 如果 0 号哈希表为空，那么这是一次初始化：</div><div class="line">     // 程序将新哈希表赋给 0 号哈希表的指针，然后字典就可以开始处理键值对了。</div><div class="line">    if (d-&gt;ht[0].table == NULL) &#123;</div><div class="line">        d-&gt;ht[0] = n;</div><div class="line">        return DICT_OK;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* Prepare a second hash table for incremental rehashing */</div><div class="line">    // 如果 0 号哈希表非空，那么这是一次 rehash ：</div><div class="line">    // 程序将新哈希表设置为 1 号哈希表，</div><div class="line">    // 并将字典的 rehash 标识打开，让程序可以开始对字典进行 rehash</div><div class="line">    d-&gt;ht[1] = n;</div><div class="line">    d-&gt;rehashidx = 0;</div><div class="line">    return DICT_OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="rehash算法"><a href="#rehash算法" class="headerlink" title="rehash算法"></a>rehash算法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line">/* Performs N steps of incremental rehashing. Returns 1 if there are still</div><div class="line"> * keys to move from the old to the new hash table, otherwise 0 is returned.</div><div class="line"> * 执行 N 步渐进式 rehash 。</div><div class="line"> *</div><div class="line"> * 返回 1 表示仍有键需要从 0 号哈希表移动到 1 号哈希表，</div><div class="line"> * 返回 0 则表示所有键都已经迁移完毕。</div><div class="line"> * Note that a rehashing step consists in moving a bucket (that may have more</div><div class="line"> * than one key as we use chaining) from the old to the new hash table, however</div><div class="line"> * since part of the hash table may be composed of empty spaces, it is not</div><div class="line"> * guaranteed that this function will rehash even a single bucket, since it</div><div class="line"> * will visit at max N*10 empty buckets in total, otherwise the amount of</div><div class="line"> * work it does would be unbound and the function may block for a long time.</div><div class="line"> * 每步 rehash 都是以一个哈希表索引（桶）作为单位的，</div><div class="line"> * 一个桶里可能会有多个节点，</div><div class="line"> * 被 rehash 的桶里的所有节点都会被移动到新哈希表。*/</div><div class="line">int dictRehash(dict *d, int n) &#123;</div><div class="line">    // 由于hash表中的桶有可能为空，设置最大访问空桶的数量为n*10，否则如果空桶很多的话会等待比较长的一段时间</div><div class="line">    int empty_visits = n*10; /* Max number of empty buckets to visit. */</div><div class="line">    // 只可以在 rehash 进行中时执行</div><div class="line">    if (!dictIsRehashing(d)) return 0;</div><div class="line"></div><div class="line">    while(n-- &amp;&amp; d-&gt;ht[0].used != 0) &#123;</div><div class="line">        dictEntry *de, *nextde;</div><div class="line"></div><div class="line">        /* Note that rehashidx can&apos;t overflow as we are sure there are more</div><div class="line">         * elements because ht[0].used != 0 */</div><div class="line">        // 确保 rehashidx 没有越界</div><div class="line">        assert(d-&gt;ht[0].size &gt; (unsigned long)d-&gt;rehashidx);</div><div class="line">        // 略过数组中为空的索引，找到下一个非空索引</div><div class="line">        // 如果访问的空索引达到了n*10， 停止遍历</div><div class="line">        while(d-&gt;ht[0].table[d-&gt;rehashidx] == NULL) &#123;</div><div class="line">            d-&gt;rehashidx++;</div><div class="line">            if (--empty_visits == 0) return 1;</div><div class="line">        &#125;</div><div class="line">        // 指向该索引的链表表头节点</div><div class="line">        de = d-&gt;ht[0].table[d-&gt;rehashidx];</div><div class="line">        /* Move all the keys in this bucket from the old to the new hash HT */</div><div class="line">        // 将链表中的所有节点迁移到新哈希表</div><div class="line">        while(de) &#123;</div><div class="line">            unsigned int h;</div><div class="line"></div><div class="line">            nextde = de-&gt;next;</div><div class="line">            /* Get the index in the new hash table */</div><div class="line">            // 根据新表的sizemask计算哈希值</div><div class="line">            h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[1].sizemask;</div><div class="line">            // 插入节点到新哈希表</div><div class="line">            de-&gt;next = d-&gt;ht[1].table[h];</div><div class="line">            d-&gt;ht[1].table[h] = de;</div><div class="line">            // 更新计数器</div><div class="line">            d-&gt;ht[0].used--;</div><div class="line">            d-&gt;ht[1].used++;</div><div class="line">            de = nextde;</div><div class="line">        &#125;</div><div class="line">        // 将刚迁移完的哈希表索引的指针设为空</div><div class="line">        d-&gt;ht[0].table[d-&gt;rehashidx] = NULL;</div><div class="line">        // 更新 rehash 索引</div><div class="line">        d-&gt;rehashidx++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* Check if we already rehashed the whole table... */</div><div class="line">    // 如果 0 号哈希表为空，那么表示 rehash 执行完毕</div><div class="line">    if (d-&gt;ht[0].used == 0) &#123;</div><div class="line">        // 释放 0 号哈希表</div><div class="line">        zfree(d-&gt;ht[0].table);</div><div class="line">        // 将原来的 1 号哈希表设置为新的 0 号哈希表</div><div class="line">        d-&gt;ht[0] = d-&gt;ht[1];</div><div class="line">        // 重置旧的 1 号哈希表</div><div class="line">        _dictReset(&amp;d-&gt;ht[1]);</div><div class="line">        // 关闭 rehash 标识</div><div class="line">        d-&gt;rehashidx = -1;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* More to rehash... */</div><div class="line">    return 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在两种情况下会调用rehash的操作，一种是在指定时间内执行操作，每次操作进行100步：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">/* Rehash for an amount of time between ms milliseconds and ms+1 milliseconds */</div><div class="line">int dictRehashMilliseconds(dict *d, int ms) &#123;</div><div class="line">    // 记录开始时间</div><div class="line">    long long start = timeInMilliseconds();</div><div class="line">    int rehashes = 0;</div><div class="line"></div><div class="line">    while(dictRehash(d,100)) &#123;</div><div class="line">        // 在给定毫秒数内，以 100 步为单位，对字典进行 rehash</div><div class="line">        rehashes += 100;</div><div class="line">        // 如果时间已过，跳出</div><div class="line">        if (timeInMilliseconds()-start &gt; ms) break;</div><div class="line">    &#125;</div><div class="line">    return rehashes;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另一种是在执行普通的查询或者更新操作的时候，同时执行一次rehash</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/* This function is called by common lookup or update operations in the</div><div class="line"> * dictionary so that the hash table automatically migrates from H1 to H2</div><div class="line"> * while it is actively used. */</div><div class="line">static void _dictRehashStep(dict *d) &#123;</div><div class="line">    if (d-&gt;iterators == 0) dictRehash(d,1);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Dict插入键"><a href="#Dict插入键" class="headerlink" title="Dict插入键"></a>Dict插入键</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">/* Add an element to the target hash table */</div><div class="line">int dictAdd(dict *d, void *key, void *val)</div><div class="line">&#123;</div><div class="line">    // 往字典中添加一个key</div><div class="line">    dictEntry *entry = dictAddRaw(d,key,NULL);</div><div class="line"></div><div class="line">    if (!entry) return DICT_ERR;</div><div class="line">    // 如果成功返回， 为key是指value</div><div class="line">    dictSetVal(d, entry, val);</div><div class="line">    return DICT_OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line">dictEntry *dictAddRaw(dict *d, void *key, dictEntry **existing)</div><div class="line">&#123;</div><div class="line">    int index;</div><div class="line">    dictEntry *entry;</div><div class="line">    dictht *ht;</div><div class="line"></div><div class="line">    // 如果在进行rehash操作， 执行一步rehash</div><div class="line">    if (dictIsRehashing(d)) _dictRehashStep(d);</div><div class="line"></div><div class="line">    /* Get the index of the new element, or -1 if</div><div class="line">     * the element already exists. */</div><div class="line">     // 获取key的索引，如果索引已经存在，返回NULL</div><div class="line">    if ((index = _dictKeyIndex(d, key, dictHashKey(d,key), existing)) == -1)</div><div class="line">        return NULL;</div><div class="line"></div><div class="line">    /* Allocate the memory and store the new entry.</div><div class="line">     * Insert the element in top, with the assumption that in a database</div><div class="line">     * system it is more likely that recently added entries are accessed</div><div class="line">     * more frequently. */</div><div class="line">     // 是否在进行rehash操作，如果在rehash， 放到新表ht[1]， 否则放到ht[0]</div><div class="line">    ht = dictIsRehashing(d) ? &amp;d-&gt;ht[1] : &amp;d-&gt;ht[0];</div><div class="line">    entry = zmalloc(sizeof(*entry));</div><div class="line">    // 插入新结点</div><div class="line">    entry-&gt;next = ht-&gt;table[index];</div><div class="line">    ht-&gt;table[index] = entry;</div><div class="line">    ht-&gt;used++;</div><div class="line"></div><div class="line">    /* Set the hash entry fields. */</div><div class="line">    dictSetKey(d, entry, key);</div><div class="line">    return entry;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="添加或更新元素"><a href="#添加或更新元素" class="headerlink" title="添加或更新元素"></a>添加或更新元素</h3><ul>
<li>如果之前元素不存在，添加成功后返回1</li>
<li>如果之前元素存在，更新元素，同时返回0</li>
<li>如果存在的话，设置新的值，然后释放老的值，这样做能够充分利用引用计数，如果是同一个元素的话，更改计数就行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">int dictReplace(dict *d, void *key, void *val)</div><div class="line">&#123;</div><div class="line">    dictEntry *entry, *existing, auxentry;</div><div class="line"></div><div class="line">    /* Try to add the element. If the key</div><div class="line">     * does not exists dictAdd will suceed. */</div><div class="line">    // 添加键值对，如果之前不存在的话，添加成功返回1</div><div class="line">    entry = dictAddRaw(d,key,&amp;existing);</div><div class="line">    if (entry) &#123;</div><div class="line">        dictSetVal(d, entry, val);</div><div class="line">        return 1;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* Set the new value and free the old one. Note that it is important</div><div class="line">     * to do that in this order, as the value may just be exactly the same</div><div class="line">     * as the previous one. In this context, think to reference counting,</div><div class="line">     * you want to increment (set), and then decrement (free), and not the</div><div class="line">     * reverse. */</div><div class="line">    // 如果存在的话，设置新的值，然后释放老的值，这样做能够充分利用引用计数，如果是同一个元素的话，更改计数就行</div><div class="line">    auxentry = *existing;</div><div class="line">    dictSetVal(d, existing, val);</div><div class="line">    dictFreeVal(d, &amp;auxentry);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="删除键值对"><a href="#删除键值对" class="headerlink" title="删除键值对"></a>删除键值对</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">static dictEntry *dictGenericDelete(dict *d, const void *key, int nofree) &#123;</div><div class="line">    unsigned int h, idx;</div><div class="line">    dictEntry *he, *prevHe;</div><div class="line">    int table;</div><div class="line"></div><div class="line">    // 如果两个哈希表都没有元素， 返回NULL</div><div class="line">    if (d-&gt;ht[0].used == 0 &amp;&amp; d-&gt;ht[1].used == 0) return NULL;</div><div class="line"></div><div class="line">    // 如果正在进行rehash，先执行一步rehash</div><div class="line">    if (dictIsRehashing(d)) _dictRehashStep(d);</div><div class="line">    h = dictHashKey(d, key);</div><div class="line"></div><div class="line">    // 两个表都要查看</div><div class="line">    for (table = 0; table &lt;= 1; table++) &#123;</div><div class="line">        idx = h &amp; d-&gt;ht[table].sizemask;</div><div class="line">        he = d-&gt;ht[table].table[idx];</div><div class="line">        prevHe = NULL;</div><div class="line">        while(he) &#123;</div><div class="line">            if (key==he-&gt;key || dictCompareKeys(d, key, he-&gt;key)) &#123;</div><div class="line">                /* Unlink the element from the list */</div><div class="line">                if (prevHe)</div><div class="line">                    prevHe-&gt;next = he-&gt;next;</div><div class="line">                else</div><div class="line">                    d-&gt;ht[table].table[idx] = he-&gt;next;</div><div class="line">                if (!nofree) &#123;</div><div class="line">                    dictFreeKey(d, he);</div><div class="line">                    dictFreeVal(d, he);</div><div class="line">                    zfree(he);</div><div class="line">                &#125;</div><div class="line">                d-&gt;ht[table].used--;</div><div class="line">                return he;</div><div class="line">            &#125;</div><div class="line">            prevHe = he;</div><div class="line">            he = he-&gt;next;</div><div class="line">        &#125;</div><div class="line">        // 如果没有在进行rehash，说明ht[1]没有值，就不用查看了</div><div class="line">        if (!dictIsRehashing(d)) break;</div><div class="line">    &#125;</div><div class="line">    return NULL; /* not found */</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>参数中的nofree用来标记是否真的删除，如果这个值为1的话，只是把这个键值对从table中拿下来，但并不是真的删除；如果想要移除一个键值对，但是在真的删除之前还想使用它的值，这个操作是有用的。</p>
<p>如果没有这个操作，需要先执行find操作找到结点，使用之后再执行删除，就需要进行两次查找；而这个操作只需要进行一次查找，用完之后再调用dictFreeUnlinkedEntry释放这个键值对就行。</p>
<h3 id="查看key的值"><a href="#查看key的值" class="headerlink" title="查看key的值"></a>查看key的值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">dictEntry *dictFind(dict *d, const void *key)</div><div class="line">&#123;</div><div class="line">    dictEntry *he;</div><div class="line">    unsigned int h, idx, table;</div><div class="line"></div><div class="line">    // 如果没有键值对，返回NULL</div><div class="line">    if (d-&gt;ht[0].used + d-&gt;ht[1].used == 0) return NULL; /* dict is empty */</div><div class="line">    // 如果正在进行rehash，先进行一次rehash</div><div class="line">    if (dictIsRehashing(d)) _dictRehashStep(d);</div><div class="line">    // 计算hash值</div><div class="line">    h = dictHashKey(d, key);</div><div class="line">    for (table = 0; table &lt;= 1; table++) &#123;</div><div class="line">        // 计算索引值</div><div class="line">        idx = h &amp; d-&gt;ht[table].sizemask;</div><div class="line">        he = d-&gt;ht[table].table[idx];</div><div class="line">        while(he) &#123;</div><div class="line">            if (key==he-&gt;key || dictCompareKeys(d, key, he-&gt;key))</div><div class="line">                return he;</div><div class="line">            he = he-&gt;next;</div><div class="line">        &#125;</div><div class="line">        // 如果没有在进行rehash，没有查看ht[1]的必要</div><div class="line">        if (!dictIsRehashing(d)) return NULL;</div><div class="line">    &#125;</div><div class="line">    return NULL;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void *dictFetchValue(dict *d, const void *key) &#123;</div><div class="line">    dictEntry *he;</div><div class="line"></div><div class="line">    he = dictFind(d,key);</div><div class="line">    return he ? dictGetVal(he) : NULL;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此外还有一个遍历dict的操作，如果dict保持不变，直接按照索引顺序遍历就行，但是由于dict存在扩大和缩小的可能性，如果和做到在扩大或缩小的同时，遍历dict能够不漏掉所有键值对呢，这个算法比较复杂， 单独开一篇研究。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://harleylau.github.io/2017/07/31/Redis源码剖析-dict字典/" data-id="cj6yh8hwf00012g67nlguxk8i" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/">redis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码/">源码</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/08/02/Redis源码剖析-dict遍历算法/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Redis源码剖析-dict遍历算法
        
      </div>
    </a>
  
  
    <a href="/2017/07/31/Redis源码剖析-链表list/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Redis源码剖析-链表list</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JWT/">JWT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tornado/">Tornado</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/源码/">源码</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/JWT/" style="font-size: 10px;">JWT</a> <a href="/tags/Python/" style="font-size: 10px;">Python</a> <a href="/tags/Tornado/" style="font-size: 10px;">Tornado</a> <a href="/tags/redis/" style="font-size: 20px;">redis</a> <a href="/tags/源码/" style="font-size: 20px;">源码</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/08/29/Redis源码剖析-整数集合/">Redis源码剖析--整数集合</a>
          </li>
        
          <li>
            <a href="/2017/08/24/Redis源码剖析-跳跃表/">Redis源码剖析--跳跃表</a>
          </li>
        
          <li>
            <a href="/2017/08/02/Redis源码剖析-dict遍历算法/">Redis源码剖析-dict遍历算法</a>
          </li>
        
          <li>
            <a href="/2017/07/31/Redis源码剖析-dict字典/">Redis源码剖析-dict字典</a>
          </li>
        
          <li>
            <a href="/2017/07/31/Redis源码剖析-链表list/">Redis源码剖析-链表list</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 Harley Liu<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>