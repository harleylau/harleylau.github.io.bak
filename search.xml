<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[Redis源码剖析--对象Object]]></title>
      <url>/2017/09/07/Redis%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%AF%B9%E8%B1%A1Object/</url>
      <content type="html"><![CDATA[<p>之前介绍的都是Redis的基础数据结构，比如简单动态字符串（SDS）、双端链表、字典、压缩列表、整数集合， 等等，不过Redis并没有直接用这些结构来实现键值对的数据库，而是对其进行了封装， 所有的键和值都是用对象Object来表示的。</p>
<p>Redis构建的对象分为5类， 字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象， 分别对应Redis操作中的string、list、hash、set和zset。</p>
<h2 id="对象的结构"><a href="#对象的结构" class="headerlink" title="对象的结构"></a>对象的结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">typedef struct redisObject &#123;</div><div class="line">    unsigned type:4;</div><div class="line">    unsigned encoding:4;</div><div class="line">    unsigned lru:LRU_BITS; // LRU_BITS为24</div><div class="line">    int refcount;</div><div class="line">    void *ptr;</div><div class="line">&#125; robj;</div></pre></td></tr></table></figure>
<p>type表示类型， encoding表示编码，prt表示指向底层数据实现的指针。</p>
<p>refcount用来实现基于引用计数技术的内存回收机制：通过引用计数技术实现了对象共享机制， 这一机制可以在适当的条件下， 通过让多个数据库键共享同一个对象来节约内存。</p>
<h3 id="类型type"><a href="#类型type" class="headerlink" title="类型type"></a>类型type</h3><p>上面说到Redis中有5中对象类型，对应的定义如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#define OBJ_STRING 0</div><div class="line">#define OBJ_LIST 1</div><div class="line">#define OBJ_SET 2</div><div class="line">#define OBJ_ZSET 3</div><div class="line">#define OBJ_HASH 4</div></pre></td></tr></table></figure>
<p>对于 Redis 数据库保存的键值对来说， 键总是一个字符串对象， 而值则可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象的其中一种。</p>
<h3 id="编码和底层实现"><a href="#编码和底层实现" class="headerlink" title="编码和底层实现"></a>编码和底层实现</h3><p>Redis对象的编码方式由encoding参数指定，也就是表示ptr指向的数据以何种数据结构作为底层实现。该字段也占用4个bit位。其取值和对应类型对应如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#define OBJ_ENCODING_RAW 0     /* Raw representation */</div><div class="line">#define OBJ_ENCODING_INT 1     /* Encoded as integer */</div><div class="line">#define OBJ_ENCODING_HT 2      /* Encoded as hash table */</div><div class="line">#define OBJ_ENCODING_ZIPMAP 3  /* Encoded as zipmap */</div><div class="line">#define OBJ_ENCODING_LINKEDLIST 4 /* Encoded as regular linked list */</div><div class="line">#define OBJ_ENCODING_ZIPLIST 5 /* Encoded as ziplist */</div><div class="line">#define OBJ_ENCODING_INTSET 6  /* Encoded as intset */</div><div class="line">#define OBJ_ENCODING_SKIPLIST 7  /* Encoded as skiplist */</div><div class="line">#define OBJ_ENCODING_EMBSTR 8  /* Embedded sds string encoding */</div><div class="line">#define OBJ_ENCODING_QUICKLIST 9 /* Encoded as linked list of ziplists */</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>编码常量</th>
<th>编码所对应的底层数据结构</th>
</tr>
</thead>
<tbody>
<tr>
<td>REDIS_ENCODING_INT</td>
<td>long 类型的整数</td>
</tr>
<tr>
<td>REDIS_ENCODING_EMBSTR</td>
<td>embstr 编码的简单动态字符串</td>
</tr>
<tr>
<td>REDIS_ENCODING_RAW</td>
<td>简单动态字符串</td>
</tr>
<tr>
<td>REDIS_ENCODING_HT</td>
<td>字典</td>
</tr>
<tr>
<td>REDIS_ENCODING_LINKEDLIST</td>
<td>双端链表</td>
</tr>
<tr>
<td>REDIS_ENCODING_ZIPLIST</td>
<td>压缩列表</td>
</tr>
<tr>
<td>REDIS_ENCODING_INTSET</td>
<td>整数集合</td>
</tr>
<tr>
<td>REDIS_ENCODING_SKIPLIST</td>
<td>跳跃表和字典</td>
</tr>
</tbody>
</table>
<p>Redis中的5中类型的对象，都对应着不止一种的底层实现</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>编码</th>
<th>对象</th>
</tr>
</thead>
<tbody>
<tr>
<td>REDIS_STRING</td>
<td>REDIS_ENCODING_INT</td>
<td>使用整数值实现的字符串对象。</td>
</tr>
<tr>
<td>REDIS_STRING</td>
<td>REDIS_ENCODING_EMBSTR</td>
<td>使用 embstr 编码的简单动态字符串实现的字符串对象。</td>
</tr>
<tr>
<td>REDIS_STRING</td>
<td>REDIS_ENCODING_RAW</td>
<td>使用简单动态字符串实现的字符串对象。</td>
</tr>
<tr>
<td>REDIS_LIST</td>
<td>REDIS_ENCODING_ZIPLIST</td>
<td>使用压缩列表实现的列表对象。</td>
</tr>
<tr>
<td>REDIS_LIST</td>
<td>REDIS_ENCODING_LINKEDLIST</td>
<td>使用双端链表实现的列表对象。</td>
</tr>
<tr>
<td>REDIS_HASH</td>
<td>REDIS_ENCODING_ZIPLIST</td>
<td>使用压缩列表实现的哈希对象。</td>
</tr>
<tr>
<td>REDIS_HASH</td>
<td>REDIS_ENCODING_HT</td>
<td>使用字典实现的哈希对象。</td>
</tr>
<tr>
<td>REDIS_SET</td>
<td>REDIS_ENCODING_INTSET</td>
<td>使用整数集合实现的集合对象。</td>
</tr>
<tr>
<td>REDIS_SET</td>
<td>REDIS_ENCODING_HT</td>
<td>使用字典实现的集合对象。</td>
</tr>
<tr>
<td>REDIS_ZSET</td>
<td>REDIS_ENCODING_ZIPLIST</td>
<td>使用压缩列表实现的有序集合对象。</td>
</tr>
<tr>
<td>REDIS_ZSET</td>
<td>REDIS_ENCODING_SKIPLIST</td>
<td>使用跳跃表和字典实现的有序集合对象。</td>
</tr>
</tbody>
</table>
<p>通过encoding参数来区分底层的实现，这样既灵活，也能节省内存。比如hash表的实现的时候，当元素比较少的时候，可以用压缩列表来实现；当元素不断增长，压缩列表失去优势的时候，就将其转化成hash table来实现。</p>
<p>之后几篇分别介绍 Redis 中的五种不同类型的对象， 说明这些对象底层所使用的编码方式。 由于每种对象类型都有不止一种底层结构，所以同时列出对象从一种编码转换成另一种编码所需的条件， 以及同一个命令在多种不同编码上的实现方法。</p>
]]></content>
      
        
        <tags>
            
            <tag> redis </tag>
            
            <tag> 源码 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[tornado--打印block日志]]></title>
      <url>/2017/09/07/tornado-%E6%89%93%E5%8D%B0block%E6%97%A5%E5%BF%97/</url>
      <content type="html"><![CDATA[<p>Tornado在使用过程，碰到过性能瓶颈。 当碰到Tornado中有比较耗时的任务的时候，请求一多就会阻塞整个服务。这个时候就需要查看到底是什么任务阻塞了服务，然后针对性的进行优化。</p>
<p>Tornado使用logging打印日志，我们可以指定当某个请求的处理时间超过设定时间的时候，打印这个请求的stack trace。</p>
<p>源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">def set_blocking_log_threshold(self, seconds):</div><div class="line">       &quot;&quot;&quot;Logs a stack trace if the `IOLoop` is blocked for more than</div><div class="line">       ``s`` seconds.</div><div class="line"></div><div class="line">       Equivalent to ``set_blocking_signal_threshold(seconds,</div><div class="line">       self.log_stack)``</div><div class="line">       &quot;&quot;&quot;</div><div class="line">       self.set_blocking_signal_threshold(seconds, self.log_stack)</div></pre></td></tr></table></figure>
<p>如何使用呢，只需要在启动服务的时候设置block的时间即可，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line"></div><div class="line">    app = create_app()</div><div class="line"></div><div class="line">    server = tornado.httpserver.HTTPServer(app)</div><div class="line">    server.listen(options.port)</div><div class="line">    io_loop = tornado.ioloop.IOLoop.instance()</div><div class="line">    io_loop.set_blocking_log_threshold(0.5)</div><div class="line">    io_loop.start()</div></pre></td></tr></table></figure>
<p>如果某个请求的处理时间超过0.5秒，就会打印该请求的栈。</p>
]]></content>
      
        
        <tags>
            
            <tag> tornado </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis源码剖析--压缩列表]]></title>
      <url>/2017/09/05/Redis%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/</url>
      <content type="html"><![CDATA[<p>压缩列表（ziplist）是列表键和哈希键的底层实现之一。<br>Redis的列表键，哈希键，有序集合的底层实现都用到了ziplist。</p>
<p>当列表键中包含比较少的元素，并且元素都是数字或者比较小的字符串的时候， redis会用压缩列表来作为列表键的底层实现。</p>
<p>当哈希键的键和值都是比较小的整数或者较短的字符的时候，也是用压缩列表来作为底层实现。 因为压缩列表也能够节省内存。</p>
<h2 id="压缩列表结构"><a href="#压缩列表结构" class="headerlink" title="压缩列表结构"></a>压缩列表结构</h2><p>压缩列表的结构如下：</p>
<p><img src="/2017/09/05/Redis源码剖析-压缩列表/ziplist.png" alt="压缩列表结构"></p>
<p>列表头包括三部分内容，分别是zlbytes，zltail，zllen</p>
<ul>
<li>zlbytes： 记录整个压缩列表占用的内存字节数：在对压缩列表进行内存重分配， 或者计算 zlend 的位置时使用。</li>
<li>zltail：记录压缩列表表尾节点距离压缩列表的起始地址有多少字节： 通过这个偏移量，程序无须遍历整个压缩列表就可以确定表尾节点的地址。</li>
<li>zllen：记录了压缩列表包含的节点数量： 当这个属性的值小于 UINT16_MAX （65535）时， 这个属性的值就是压缩列表包含节点的数量； 当这个值等于 UINT16_MAX 时， 节点的真实数量需要遍历整个压缩列表才能计算得出。</li>
</ul>
<p>压缩列表中间一次保存着各个列表项entry。</p>
<p>压缩列表尾部的zlend则表示压缩列表结束，其值固定为0xFF。</p>
<h3 id="压缩列表结点"><a href="#压缩列表结点" class="headerlink" title="压缩列表结点"></a>压缩列表结点</h3><p>先看结点的数据结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">typedef struct zlentry &#123;</div><div class="line">    unsigned int prevrawlensize, prevrawlen; // 前置节点长度和编码所需长度</div><div class="line">    unsigned int lensize, len; // 当前节点长度和编码所需长度</div><div class="line">    unsigned int headersize; // 头的大小</div><div class="line">    unsigned char encoding; // 编码类型</div><div class="line">    unsigned char *p; // 数据部分</div><div class="line">&#125; zlentry;</div></pre></td></tr></table></figure>
<p>每个压缩列表节点都由 previous_entry_length 、 encoding 、 content 三个部分组成。</p>
<h4 id="previous-entry-length"><a href="#previous-entry-length" class="headerlink" title="previous_entry_length"></a>previous_entry_length</h4><p>节点的 previous_entry_length 记录了压缩列表中前一个节点的长度。</p>
<p>previous_entry_length 属性的长度可以是 1 字节或者 5 字节：</p>
<ul>
<li>如果前一节点的长度小于 254 字节， 那么 previous_entry_length 属性的长度为 1 字节： 前一节点的长度就保存在这一个字节里面。</li>
<li>如果前一节点的长度大于等于 254 字节， 那么 previous_entry_length 属性的长度为 5 字节： 其中属性的第一字节会被设置为 0xFE （十进制值 254）， 而之后的四个字节则用于保存前一节点的长度。</li>
</ul>
<p>压缩列表zltail和previous_entry_length的存在，我们能够轻松得到一个列表的尾部，然后从尾部实现向前遍历整个压缩列表。</p>
<h4 id="encoding"><a href="#encoding" class="headerlink" title="encoding"></a>encoding</h4><p>压缩列表能够保存字节数组和整数，当读取压缩列表的时候，如何区分当前的结点存储的是字节数组还是整数呢，就需要靠encoding字段来判断。</p>
<h5 id="1、字节数组"><a href="#1、字节数组" class="headerlink" title="1、字节数组"></a>1、字节数组</h5><p>保存字节数组的时候，encoding字段可以是一字节、两字节或者五字节长， 值的最高位为 00 、 01 或者 10 ，数组的长度由编码除去最高两位之后的其他位记录。</p>
<table>
<thead>
<tr>
<th>编码</th>
<th>编码长度</th>
<th>content 属性保存的值</th>
</tr>
</thead>
<tbody>
<tr>
<td>00bbbbbb</td>
<td>1 字节</td>
<td>长度小于等于 63 字节的字节数组。</td>
</tr>
<tr>
<td>01bbbbbb xxxxxxxx</td>
<td>2 字节</td>
<td>长度小于等于 16383 字节的字节数组。</td>
</tr>
<tr>
<td>10<strong>__</strong> aaaaaaaa bbbbbbbb cccccccc dddddddd</td>
<td>5 字节</td>
<td>长度小于等于 4294967295 的字节数组。</td>
</tr>
</tbody>
</table>
<p>如上表所示，三种长度的字节数组分别用不同长度的encoding字段来表示，用来节省空间。 而encoding的前两位用来标记encoding本身的类型。</p>
<h5 id="2、整数"><a href="#2、整数" class="headerlink" title="2、整数"></a>2、整数</h5><p>保存整数的时候，encoding字段为一字节长， 值的最高位以 11 开头。 整数值的类型和长度由编码除去最高两位之后的其他位记录。</p>
<table>
<thead>
<tr>
<th>编码</th>
<th>编码长度</th>
<th>content 属性保存的值</th>
</tr>
</thead>
<tbody>
<tr>
<td>11000000</td>
<td>1 字节</td>
<td>int16_t 类型的整数。</td>
</tr>
<tr>
<td>11010000</td>
<td>1 字节</td>
<td>int32_t 类型的整数。</td>
</tr>
<tr>
<td>11100000</td>
<td>1 字节</td>
<td>int64_t 类型的整数。</td>
</tr>
<tr>
<td>11110000</td>
<td>1 字节</td>
<td>24 位有符号整数。</td>
</tr>
<tr>
<td>11111110</td>
<td>1 字节</td>
<td>8 位有符号整数。</td>
</tr>
<tr>
<td>1111xxxx</td>
<td>1 字节</td>
<td>使用这一编码的节点没有相应的 content 属性， 因为编码本身的 xxxx 四个位已经保存了一个介于 0 和 12 之间的值， 所以它无须 content 属性。</td>
</tr>
</tbody>
</table>
<p>当encoding最前两位字段为11的时候，表示当前结点为整数。 同时encoding的后几位用来表示不同的整数类型。可以看到后几位中用000000表示int16_t 类型的整数， 用010000表示int32_t 类型的整数， 用100000表示int64_t 类型的整数。</p>
<p>可以注意到，为了进一步节省内存，当编码为1111xxxx时，表示没有内容部分，xxxx已经存放了当前的整数值，包括整数0~12，即xxxx可以表示0000~1101。这样就节省了content的内存空间。这边编码为11111111代表ziplist的结尾。</p>
<h3 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h3><p>由于每个压缩列表的结点保存了上一个结点的大小，所以当前结点的变化有可能引起下一个结点的变化。如果前一节点的长度小于 254 字节， 那么 previous_entry_length 属性需要用 1 字节长的空间来保存这个长度值； 如果超过了254字节，这个属性值就需要 5 个字节的长度来保存。</p>
<p>所以最坏的情况下，压缩列表中某一个结点的更新，会引起所有结点的一个更新操作，就是所谓的连锁更新。</p>
<p>此外，插入或者删除结点也有可能引起连锁更新的操作。不过虽然连锁更新带来的消耗很大，但是仍旧可以放心的使用压缩列表，因为连锁更新引起的条件比较苛刻，概率比较小。 首先， 压缩列表里要恰好有多个连续的、长度介于 250 字节至 253 字节之间的节点， 连锁更新才有可能被引发， 在实际中， 这种情况并不多见；<br>其次， 即使出现连锁更新， 但只要被更新的节点数量不多， 就不会对性能造成任何影响： 比如说， 对三五个节点进行连锁更新是绝对不会影响性能的。</p>
<h2 id="压缩列表基本操作"><a href="#压缩列表基本操作" class="headerlink" title="压缩列表基本操作"></a>压缩列表基本操作</h2><h3 id="创建新的压缩列表"><a href="#创建新的压缩列表" class="headerlink" title="创建新的压缩列表"></a>创建新的压缩列表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/* Create a new empty ziplist. */</div><div class="line">unsigned char *ziplistNew(void) &#123;</div><div class="line">    // 空ziplist的大小为11个字节，头部10字节，尾部1字节</div><div class="line">    unsigned int bytes = ZIPLIST_HEADER_SIZE+1;</div><div class="line">    // 开辟空间</div><div class="line">    unsigned char *zl = zmalloc(bytes);</div><div class="line">    // 设定压缩列表的大小</div><div class="line">    ZIPLIST_BYTES(zl) = intrev32ifbe(bytes);</div><div class="line">    // 设置尾结点相对头部的偏移量</div><div class="line">    ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(ZIPLIST_HEADER_SIZE);</div><div class="line">    // 压缩列表结点数为0</div><div class="line">    ZIPLIST_LENGTH(zl) = 0;</div><div class="line">    // 设定尾部一个字节位0xFF</div><div class="line">    zl[bytes-1] = ZIP_END;</div><div class="line">    return zl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="插入结点"><a href="#插入结点" class="headerlink" title="插入结点"></a>插入结点</h3><p>由于连锁更新的存在，插入结点的复杂度平均 O(N) ，最坏 O(N^2)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div></pre></td><td class="code"><pre><div class="line">// ziplist插入节点只能往头或者尾部插入</div><div class="line">// zl: 待插入的ziplist</div><div class="line">// s，slen: 待插入节点和其长度</div><div class="line">// where: 带插入的位置，0代表头部插入，1代表尾部插入</div><div class="line">unsigned char *ziplistPush(unsigned char *zl, unsigned char *s, unsigned int slen, int where) &#123;</div><div class="line">    unsigned char *p;</div><div class="line">    // 获取插入的位置</div><div class="line">    p = (where == ZIPLIST_HEAD) ? ZIPLIST_ENTRY_HEAD(zl) : ZIPLIST_ENTRY_END(zl);</div><div class="line">    // 执行具体的插入过程</div><div class="line">    return __ziplistInsert(zl,p,s,slen);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Insert item at &quot;p&quot;. */</div><div class="line">unsigned char *__ziplistInsert(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen) &#123;</div><div class="line">    size_t curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), reqlen;</div><div class="line">    unsigned int prevlensize, prevlen = 0; // 前置节点长度和编码该长度值所需的长度</div><div class="line">    size_t offset;</div><div class="line">    int nextdiff = 0;</div><div class="line">    unsigned char encoding = 0;</div><div class="line">    long long value = 123456789; /* 为了防止警告，进行初始化；用一个比较特殊的值以便能够方便的观察到不恰当的使用 */</div><div class="line">    zlentry tail;</div><div class="line"></div><div class="line">    /* Find out prevlen for the entry that is inserted. */</div><div class="line">    if (p[0] != ZIP_END) &#123;</div><div class="line">        // 如果不是压缩列表的结束标志，说明p指向了一个已存在的结点</div><div class="line">        // 解码得到p的前置结点和长度</div><div class="line">        ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);</div><div class="line">    &#125; else &#123;</div><div class="line">        // 如果p指向列表末端，表示列表为空</div><div class="line">        unsigned char *ptail = ZIPLIST_ENTRY_TAIL(zl);</div><div class="line">        if (ptail[0] != ZIP_END) &#123;</div><div class="line">            prevlen = zipRawEntryLength(ptail);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* See if the entry can be encoded */</div><div class="line">    // 判断是否能够编码为整数</div><div class="line">    if (zipTryEncoding(s,slen,&amp;value,&amp;encoding)) &#123;</div><div class="line">        /* &apos;encoding&apos; is set to the appropriate integer encoding */</div><div class="line">        reqlen = zipIntSize(encoding);</div><div class="line">    &#125; else &#123;</div><div class="line">        /* &apos;encoding&apos; is untouched, however zipStoreEntryEncoding will use the</div><div class="line">         * string length to figure out how to encode it. */</div><div class="line">        // 编码为字节数组</div><div class="line">        reqlen = slen;</div><div class="line">    &#125;</div><div class="line">    /* We need space for both the length of the previous entry and</div><div class="line">     * the length of the payload. */</div><div class="line">    // 加上前置结点的编码长度和当前结点的编码长度</div><div class="line">    reqlen += zipStorePrevEntryLength(NULL,prevlen);</div><div class="line">    reqlen += zipStoreEntryEncoding(NULL,encoding,slen);</div><div class="line"></div><div class="line">    /* When the insert position is not equal to the tail, we need to</div><div class="line">     * make sure that the next entry can hold this entry&apos;s length in</div><div class="line">     * its prevlen field. */</div><div class="line">    // 如果不是插入到列表的末端，都需要判断下一个结点是否能存放新节点的长度编码</div><div class="line">    // nextdiff保存新旧编码之间的字节大小差，如果这个值大于0</div><div class="line">    // 那就说明当前p指向的节点的header进行扩展</div><div class="line">    int forcelarge = 0;</div><div class="line">    nextdiff = (p[0] != ZIP_END) ? zipPrevLenByteDiff(p,reqlen) : 0;</div><div class="line">    if (nextdiff == -4 &amp;&amp; reqlen &lt; 4) &#123;</div><div class="line">        nextdiff = 0;</div><div class="line">        forcelarge = 1;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* Store offset because a realloc may change the address of zl. */</div><div class="line">    // 保存偏移量</div><div class="line">    offset = p-zl;</div><div class="line">    // 重新分配空间，curlen当前列表的长度</div><div class="line">    // reqlen 新节点的全部长度</div><div class="line">    // nextdiff 新节点的后继节点扩展header的长度</div><div class="line">    zl = ziplistResize(zl,curlen+reqlen+nextdiff);</div><div class="line">    // 根据新的压缩列表地址得到新的p的地址</div><div class="line">    p = zl+offset;</div><div class="line"></div><div class="line">    /* Apply memory move when necessary and update tail offset. */</div><div class="line">    if (p[0] != ZIP_END) &#123;</div><div class="line">        // 如果不是表尾插入，需要更新表尾的偏移地址</div><div class="line">        /* Subtract one because of the ZIP_END bytes */</div><div class="line">        memmove(p+reqlen,p-nextdiff,curlen-offset-1+nextdiff);</div><div class="line"></div><div class="line">        /* Encode this entry&apos;s raw length in the next entry. */</div><div class="line">        // 编码新结点的长度到下一个结点中</div><div class="line">        if (forcelarge)</div><div class="line">            zipStorePrevEntryLengthLarge(p+reqlen,reqlen);</div><div class="line">        else</div><div class="line">            zipStorePrevEntryLength(p+reqlen,reqlen);</div><div class="line"></div><div class="line">        /* Update offset for tail */</div><div class="line">        ZIPLIST_TAIL_OFFSET(zl) =</div><div class="line">            intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+reqlen);</div><div class="line"></div><div class="line">        /* When the tail contains more than one entry, we need to take</div><div class="line">         * &quot;nextdiff&quot; in account as well. Otherwise, a change in the</div><div class="line">         * size of prevlen doesn&apos;t have an effect on the *tail* offset. */</div><div class="line">        zipEntry(p+reqlen, &amp;tail);</div><div class="line">        if (p[reqlen+tail.headersize+tail.len] != ZIP_END) &#123;</div><div class="line">            ZIPLIST_TAIL_OFFSET(zl) =</div><div class="line">                intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+nextdiff);</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        /* This element will be the new tail. */</div><div class="line">        ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(p-zl);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 如果nextdiff不等于0， 下一个结点的头部需要进行扩展</div><div class="line">    if (nextdiff != 0) &#123;</div><div class="line">        offset = p-zl;</div><div class="line">        zl = __ziplistCascadeUpdate(zl,p+reqlen);</div><div class="line">        p = zl+offset;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* Write the entry */</div><div class="line">    // 将新节点前置节点的长度写入新节点的header</div><div class="line">    p += zipStorePrevEntryLength(p,prevlen);</div><div class="line">    // 编码新结点</div><div class="line">    p += zipStoreEntryEncoding(p,encoding,slen);</div><div class="line">    if (ZIP_IS_STR(encoding)) &#123;</div><div class="line">        memcpy(p,s,slen);</div><div class="line">    &#125; else &#123;</div><div class="line">        zipSaveInteger(p,value,encoding);</div><div class="line">    &#125;</div><div class="line">    ZIPLIST_INCR_LENGTH(zl,1);</div><div class="line">    return zl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="查找结点"><a href="#查找结点" class="headerlink" title="查找结点"></a>查找结点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">/* 寻找节点值和 vstr 相等的列表节点，并返回该节点的指针。</div><div class="line"> * 每次比对之前都跳过 skip 个节点。</div><div class="line"> * 如果找不到相应的节点，则返回 NULL 。 */</div><div class="line">unsigned char *ziplistFind(unsigned char *p, unsigned char *vstr, unsigned int vlen, unsigned int skip) &#123;</div><div class="line">    int skipcnt = 0;</div><div class="line">    unsigned char vencoding = 0;</div><div class="line">    long long vll = 0;</div><div class="line"></div><div class="line">    // 循环直到碰到结束标志</div><div class="line">    while (p[0] != ZIP_END) &#123;</div><div class="line">        unsigned int prevlensize, encoding, lensize, len;</div><div class="line">        unsigned char *q;</div><div class="line"></div><div class="line">        // 解码得到前置结点的长度</div><div class="line">        ZIP_DECODE_PREVLENSIZE(p, prevlensize);</div><div class="line">        // 当前结点的长度</div><div class="line">        ZIP_DECODE_LENGTH(p + prevlensize, encoding, lensize, len);</div><div class="line">        q = p + prevlensize + lensize;</div><div class="line"></div><div class="line">        if (skipcnt == 0) &#123;</div><div class="line">            /* Compare current entry with specified entry */</div><div class="line">            // 如果是字节数组，直接比较</div><div class="line">            if (ZIP_IS_STR(encoding)) &#123;</div><div class="line">                if (len == vlen &amp;&amp; memcmp(q, vstr, vlen) == 0) &#123;</div><div class="line">                    return p;</div><div class="line">                &#125;</div><div class="line">            &#125; else &#123;</div><div class="line">                /* 查看目标值是否能被编码，只会在第一次循环的时候检查；</div><div class="line">                 * 检查一次之后vencoding会被置为非0 */</div><div class="line">                if (vencoding == 0) &#123;</div><div class="line">                    if (!zipTryEncoding(vstr, vlen, &amp;vll, &amp;vencoding)) &#123;</div><div class="line">                        /* 如果不能被编码，设置格式为UCHAR_MAX ， 下次不会再检查*/</div><div class="line">                        vencoding = UCHAR_MAX;</div><div class="line">                    &#125;</div><div class="line">                    /* Must be non-zero by now */</div><div class="line">                    assert(vencoding);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                /* Compare current entry with specified entry, do it only</div><div class="line">                 * if vencoding != UCHAR_MAX because if there is no encoding</div><div class="line">                 * possible for the field it can&apos;t be a valid integer. */</div><div class="line">                if (vencoding != UCHAR_MAX) &#123;</div><div class="line">                    long long ll = zipLoadInteger(q, encoding);</div><div class="line">                    if (ll == vll) &#123;</div><div class="line">                        return p;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            /* Reset skip count */</div><div class="line">            skipcnt = skip;</div><div class="line">        &#125; else &#123;</div><div class="line">            /* Skip entry */</div><div class="line">            skipcnt--;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        /* Move to next entry */</div><div class="line">        // 后移指针，指向后置节点</div><div class="line">        p = q + len;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return NULL;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="删除结点"><a href="#删除结点" class="headerlink" title="删除结点"></a>删除结点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line">// 删除给定节点，输入压缩列表zl和指向删除节点的指针p</div><div class="line">unsigned char *ziplistDelete(unsigned char *zl, unsigned char **p) &#123;</div><div class="line">    size_t offset = *p-zl;</div><div class="line">    // 调用底层函数__ziplistDelete进行删除操作</div><div class="line">    zl = __ziplistDelete(zl,*p,1);</div><div class="line">    // 删除操作可能会改变zl，因为会重新分配内存</div><div class="line">    *p = zl+offset;</div><div class="line">    return zl;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* 从位置 p 开始，连续删除 num 个节点。</div><div class="line"> * 函数的返回值为处理删除操作之后的 ziplist */</div><div class="line">unsigned char *__ziplistDelete(unsigned char *zl, unsigned char *p, unsigned int num) &#123;</div><div class="line">    unsigned int i, totlen, deleted = 0;</div><div class="line">    size_t offset;</div><div class="line">    int nextdiff = 0;</div><div class="line">    zlentry first, tail;</div><div class="line"></div><div class="line">    zipEntry(p, &amp;first);</div><div class="line">    // 计算被删除节点的总个数</div><div class="line">    for (i = 0; p[0] != ZIP_END &amp;&amp; i &lt; num; i++) &#123;</div><div class="line">        p += zipRawEntryLength(p);</div><div class="line">        deleted++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // totlen 是所有被删除节点总共占用的内存字节数</div><div class="line">    totlen = p-first.p; /* Bytes taken by the element(s) to delete. */</div><div class="line">    if (totlen &gt; 0) &#123;</div><div class="line">        if (p[0] != ZIP_END) &#123;</div><div class="line">            // 不是尾结点，表示被删除节点之后仍然有节点存在</div><div class="line">            </div><div class="line">            // 因为位于被删除范围之后的第一个节点的 header 部分的大小</div><div class="line">            // 可能容纳不了新的前置节点，所以需要计算新旧前置节点之间的字节数差</div><div class="line">            nextdiff = zipPrevLenByteDiff(p,first.prevrawlen);</div><div class="line"></div><div class="line">            /* Note that there is always space when p jumps backward: if</div><div class="line">             * the new previous entry is large, one of the deleted elements</div><div class="line">             * had a 5 bytes prevlen header, so there is for sure at least</div><div class="line">             * 5 bytes free and we need just 4. */</div><div class="line">            // 如果有需要的话，将指针 p 后退 nextdiff 字节，为新 header 空出空间</div><div class="line">            // 由于会删除之前的结点，所以肯定会有足够的空间用来扩展</div><div class="line">            p -= nextdiff;</div><div class="line">            // 将 first 的前置节点的长度编码至 p 中</div><div class="line">            zipStorePrevEntryLength(p,first.prevrawlen);</div><div class="line"></div><div class="line">            /* Update offset for tail */</div><div class="line">            ZIPLIST_TAIL_OFFSET(zl) =</div><div class="line">                intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))-totlen);</div><div class="line"></div><div class="line">            /* When the tail contains more than one entry, we need to take</div><div class="line">             * &quot;nextdiff&quot; in account as well. Otherwise, a change in the</div><div class="line">             * size of prevlen doesn&apos;t have an effect on the *tail* offset. */</div><div class="line">            // 如果被删除节点之后，有多于一个节点</div><div class="line">            // 那么程序需要将 nextdiff 记录的字节数也计算到表尾偏移量中</div><div class="line">            // 这样才能让表尾偏移量正确对齐表尾节点</div><div class="line">            zipEntry(p, &amp;tail);</div><div class="line">            if (p[tail.headersize+tail.len] != ZIP_END) &#123;</div><div class="line">                ZIPLIST_TAIL_OFFSET(zl) =</div><div class="line">                   intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+nextdiff);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            /* Move tail to the front of the ziplist */</div><div class="line">            // 从表尾向表头移动数据，覆盖被删除节点的数据</div><div class="line">            memmove(first.p,p,</div><div class="line">                intrev32ifbe(ZIPLIST_BYTES(zl))-(p-zl)-1);</div><div class="line">        &#125; else &#123;</div><div class="line">            /* The entire tail was deleted. No need to move memory. */</div><div class="line">            // 执行这里，表示被删除节点之后已经没有其他节点了， 不需要移动结点</div><div class="line">            ZIPLIST_TAIL_OFFSET(zl) =</div><div class="line">                intrev32ifbe((first.p-zl)-first.prevrawlen);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        /* Resize and update length */</div><div class="line">        // 缩小并更新 ziplist 的长度</div><div class="line">        offset = first.p-zl;</div><div class="line">        zl = ziplistResize(zl, intrev32ifbe(ZIPLIST_BYTES(zl))-totlen+nextdiff);</div><div class="line">        ZIPLIST_INCR_LENGTH(zl,-deleted);</div><div class="line">        p = zl+offset;</div><div class="line"></div><div class="line">        /* When nextdiff != 0, the raw length of the next entry has changed, so</div><div class="line">         * we need to cascade the update throughout the ziplist */</div><div class="line">        // 如果 p 所指向的节点的大小已经变更，那么进行级联更新</div><div class="line">        // 检查 p 之后的所有节点是否符合 ziplist 的编码要求</div><div class="line">        if (nextdiff != 0)</div><div class="line">            zl = __ziplistCascadeUpdate(zl,p);</div><div class="line">    &#125;</div><div class="line">    return zl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
        
        <tags>
            
            <tag> redis </tag>
            
            <tag> 源码 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis源码剖析--整数集合]]></title>
      <url>/2017/08/29/Redis%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/</url>
      <content type="html"><![CDATA[<p>整数集合（intset）是集合键的底层实现之一： 当一个集合只包含整数值元素， 并且这个集合的元素数量不多时， Redis 就会使用整数集合作为集合键的底层实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; sadd numbers 1 2 3 4 5</div><div class="line">(integer) 5</div><div class="line">127.0.0.1:6379&gt; object encoding numbers</div><div class="line">&quot;intset&quot;</div></pre></td></tr></table></figure>
<p>这么做的好处是当集合中只有少量的整数元素的时候，采用之前介绍的其他数据结构，比如sds，都会占用比较大的内存，但如果仅保存为整数集合的话，则会更加经济。</p>
<h2 id="整数数组数据结构"><a href="#整数数组数据结构" class="headerlink" title="整数数组数据结构"></a>整数数组数据结构</h2><p>整数数组的定义位于intset.h中，具体如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">typedef struct intset &#123;</div><div class="line">    uint32_t encoding;  // 编码方式</div><div class="line">    uint32_t length;   // 保存的元素个数</div><div class="line">    int8_t contents[];  // 保存元素的数组</div><div class="line">&#125; intset;</div></pre></td></tr></table></figure>
<p>虽然 intset 结构将 contents 属性声明为 int8_t 类型的数组， 但实际上 contents 数组并不保存任何 int8_t 类型的值 —— contents 数组的真正类型取决于 encoding 属性的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">#define INTSET_ENC_INT16 (sizeof(int16_t))</div><div class="line">#define INTSET_ENC_INT32 (sizeof(int32_t))</div><div class="line">#define INTSET_ENC_INT64 (sizeof(int64_t))</div><div class="line"></div><div class="line">/* Return the required encoding for the provided value. */</div><div class="line">static uint8_t _intsetValueEncoding(int64_t v) &#123;</div><div class="line">    if (v &lt; INT32_MIN || v &gt; INT32_MAX)</div><div class="line">        return INTSET_ENC_INT64;</div><div class="line">    else if (v &lt; INT16_MIN || v &gt; INT16_MAX)</div><div class="line">        return INTSET_ENC_INT32;</div><div class="line">    else</div><div class="line">        return INTSET_ENC_INT16;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到一共会有三种类型，分别对应int_16, int_32, int_64。</p>
<p>整数数组中所有的元素在数组中按值的大小从小到大有序地排列， 并且数组中不包含任何重复项。</p>
<h2 id="整数集合操作"><a href="#整数集合操作" class="headerlink" title="整数集合操作"></a>整数集合操作</h2><h3 id="创建整数集合"><a href="#创建整数集合" class="headerlink" title="创建整数集合"></a>创建整数集合</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 初始化空的整数集合</div><div class="line">intset *intsetNew(void) &#123;</div><div class="line">    intset *is = zmalloc(sizeof(intset));</div><div class="line">    is-&gt;encoding = intrev32ifbe(INTSET_ENC_INT16); // 默认创建int_16的编码格式</div><div class="line">    is-&gt;length = 0;</div><div class="line">    return is;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="插入一个元素"><a href="#插入一个元素" class="headerlink" title="插入一个元素"></a>插入一个元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">/* Insert an integer in the intset */</div><div class="line">intset *intsetAdd(intset *is, int64_t value, uint8_t *success) &#123;</div><div class="line">    uint8_t valenc = _intsetValueEncoding(value);</div><div class="line">    uint32_t pos;</div><div class="line">    if (success) *success = 1;</div><div class="line"></div><div class="line">    // 如果超出了当前编码格式所能表示的范围，则升级整数集合并添加元素</div><div class="line">    if (valenc &gt; intrev32ifbe(is-&gt;encoding)) &#123;</div><div class="line">        /* This always succeeds, so we don&apos;t need to curry *success. */</div><div class="line">        return intsetUpgradeAndAdd(is,value);</div><div class="line">    &#125; else &#123;</div><div class="line">        // 如果元素已经存在于集合，success返回0</div><div class="line">        // 如果不存在的话， 这个函数会返回元素应该插入的位置pos</div><div class="line">        if (intsetSearch(is,value,&amp;pos)) &#123;</div><div class="line">            if (success) *success = 0;</div><div class="line">            return is;</div><div class="line">        &#125;</div><div class="line">        // 否则，需要重新调整集合的大小</div><div class="line">        is = intsetResize(is,intrev32ifbe(is-&gt;length)+1);</div><div class="line">        // 将pos之后的数据全都向后挪动一个位子</div><div class="line">        if (pos &lt; intrev32ifbe(is-&gt;length)) intsetMoveTail(is,pos,pos+1);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    _intsetSet(is,pos,value); // 添加数据到第pos位</div><div class="line">    is-&gt;length = intrev32ifbe(intrev32ifbe(is-&gt;length)+1); // 调整元素个数</div><div class="line">    return is;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在插入元素的时候，需要根据新元素的大小来重新确定所采用的编码。如果新元素超出了原有编码的表示范围，就需要调整编码，同时调整集合中所有其他元素的编码格式。调整编码是一个不可逆的过程，就是说只能从小的编码调整到大的编码，只能升级不能降级。</p>
<h3 id="升级过程"><a href="#升级过程" class="headerlink" title="升级过程"></a>升级过程</h3><p>升级整数集合并添加新元素调用的是intsetUpgradeAndAdd函数，共分为三步进行：</p>
<ul>
<li>根据新元素的类型， 扩展整数集合底层数组的空间大小， 并为新元素分配空间。</li>
<li>将底层数组现有的所有元素都转换成与新元素相同的类型， 并将类型转换后的元素放置到正确的位上， 而且在放置元素的过程中， 需要继续维持底层数组的有序性质不变。</li>
<li>将新元素添加到底层数组里面。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">/* Upgrades the intset to a larger encoding and inserts the given integer. */</div><div class="line">static intset *intsetUpgradeAndAdd(intset *is, int64_t value) &#123;</div><div class="line">    // 当前的编码</div><div class="line">    uint8_t curenc = intrev32ifbe(is-&gt;encoding);</div><div class="line">    // 根据新元素的值获得新的编码</div><div class="line">    uint8_t newenc = _intsetValueEncoding(value);</div><div class="line">    int length = intrev32ifbe(is-&gt;length);</div><div class="line">    // 由于整数集合是一个有序集合，所以新的这个超出范围的元素，要不插入头部，要不插入尾部</div><div class="line">    // 当value大于0的时候，就是插入到尾部，否则插入到头部，用参数prepend来标记</div><div class="line">    int prepend = value &lt; 0 ? 1 : 0;</div><div class="line"></div><div class="line">    /* First set new encoding and resize */</div><div class="line">    // 重新设置整数集合的编码</div><div class="line">    is-&gt;encoding = intrev32ifbe(newenc);</div><div class="line">    // 根据新编码调整整数集合的大小</div><div class="line">    is = intsetResize(is,intrev32ifbe(is-&gt;length)+1);</div><div class="line"></div><div class="line"></div><div class="line">    // 从尾部向头部进行升级，这样在挪动其中的元素的时候，不会覆盖原来的值</div><div class="line">    while(length--)</div><div class="line">        // 如果新元素是插入到尾部，prepend==0， 所以原来最后的元素是挪动到length位置</div><div class="line">        // 如果新元素是插入到头部，prepend==1，所有的元素都要向后挪动一个位置，将头部空出来</div><div class="line">        _intsetSet(is,length+prepend,_intsetGetEncoded(is,length,curenc));</div><div class="line"></div><div class="line">    /* Set the value at the beginning or the end. */</div><div class="line">    if (prepend)</div><div class="line">        // 如果prepend==1， 插入到头部</div><div class="line">        _intsetSet(is,0,value);</div><div class="line">    else</div><div class="line">        // 否则，设置最后一个位置的元素为value</div><div class="line">        _intsetSet(is,intrev32ifbe(is-&gt;length),value);</div><div class="line">    // 元素个数加1</div><div class="line">    is-&gt;length = intrev32ifbe(intrev32ifbe(is-&gt;length)+1);</div><div class="line">    return is;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而整数集合现在的做法既可以让集合能同时保存三种不同类型的值， 又可以确保升级操作只会在有需要的时候进行， 这可以尽量节省内存。</p>
<h3 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h3><p>查找的时候，需要先判断要查找的元素是否在当前编码的有效范围内，如果不在当前范围内，可以直接返回。</p>
<p>另外因为整数集合是一个有序集合，可以采用二分查找的办法，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">uint8_t intsetFind(intset *is, int64_t value) &#123;</div><div class="line">    // 获得目标值的编码</div><div class="line">    uint8_t valenc = _intsetValueEncoding(value);</div><div class="line">    // 只有目标值的编码比当前编码小，才继续执行查找过程</div><div class="line">    return valenc &lt;= intrev32ifbe(is-&gt;encoding) &amp;&amp; intsetSearch(is,value,NULL);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 如果找到这个元素，返回1，同时pos表示这个值在整数集合里边的位置</div><div class="line">// 如果没有找到这个元素，返回0， 同时pos表示这个值可以插入的位置</div><div class="line">static uint8_t intsetSearch(intset *is, int64_t value, uint32_t *pos) &#123;</div><div class="line">    int min = 0, max = intrev32ifbe(is-&gt;length)-1, mid = -1;</div><div class="line">    int64_t cur = -1;</div><div class="line"></div><div class="line">    /* The value can never be found when the set is empty */</div><div class="line">    // 如果集合的长度为0， 直接返回0</div><div class="line">    if (intrev32ifbe(is-&gt;length) == 0) &#123;</div><div class="line">        if (pos) *pos = 0;</div><div class="line">        return 0;</div><div class="line">    &#125; else &#123;</div><div class="line">        /* Check for the case where we know we cannot find the value,</div><div class="line">         * but do know the insert position. */</div><div class="line">        // 如果目标值大于当前最大值，肯定找不到，返回0， 同时待插入的位置pos为length</div><div class="line">        if (value &gt; _intsetGet(is,intrev32ifbe(is-&gt;length)-1)) &#123;</div><div class="line">            if (pos) *pos = intrev32ifbe(is-&gt;length);</div><div class="line">            return 0;</div><div class="line">        &#125; else if (value &lt; _intsetGet(is,0)) &#123;</div><div class="line">            // 如果目标址小于当前最小值，返回0， 同时待插入的位置pos为0</div><div class="line">            if (pos) *pos = 0;</div><div class="line">            return 0;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 二分查找</div><div class="line">    while(max &gt;= min) &#123;</div><div class="line">        // 得到中间位置</div><div class="line">        mid = ((unsigned int)min + (unsigned int)max) &gt;&gt; 1;</div><div class="line">        // 得到中间位置的值</div><div class="line">        cur = _intsetGet(is,mid);</div><div class="line">        if (value &gt; cur) &#123;</div><div class="line">            min = mid+1;</div><div class="line">        &#125; else if (value &lt; cur) &#123;</div><div class="line">            max = mid-1;</div><div class="line">        &#125; else &#123;</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (value == cur) &#123;</div><div class="line">        if (pos) *pos = mid;</div><div class="line">        return 1;</div><div class="line">    &#125; else &#123;</div><div class="line">        if (pos) *pos = min;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
        
        <tags>
            
            <tag> redis </tag>
            
            <tag> 源码 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis源码剖析--跳跃表]]></title>
      <url>/2017/08/24/Redis%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E8%B7%B3%E8%B7%83%E8%A1%A8/</url>
      <content type="html"><![CDATA[<p>跳跃表（skiplist）是一种有序数据结构， 它通过在每个节点中维持多个指向其他节点的指针， 从而达到快速访问节点的目的。</p>
<p>跳跃表支持平均 O(\log N) 最坏 O(N) 复杂度的节点查找， 还可以通过顺序性操作来批量处理节点。</p>
<p>在大部分情况下， 跳跃表的效率可以和平衡树相媲美， 并且因为跳跃表的实现比平衡树要来得更为简单， 所以有不少程序都使用跳跃表来代替平衡树。</p>
<p>Redis 使用跳跃表作为有序集合键的底层实现之一： 如果一个有序集合包含的元素数量比较多， 又或者有序集合中元素的成员（member）是比较长的字符串时， Redis 就会使用跳跃表来作为有序集合键的底层实现。</p>
<p>和链表、字典等数据结构被广泛地应用在 Redis 内部不同， Redis 只在两个地方用到了跳跃表， 一个是实现有序集合键， 另一个是在集群节点中用作内部数据结构， 除此之外， 跳跃表在 Redis 里面没有其他用途。</p>
<p>先看一下维基百科对跳跃表的图示：<br><img src="/2017/08/24/Redis源码剖析-跳跃表/Skip_list.svg" alt="logo"></p>
<p>从图中可以看到， 跳跃表主要由以下部分构成：</p>
<ul>
<li>表头（head）：负责维护跳跃表的节点指针。</li>
<li>跳跃表节点：保存着元素值，以及多个层。</li>
<li>层：保存着指向其他元素的指针。高层的指针越过的元素数量大于等于低层的指针，为了提高查找的效率，程序总是从高层先开始访问，然后随着元素值范围的缩小，慢慢降低层次。</li>
<li>表尾：全部由 NULL 组成，表示跳跃表的末尾。</li>
</ul>
<h2 id="跳跃表结构定义"><a href="#跳跃表结构定义" class="headerlink" title="跳跃表结构定义"></a>跳跃表结构定义</h2><p>跳跃表的结构体定义在server.h文件中。其中包括跳跃表节点zskiplistNode和跳跃表zskiplist两个结构体。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/* ZSETs use a specialized version of Skiplists */</div><div class="line">typedef struct zskiplistNode &#123;</div><div class="line">    sds ele;   // 具体成员对象</div><div class="line">    double score;   // 成员分值</div><div class="line">    struct zskiplistNode *backward;  // 向后索引指针</div><div class="line">    struct zskiplistLevel &#123;    // 跳跃表层</div><div class="line">        struct zskiplistNode *forward;  // 前向索引指针</div><div class="line">        unsigned int span;    // 这一层的跨度</div><div class="line">    &#125; level[];</div><div class="line">&#125; zskiplistNode;</div><div class="line"></div><div class="line">typedef struct zskiplist &#123;</div><div class="line">    struct zskiplistNode *header, *tail;   // 头尾结点</div><div class="line">    unsigned long length;    // 总的结点数</div><div class="line">    int level;    // 总的层数</div><div class="line">&#125; zskiplist;</div></pre></td></tr></table></figure>
<p>每次创建一个新跳跃表节点的时候， 程序都根据幂次定律 （power law，越大的数出现的概率越小） 随机生成一个介于 1 和 32 之间的值作为 level 数组的大小， 这个大小就是层的“高度”。</p>
<p>总的层数保存在zskiplist的level参数中， 另外每个节点保存了各自层中的指针以及这一层的跨度。</p>
<h2 id="跳跃表操作"><a href="#跳跃表操作" class="headerlink" title="跳跃表操作"></a>跳跃表操作</h2><h3 id="创建跳跃表"><a href="#创建跳跃表" class="headerlink" title="创建跳跃表"></a>创建跳跃表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">/* Create a skiplist node with the specified number of levels.</div><div class="line"> * The SDS string &apos;ele&apos; is referenced by the node after the call. */</div><div class="line"> // 创建跳跃表结点</div><div class="line">zskiplistNode *zslCreateNode(int level, double score, sds ele) &#123;</div><div class="line">    // 开辟内存，根据传入的层数设置大小</div><div class="line">    zskiplistNode *zn =</div><div class="line">        zmalloc(sizeof(*zn)+level*sizeof(struct zskiplistLevel));</div><div class="line">    // 赋值跳跃表结点分值</div><div class="line">    zn-&gt;score = score;</div><div class="line">    // 赋值跳跃表结点对象</div><div class="line">    zn-&gt;ele = ele;</div><div class="line">    return zn;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* 创建跳跃表 */</div><div class="line">zskiplist *zslCreate(void) &#123;</div><div class="line">    int j;</div><div class="line">    zskiplist *zsl;</div><div class="line">    // 申请内存</div><div class="line">    zsl = zmalloc(sizeof(*zsl));</div><div class="line">    // 设置层数为1</div><div class="line">    zsl-&gt;level = 1;</div><div class="line">    // 总的结点数为0</div><div class="line">    zsl-&gt;length = 0;</div><div class="line">    // ZSKIPLIST_MAXLEVEL=32, 头结点，设置最大层数，分值为0， 具体对象为NULL</div><div class="line">    zsl-&gt;header = zslCreateNode(ZSKIPLIST_MAXLEVEL,0,NULL);</div><div class="line">    // 循环设置头结点的每一层的前向指针为NULL，跨度为0</div><div class="line">    for (j = 0; j &lt; ZSKIPLIST_MAXLEVEL; j++) &#123;</div><div class="line">        zsl-&gt;header-&gt;level[j].forward = NULL;</div><div class="line">        zsl-&gt;header-&gt;level[j].span = 0;</div><div class="line">    &#125;</div><div class="line">    // 头结点的后向指针为NULL</div><div class="line">    zsl-&gt;header-&gt;backward = NULL;</div><div class="line">    zsl-&gt;tail = NULL;</div><div class="line">    return zsl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>创建跳跃表的时候设置层数为1， 只有一个头结点，头结点保存了最大的层数，同时所有的前向指针都为NULL。</p>
<h3 id="释放整个跳跃表"><a href="#释放整个跳跃表" class="headerlink" title="释放整个跳跃表"></a>释放整个跳跃表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">/* Free the specified skiplist node. The referenced SDS string representation</div><div class="line"> * of the element is freed too, unless node-&gt;ele is set to NULL before calling</div><div class="line"> * this function. */</div><div class="line">void zslFreeNode(zskiplistNode *node) &#123;</div><div class="line">    sdsfree(node-&gt;ele);</div><div class="line">    zfree(node);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* 释放整个跳跃表. */</div><div class="line">void zslFree(zskiplist *zsl) &#123;</div><div class="line">    // 从最底层的level[0]依次遍历，释放</div><div class="line">    zskiplistNode *node = zsl-&gt;header-&gt;level[0].forward, *next;</div><div class="line"></div><div class="line">    zfree(zsl-&gt;header);</div><div class="line">    // 如果存在后续结点</div><div class="line">    while(node) &#123;</div><div class="line">        next = node-&gt;level[0].forward;</div><div class="line">        // 释放结点</div><div class="line">        zslFreeNode(node);</div><div class="line">        node = next;</div><div class="line">    &#125;</div><div class="line">    zfree(zsl);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="跳跃表插入元素"><a href="#跳跃表插入元素" class="headerlink" title="跳跃表插入元素"></a>跳跃表插入元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line">/* Insert a new node in the skiplist. Assumes the element does not already</div><div class="line"> * exist (up to the caller to enforce that). The skiplist takes ownership</div><div class="line"> * of the passed SDS string &apos;ele&apos;. */</div><div class="line"> // 跳跃表插入元素</div><div class="line">zskiplistNode *zslInsert(zskiplist *zsl, double score, sds ele) &#123;</div><div class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</div><div class="line">    unsigned int rank[ZSKIPLIST_MAXLEVEL];</div><div class="line">    int i, level;</div><div class="line"></div><div class="line">    serverAssert(!isnan(score));   　// 判断是否为数字</div><div class="line">    x = zsl-&gt;header;</div><div class="line">    // 从最高的level， 也即跨度最大的level开始查找结点</div><div class="line">    for (i = zsl-&gt;level-1; i &gt;= 0; i--) &#123;</div><div class="line">        /* store rank that is crossed to reach the insert position */</div><div class="line">        // 当前是否是最高层， 如果是最高层，rank[i]=0，否则，复制上一层的数值</div><div class="line">        rank[i] = i == (zsl-&gt;level-1) ? 0 : rank[i+1];</div><div class="line">        // 如果当前结点的score值小于传入的score 或者 当前score相等，但是结点的对象不相等</div><div class="line">        while (x-&gt;level[i].forward &amp;&amp;</div><div class="line">                (x-&gt;level[i].forward-&gt;score &lt; score ||</div><div class="line">                    (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</div><div class="line">                    sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt; 0)))</div><div class="line">        &#123;</div><div class="line">            // 将当前一层的跨度加到rank[i]</div><div class="line">            rank[i] += x-&gt;level[i].span;</div><div class="line">            // 在当前层中向前查找</div><div class="line">            x = x-&gt;level[i].forward;</div><div class="line">        &#125;</div><div class="line">        // 当前层位于插入位置前的结点x放入update数组</div><div class="line">        update[i] = x;</div><div class="line">    &#125;</div><div class="line">    /* we assume the element is not already inside, since we allow duplicated</div><div class="line">     * scores, reinserting the same element should never happen since the</div><div class="line">     * caller of zslInsert() should test in the hash table if the element is</div><div class="line">     * already inside or not. */</div><div class="line">    // 随机生成小于32的层数</div><div class="line">    level = zslRandomLevel();</div><div class="line">    // 如果生成的层数大于当前的层数</div><div class="line">    if (level &gt; zsl-&gt;level) &#123;</div><div class="line">        for (i = zsl-&gt;level; i &lt; level; i++) &#123;</div><div class="line">            // 设定rank数组中大于原level层以上的值为0</div><div class="line">            // 同时设定update数组大于原level层以上的数据</div><div class="line">            rank[i] = 0;</div><div class="line">            update[i] = zsl-&gt;header;</div><div class="line">            update[i]-&gt;level[i].span = zsl-&gt;length;</div><div class="line">        &#125;</div><div class="line">        zsl-&gt;level = level;</div><div class="line">    &#125;</div><div class="line">    // 创建层数为level的新结点</div><div class="line">    x = zslCreateNode(level,score,ele);</div><div class="line">    for (i = 0; i &lt; level; i++) &#123;</div><div class="line">        // 将每一层的前置结点的后续结点指向新结点， 同时设置新结点的后续结点</div><div class="line">        x-&gt;level[i].forward = update[i]-&gt;level[i].forward;</div><div class="line">        update[i]-&gt;level[i].forward = x;</div><div class="line"></div><div class="line">        /* update span covered by update[i] as x is inserted here */</div><div class="line">        // 更新每一层的前置结点和新结点的跨度</div><div class="line">        x-&gt;level[i].span = update[i]-&gt;level[i].span - (rank[0] - rank[i]);</div><div class="line">        update[i]-&gt;level[i].span = (rank[0] - rank[i]) + 1;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* increment span for untouched levels */</div><div class="line">    for (i = level; i &lt; zsl-&gt;level; i++) &#123;</div><div class="line">        update[i]-&gt;level[i].span++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 根据最低层的前序结点是否是header结点来设置当前新结点的向后指针</div><div class="line">    x-&gt;backward = (update[0] == zsl-&gt;header) ? NULL : update[0];</div><div class="line">    if (x-&gt;level[0].forward)</div><div class="line">        x-&gt;level[0].forward-&gt;backward = x;</div><div class="line">    else</div><div class="line">        zsl-&gt;tail = x;</div><div class="line">    zsl-&gt;length++;</div><div class="line">    return x;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先看图示，如果想要插入score=5的结点（redis中允许score值重复），那么首选需要找到score=5的结点，查找的顺序为：</p>
<p><img src="/2017/08/24/Redis源码剖析-跳跃表/WX20170824-181328.png" alt="logo"></p>
<p>从最大的层向后查找，如果当前层后边没有值了，并且当前结点的值小于要找的值，就查找下一层结点；如果下一个结点的值大于要找的值，也会到下一层结点继续查找。</p>
<p>找到对应的位置执行插入操作后，需要为新结点设置层数，那么设置多少层合适呢，这边直接采用了一个随机数。随机数生成了多少层，当前新结点的层数就设置多少层。</p>
<p>如果新层数小于原来的层数，只需要重新设置前序后置结点的指针和跨度就行；如果新层数大于原来的层数，就需要额外设置新的更高的层。</p>
<p>那么插入结点之后，如何修改前序和后置结点的指针和跨度呢。这边用了两个数组来记录，分别是update和rank。update用来记录每一层中插入位置的前序结点，到时候根据这个前序结点设置每一层的指针调整。 rank用来记录每一层到新结点的跨度，插入新结点之后，根据rank数组中记录跨度更新前置结点的跨度值。</p>
<h3 id="删除跳跃表结点"><a href="#删除跳跃表结点" class="headerlink" title="删除跳跃表结点"></a>删除跳跃表结点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"> /* 删除结点，如果结点存在并删除，返回1， 否则返回0</div><div class="line">    参数中node如果是空的，则结点确实被删除； 如果非空，只是把结点从链表上摘下来，返回指针给node*/</div><div class="line">int zslDelete(zskiplist *zsl, double score, sds ele, zskiplistNode **node) &#123;</div><div class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</div><div class="line">    int i;</div><div class="line"></div><div class="line">    x = zsl-&gt;header;</div><div class="line">    // 查找对应结点</div><div class="line">    for (i = zsl-&gt;level-1; i &gt;= 0; i--) &#123;</div><div class="line">        while (x-&gt;level[i].forward &amp;&amp;</div><div class="line">                (x-&gt;level[i].forward-&gt;score &lt; score ||</div><div class="line">                    (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</div><div class="line">                     sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt; 0)))</div><div class="line">        &#123;</div><div class="line">            x = x-&gt;level[i].forward;</div><div class="line">        &#125;</div><div class="line">        update[i] = x;</div><div class="line">    &#125;</div><div class="line">    /* We may have multiple elements with the same score, what we need</div><div class="line">     * is to find the element with both the right score and object. */</div><div class="line">    // 由于允许存在相同的score，需要在score和ele都满足的条件下才能删除</div><div class="line">    x = x-&gt;level[0].forward;</div><div class="line">    if (x &amp;&amp; score == x-&gt;score &amp;&amp; sdscmp(x-&gt;ele,ele) == 0) &#123;</div><div class="line">        zslDeleteNode(zsl, x, update);</div><div class="line">        if (!node)</div><div class="line">            zslFreeNode(x);</div><div class="line">        else</div><div class="line">            *node = x;</div><div class="line">        return 1;</div><div class="line">    &#125;</div><div class="line">    return 0; /* not found */</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>具体的结点删除操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">/* Internal function used by zslDelete, zslDeleteByScore and zslDeleteByRank */</div><div class="line">// update数组保存了所有层上要删除结点的前置结点</div><div class="line">void zslDeleteNode(zskiplist *zsl, zskiplistNode *x, zskiplistNode **update) &#123;</div><div class="line">    int i;</div><div class="line">    for (i = 0; i &lt; zsl-&gt;level; i++) &#123;</div><div class="line">        if (update[i]-&gt;level[i].forward == x) &#123;</div><div class="line">            // 如果当前层有指针指向要删除的结点，前置结点的跨度需要加上当前结点的跨度，同时更新指针</div><div class="line">            update[i]-&gt;level[i].span += x-&gt;level[i].span - 1;</div><div class="line">            update[i]-&gt;level[i].forward = x-&gt;level[i].forward;</div><div class="line">        &#125; else &#123;</div><div class="line">            // 否则，只需要将前置结点的跨度减1即可，因为少了一个结点啊</div><div class="line">            update[i]-&gt;level[i].span -= 1;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    // 修改backward指针，需要考虑x是否为尾节点</div><div class="line">    if (x-&gt;level[0].forward) &#123;</div><div class="line">        x-&gt;level[0].forward-&gt;backward = x-&gt;backward;</div><div class="line">    &#125; else &#123;</div><div class="line">        zsl-&gt;tail = x-&gt;backward;</div><div class="line">    &#125;</div><div class="line">    while(zsl-&gt;level &gt; 1 &amp;&amp; zsl-&gt;header-&gt;level[zsl-&gt;level-1].forward == NULL)</div><div class="line">        zsl-&gt;level--;</div><div class="line">    zsl-&gt;length--;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> redis </tag>
            
            <tag> 源码 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis源码剖析-dict遍历算法]]></title>
      <url>/2017/08/02/Redis%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-dict%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>先贴一下整体的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line">unsigned long dictScan(dict *d,</div><div class="line">                       unsigned long v,</div><div class="line">                       dictScanFunction *fn,</div><div class="line">                       dictScanBucketFunction* bucketfn,</div><div class="line">                       void *privdata)</div><div class="line">&#123;</div><div class="line">    dictht *t0, *t1;</div><div class="line">    const dictEntry *de, *next;</div><div class="line">    unsigned long m0, m1;</div><div class="line"></div><div class="line">    // 跳过空字典</div><div class="line">    if (dictSize(d) == 0) return 0;</div><div class="line"></div><div class="line">    // 如果没有rehash，迭代一个哈希表的字典</div><div class="line">    if (!dictIsRehashing(d)) &#123;</div><div class="line">        t0 = &amp;(d-&gt;ht[0]);</div><div class="line">        m0 = t0-&gt;sizemask;</div><div class="line"></div><div class="line">        /* Emit entries at cursor */</div><div class="line">        if (bucketfn) bucketfn(privdata, &amp;t0-&gt;table[v &amp; m0]);</div><div class="line">        de = t0-&gt;table[v &amp; m0];</div><div class="line">        while (de) &#123;</div><div class="line">            next = de-&gt;next;</div><div class="line">            fn(privdata, de);</div><div class="line">            de = next;</div><div class="line">        &#125;</div><div class="line">    // 迭代有两个哈希表的字典</div><div class="line">    &#125; else &#123;</div><div class="line">        t0 = &amp;d-&gt;ht[0];</div><div class="line">        t1 = &amp;d-&gt;ht[1];</div><div class="line"></div><div class="line">        /* Make sure t0 is the smaller and t1 is the bigger table */</div><div class="line">        // 确保 t0 比 t1 要小</div><div class="line">        if (t0-&gt;size &gt; t1-&gt;size) &#123;</div><div class="line">            t0 = &amp;d-&gt;ht[1];</div><div class="line">            t1 = &amp;d-&gt;ht[0];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        m0 = t0-&gt;sizemask;</div><div class="line">        m1 = t1-&gt;sizemask;</div><div class="line"></div><div class="line">        /* Emit entries at cursor */</div><div class="line">        if (bucketfn) bucketfn(privdata, &amp;t0-&gt;table[v &amp; m0]);</div><div class="line">        de = t0-&gt;table[v &amp; m0];</div><div class="line">        while (de) &#123;</div><div class="line">            next = de-&gt;next;</div><div class="line">            fn(privdata, de);</div><div class="line">            de = next;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        /* Iterate over indices in larger table that are the expansion</div><div class="line">         * of the index pointed to by the cursor in the smaller table */</div><div class="line">        do &#123;</div><div class="line">            /* Emit entries at cursor */</div><div class="line">            if (bucketfn) bucketfn(privdata, &amp;t1-&gt;table[v &amp; m1]);</div><div class="line">            de = t1-&gt;table[v &amp; m1];</div><div class="line">            while (de) &#123;</div><div class="line">                next = de-&gt;next;</div><div class="line">                fn(privdata, de);</div><div class="line">                de = next;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            /* Increment bits not covered by the smaller mask */</div><div class="line">            v = (((v | m0) + 1) &amp; ~m0) | (v &amp; m0);</div><div class="line"></div><div class="line">            /* Continue while bits covered by mask difference is non-zero */</div><div class="line">        &#125; while (v &amp; (m0 ^ m1));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* Set unmasked bits so incrementing the reversed cursor</div><div class="line">     * operates on the masked bits of the smaller table */</div><div class="line">    v |= ~m0;</div><div class="line"></div><div class="line">    /* Increment the reverse cursor */</div><div class="line">    v = rev(v);</div><div class="line">    v++;</div><div class="line">    v = rev(v);</div><div class="line"></div><div class="line">    return v;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Redis的dict结构中，有一个遍历dict的函数，因为该遍历函数的算法比较特别，值得单独拿出来研究一下。</p>
<p>首先考虑最简单的情况， 如果一个dict是稳定，即没有扩大缩小，也没有正好处于rehash的过程中，那么这种情况下的遍历是最简单的， 只需要按照索引值顺序遍历第一个hash表ht[0]就行。 </p>
<p>但是如果本次索引的遍历的时候，跟上一个索引遍历的时候，dict已经经过了扩大或者缩小，或者dict正好处于rehash的过程中的时候，遍历过程就变复杂了。</p>
<p>如果仍旧采用顺序遍历索引的策略，考虑dict经过缩小的情况。如果hash表一共有8个slot，经过扩大变成了4个slot，在计算索引的时候，都是hash值同mask=size-1做与操作。所以如果某个key的hash值最后原来是7的话，在slot=8的时候，应该放到索引为7的slot，但是缩小到4个slot的时候，将被放在slot=3。可以想见，这种情况下，会有大量的key被漏掉。同样，如果经过了扩大，也会有大量的key被重复遍历。</p>
<h2 id="dict的反向二进制位遍历"><a href="#dict的反向二进制位遍历" class="headerlink" title="dict的反向二进制位遍历"></a>dict的反向二进制位遍历</h2><p>Redis的遍历方式采用了反向的二进制位遍历。那么什么是反向二进制位遍历呢。按照正常的遍历逻辑，遍历的顺序是按照0-&gt;1-&gt;2-&gt;3-&gt;4….</p>
<p>但是dictScan采用的顺序，以8个slot为例，是0-&gt;4-&gt;2-&gt;6-&gt;1-&gt;5-&gt;3-&gt;7。看着貌似没有规律，但是其实是从高位开始，向低位进位的一种遍历方式，用二进制更能直观的看出来</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">000 --&gt; 100 --&gt; 010 --&gt; 110 --&gt; 001 --&gt; 101 --&gt; 011 --&gt; 111 --&gt; 000</div></pre></td></tr></table></figure>
<p> 那么用这种方式遍历会有什么好处呢，可以按照dict不同状态的示例来说明</p>
<h3 id="1、当dict稳定的时候"><a href="#1、当dict稳定的时候" class="headerlink" title="1、当dict稳定的时候"></a>1、当dict稳定的时候</h3><p>这种情况下，从上面的说明能看出，反向二进制遍历同正向二进制遍历一样，能够遍历到所有的索引，并且不会有重复或遗漏</p>
<h3 id="2、当dict扩大的时候"><a href="#2、当dict扩大的时候" class="headerlink" title="2、当dict扩大的时候"></a>2、当dict扩大的时候</h3><p>假设dict的slot由8个扩大到16个，首先列出两种状态下的遍历顺序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">000 --&gt; 100 --&gt; 010 --&gt; 110 --&gt; 001 --&gt; 101 --&gt; 011 --&gt; 111 --&gt; 000     </div><div class="line">  </div><div class="line">0000 --&gt; 1000 --&gt; 0100 --&gt; 1100 --&gt; 0010 --&gt; 1010 --&gt; 0110 --&gt; 1110 --&gt; 0001 --&gt; 1001 --&gt; 0101 --&gt; 1101 --&gt; 0011 --&gt; 1011 --&gt; 0111 --&gt; 1111 --&gt; 0000</div></pre></td></tr></table></figure>
<p>假设在slot=8的时候已经遍历完了010的索引，下一次就需要遍历110的索引。此时dict发生了rehash操作，slot从8个扩展到了16个，</p>
<p>在slot=16的情况下，就需要遍历0110的索引。 此时，在slot=8的时候遍历过的所以值为000，100，010，对应到slot=16的情况下，分别是0000，1000， 0100，1100， 0010， 1010， 正好是所以址0110的前序所以， 这样的话，整个遍历流程，不会造成遍历的重复或者遗漏。</p>
<h3 id="3、当dict缩小的时候"><a href="#3、当dict缩小的时候" class="headerlink" title="3、当dict缩小的时候"></a>3、当dict缩小的时候</h3><p>假设在slot=16的是，已经遍历完了0110的索引，下一个就要遍历1110的索引，此时dict缩小到了slot=8 。此前已经遍历过的所有索引分别为 0000， 1000， 0100， 1100， 0010， 1010， 0110， 对应到slot=8的情况下，分别落到索引000，100，010，110。 </p>
<p>此时需要从110的所以开始遍历，但是由于此前在slot=16的时候已经遍历过的0110的索引值也是落到110的索引，所以会造成一部分的key被重复遍历。</p>
<p>原哈希表长度为x，缩小后长度为y，则最多会有x/y – 1个原bucket的节点会被重复迭代。比如由16缩小为8，则最多就有1个bucket节点会重复迭代，要是由32缩小为8，则最多会有3个。</p>
<p>但是，也有可能，正好不重复遍历，比如slot=16的时候遍历到1010，即将遍历0110的时候dict缩小的时候，就不会产生重复。</p>
<p>反向二进制算法保证了dict不会遗漏元素，同时在dict缩小的时候，保证了比较小的元素重复。</p>
<h3 id="4、正好进行rehash的时候"><a href="#4、正好进行rehash的时候" class="headerlink" title="4、正好进行rehash的时候"></a>4、正好进行rehash的时候</h3><p>当dict正好在进行rehash的时候，当前遍历的索引里边可能数据不全，因为有一部分已经rehash到新表中去了。所以为了不漏掉元素，采取的措施是同时遍历两个hash表的对应索引。</p>
<p>但是rehash的过程中，不管扩大还是缩小，两张表的索引都是不同的，如何对应呢。 方法就是先比较两张hash表的大小，先遍历较小的hash表，遍历完之后，找到大表中所有对应的索引值，全部依次遍历。</p>
<p>举个例子，暂且不管dict当前是在扩大还是缩小，两张hash表的大小肯定是不同的。假设一张表的slot=8，另一张表的slot=32， 两个mask分别为111和11111。 假设当前的hash值同111做与操作之后为010，那么小表中010的索引遍历之后，需要遍历大表的00010，01010， 10010和11010的索引，然后将两者的索引一块返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">v = (((v | m0) + 1) &amp; ~m0) | (v &amp; m0);</div></pre></td></tr></table></figure>
<p>那么如何保证大表对应的所有索引都能遍历到呢。代码中可以看到这么一条语句，分析一下。 v | m0 将v的低位全部置为1， (v | m0) + 1则是将v的高位加1，之后再 &amp; ~m0 将所有低位置0， v &amp; m0 就是将v的低位提取出来放到之前的数值之后。 这样就能够： 保持v的低位不变，高位持续加1，遍历所有扩展后的slot</p>
<p>那么高位什么时候停止加1呢，就是while终止的条件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">while (v &amp; (m0 ^ m1))</div></pre></td></tr></table></figure>
<p>由于m0和m1都是全为1的mask，假设m0=111， m1=11111， 那么m0 ^ m1 = 11000， 所以我们能看到当v的高位没有1了，其实就是说到头了，循环就会终止。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Redis的dictScan通过反向二进制位的遍历顺序，既能防止漏掉遍历元素，也能在必须要重复遍历元素的时候，减少重复元素的个数。 同时在处理rehash操作时的遍历的时候，通过各种位操作的结合，使得rehash过程中不会漏掉元素。</p>
]]></content>
      
        
        <tags>
            
            <tag> redis </tag>
            
            <tag> 源码 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis源码剖析-dict字典]]></title>
      <url>/2017/07/31/Redis%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-dict%E5%AD%97%E5%85%B8/</url>
      <content type="html"><![CDATA[<p>改换一下策略，不直接介绍源码，打算先整体介绍一下思路，然后再根据源码解释具体的实现。</p>
<p><img src="/2017/07/31/Redis源码剖析-dict字典/dict.png" alt="logo"></p>
<p>如图所示，一个dict字典中由两个hashtable组成，分别为ht[0]和ht[1]，用到的基本上都是ht[0]。 那么ht[1]什么时候用到呢？因为hash算出来的索引值是有可能重复的，也就是说不同的dictEntry有可能位于同一个hashtable的槽内，如果拥有的dictEntry的数量和slot的数量的比值超过了5，相当于平均每个slot拥有5个以上的dictEntry的时候，就需要重新rehash整个dict。</p>
<p>扩展或者收缩dict的时候，并不是一次性完成的， 因为如果dict中拥有大量数据的时候，一次性的操作有可能会影响正式的服务。</p>
<p>所以redis采取的策略是分布式的rehash。 利用rehashidx来记录当前进行到了哪个索引，下一次的rehash从这个索引开始。那什么时候进行rehash呢，有两种策略， 一种是在指定时间内执行固定步数；另一种是在每次对当前dict进行查询、修改的时候，每一次操作都附带完成一个索引值的rehash。这样就把整体的rehash时间平摊到了各个小操作中。</p>
<p>在rehash的过程中，如果执行查询操作，两个ht都需要查询；修改和删除也需要操作两个ht，插入的时候，只需要插入到ht[1]，这样就保证了ht[0]里边的键值对只少不多。</p>
<h2 id="Dict定义"><a href="#Dict定义" class="headerlink" title="Dict定义"></a>Dict定义</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">typedef struct dict &#123;</div><div class="line">    dictType *type;  // 类型特定函数</div><div class="line">    void *privdata;  // 私有数据</div><div class="line">    dictht ht[2];    // 2个哈希表</div><div class="line">    // rehash 索引</div><div class="line">    // 当 rehash 不在进行时，值为 -1</div><div class="line">    long rehashidx; /* rehashing not in progress if rehashidx == -1 */</div><div class="line">    // 目前正在运行的安全迭代器的数量</div><div class="line">    unsigned long iterators; /* number of iterators currently running */</div><div class="line">&#125; dict;</div></pre></td></tr></table></figure>
<p>dictType保存一些用于操作特定类型键值对的函数，定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">typedef struct dictType &#123;</div><div class="line">    // 计算哈希值的函数</div><div class="line">    uint64_t (*hashFunction)(const void *key);</div><div class="line">    // 复制键的函数</div><div class="line">    void *(*keyDup)(void *privdata, const void *key);</div><div class="line">    // 复制值的函数</div><div class="line">    void *(*valDup)(void *privdata, const void *obj);</div><div class="line">    // 比较键的函数</div><div class="line">    int (*keyCompare)(void *privdata, const void *key1, const void *key2);</div><div class="line">    // 销毁键的函数</div><div class="line">    void (*keyDestructor)(void *privdata, void *key);</div><div class="line">    // 销毁值的函数</div><div class="line">    void (*valDestructor)(void *privdata, void *obj);</div><div class="line">&#125; dictType;</div></pre></td></tr></table></figure>
<p>dicht哈希表，所有的键值对保存在里边，定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">typedef struct dictht &#123;</div><div class="line">    dictEntry **table;  // 哈希数组</div><div class="line">    unsigned long size;  // 总的哈希表大小</div><div class="line">    // 哈希表大小掩码，用于计算索引值</div><div class="line">    // 总是等于 size - 1</div><div class="line">    unsigned long sizemask;  </div><div class="line">    unsigned long used;  // 该哈希表已有节点的数量</div><div class="line">&#125; dictht;</div></pre></td></tr></table></figure>
<p>dictEntry则保存了每一个具体的键值对，定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">typedef struct dictEntry &#123;</div><div class="line">    // 键</div><div class="line">    void *key;</div><div class="line">    union &#123;</div><div class="line">        void *val;</div><div class="line">        uint64_t u64;</div><div class="line">        int64_t s64;</div><div class="line">        double d;</div><div class="line">    &#125; v; // 值</div><div class="line">    // 指向下一个结点，因为hash值有可能冲突，冲突的时候链表形式保存在同一个索引后边</div><div class="line">    struct dictEntry *next;</div><div class="line">&#125; dictEntry;</div></pre></td></tr></table></figure>
<h2 id="Dict操作"><a href="#Dict操作" class="headerlink" title="Dict操作"></a>Dict操作</h2><h3 id="判断是否需要进行rehash"><a href="#判断是否需要进行rehash" class="headerlink" title="判断是否需要进行rehash"></a>判断是否需要进行rehash</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">/* Resize the table to the minimal size that contains all the elements,</div><div class="line"> * but with the invariant of a USED/BUCKETS ratio near to &lt;= 1 */</div><div class="line">int dictResize(dict *d)</div><div class="line">&#123;</div><div class="line">    int minimal;</div><div class="line">    // 不能在关闭 rehash 或者正在 rehash 的时候调用</div><div class="line">    if (!dict_can_resize || dictIsRehashing(d)) return DICT_ERR;</div><div class="line">    // 查看已经使用了多少结点，最少分配DICT_HT_INITIAL_SIZE=4个结点</div><div class="line">    // 否则，计算让比率接近 1：1 所需要的最少节点数量</div><div class="line">    minimal = d-&gt;ht[0].used;</div><div class="line">    if (minimal &lt; DICT_HT_INITIAL_SIZE)</div><div class="line">        minimal = DICT_HT_INITIAL_SIZE;</div><div class="line">    return dictExpand(d, minimal);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Expand or create the hash table */</div><div class="line">/*</div><div class="line"> * 创建一个新的哈希表，并根据字典的情况，选择以下其中一个动作来进行：</div><div class="line"> *</div><div class="line"> * 1) 如果字典的 0 号哈希表为空，那么将新哈希表设置为 0 号哈希表</div><div class="line"> * 2) 如果字典的 0 号哈希表非空，那么将新哈希表设置为 1 号哈希表，</div><div class="line"> *    并打开字典的 rehash 标识，使得程序可以开始对字典进行 rehash</div><div class="line"> *</div><div class="line"> * size 参数不够大，或者 rehash 已经在进行时，返回 DICT_ERR 。</div><div class="line"> *</div><div class="line"> * 成功创建 0 号哈希表，或者 1 号哈希表时，返回 DICT_OK 。</div><div class="line"> */</div><div class="line">int dictExpand(dict *d, unsigned long size)</div><div class="line">&#123;</div><div class="line">    dictht n; /* the new hash table */</div><div class="line">    // 计算大于size的第一个2的N次方的值，用来当作新的哈希表的大小</div><div class="line">    unsigned long realsize = _dictNextPower(size);</div><div class="line"></div><div class="line">    /* the size is invalid if it is smaller than the number of</div><div class="line">     * elements already inside the hash table */</div><div class="line">    if (dictIsRehashing(d) || d-&gt;ht[0].used &gt; size)</div><div class="line">        return DICT_ERR;</div><div class="line"></div><div class="line">    /* Rehashing to the same table size is not useful. */</div><div class="line">    // 如果新表大小跟老表一样， 没有进行expand的需要</div><div class="line">    if (realsize == d-&gt;ht[0].size) return DICT_ERR;</div><div class="line"></div><div class="line">    /* Allocate the new hash table and initialize all pointers to NULL */</div><div class="line">    n.size = realsize;</div><div class="line">    n.sizemask = realsize-1;</div><div class="line">    n.table = zcalloc(realsize*sizeof(dictEntry*));</div><div class="line">    n.used = 0;</div><div class="line"></div><div class="line">    /* Is this the first initialization? If so it&apos;s not really a rehashing</div><div class="line">     * we just set the first hash table so that it can accept keys. */</div><div class="line">     // 如果 0 号哈希表为空，那么这是一次初始化：</div><div class="line">     // 程序将新哈希表赋给 0 号哈希表的指针，然后字典就可以开始处理键值对了。</div><div class="line">    if (d-&gt;ht[0].table == NULL) &#123;</div><div class="line">        d-&gt;ht[0] = n;</div><div class="line">        return DICT_OK;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* Prepare a second hash table for incremental rehashing */</div><div class="line">    // 如果 0 号哈希表非空，那么这是一次 rehash ：</div><div class="line">    // 程序将新哈希表设置为 1 号哈希表，</div><div class="line">    // 并将字典的 rehash 标识打开，让程序可以开始对字典进行 rehash</div><div class="line">    d-&gt;ht[1] = n;</div><div class="line">    d-&gt;rehashidx = 0;</div><div class="line">    return DICT_OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="rehash算法"><a href="#rehash算法" class="headerlink" title="rehash算法"></a>rehash算法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line">/* Performs N steps of incremental rehashing. Returns 1 if there are still</div><div class="line"> * keys to move from the old to the new hash table, otherwise 0 is returned.</div><div class="line"> * 执行 N 步渐进式 rehash 。</div><div class="line"> *</div><div class="line"> * 返回 1 表示仍有键需要从 0 号哈希表移动到 1 号哈希表，</div><div class="line"> * 返回 0 则表示所有键都已经迁移完毕。</div><div class="line"> * Note that a rehashing step consists in moving a bucket (that may have more</div><div class="line"> * than one key as we use chaining) from the old to the new hash table, however</div><div class="line"> * since part of the hash table may be composed of empty spaces, it is not</div><div class="line"> * guaranteed that this function will rehash even a single bucket, since it</div><div class="line"> * will visit at max N*10 empty buckets in total, otherwise the amount of</div><div class="line"> * work it does would be unbound and the function may block for a long time.</div><div class="line"> * 每步 rehash 都是以一个哈希表索引（桶）作为单位的，</div><div class="line"> * 一个桶里可能会有多个节点，</div><div class="line"> * 被 rehash 的桶里的所有节点都会被移动到新哈希表。*/</div><div class="line">int dictRehash(dict *d, int n) &#123;</div><div class="line">    // 由于hash表中的桶有可能为空，设置最大访问空桶的数量为n*10，否则如果空桶很多的话会等待比较长的一段时间</div><div class="line">    int empty_visits = n*10; /* Max number of empty buckets to visit. */</div><div class="line">    // 只可以在 rehash 进行中时执行</div><div class="line">    if (!dictIsRehashing(d)) return 0;</div><div class="line"></div><div class="line">    while(n-- &amp;&amp; d-&gt;ht[0].used != 0) &#123;</div><div class="line">        dictEntry *de, *nextde;</div><div class="line"></div><div class="line">        /* Note that rehashidx can&apos;t overflow as we are sure there are more</div><div class="line">         * elements because ht[0].used != 0 */</div><div class="line">        // 确保 rehashidx 没有越界</div><div class="line">        assert(d-&gt;ht[0].size &gt; (unsigned long)d-&gt;rehashidx);</div><div class="line">        // 略过数组中为空的索引，找到下一个非空索引</div><div class="line">        // 如果访问的空索引达到了n*10， 停止遍历</div><div class="line">        while(d-&gt;ht[0].table[d-&gt;rehashidx] == NULL) &#123;</div><div class="line">            d-&gt;rehashidx++;</div><div class="line">            if (--empty_visits == 0) return 1;</div><div class="line">        &#125;</div><div class="line">        // 指向该索引的链表表头节点</div><div class="line">        de = d-&gt;ht[0].table[d-&gt;rehashidx];</div><div class="line">        /* Move all the keys in this bucket from the old to the new hash HT */</div><div class="line">        // 将链表中的所有节点迁移到新哈希表</div><div class="line">        while(de) &#123;</div><div class="line">            unsigned int h;</div><div class="line"></div><div class="line">            nextde = de-&gt;next;</div><div class="line">            /* Get the index in the new hash table */</div><div class="line">            // 根据新表的sizemask计算哈希值</div><div class="line">            h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[1].sizemask;</div><div class="line">            // 插入节点到新哈希表</div><div class="line">            de-&gt;next = d-&gt;ht[1].table[h];</div><div class="line">            d-&gt;ht[1].table[h] = de;</div><div class="line">            // 更新计数器</div><div class="line">            d-&gt;ht[0].used--;</div><div class="line">            d-&gt;ht[1].used++;</div><div class="line">            de = nextde;</div><div class="line">        &#125;</div><div class="line">        // 将刚迁移完的哈希表索引的指针设为空</div><div class="line">        d-&gt;ht[0].table[d-&gt;rehashidx] = NULL;</div><div class="line">        // 更新 rehash 索引</div><div class="line">        d-&gt;rehashidx++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* Check if we already rehashed the whole table... */</div><div class="line">    // 如果 0 号哈希表为空，那么表示 rehash 执行完毕</div><div class="line">    if (d-&gt;ht[0].used == 0) &#123;</div><div class="line">        // 释放 0 号哈希表</div><div class="line">        zfree(d-&gt;ht[0].table);</div><div class="line">        // 将原来的 1 号哈希表设置为新的 0 号哈希表</div><div class="line">        d-&gt;ht[0] = d-&gt;ht[1];</div><div class="line">        // 重置旧的 1 号哈希表</div><div class="line">        _dictReset(&amp;d-&gt;ht[1]);</div><div class="line">        // 关闭 rehash 标识</div><div class="line">        d-&gt;rehashidx = -1;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* More to rehash... */</div><div class="line">    return 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在两种情况下会调用rehash的操作，一种是在指定时间内执行操作，每次操作进行100步：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">/* Rehash for an amount of time between ms milliseconds and ms+1 milliseconds */</div><div class="line">int dictRehashMilliseconds(dict *d, int ms) &#123;</div><div class="line">    // 记录开始时间</div><div class="line">    long long start = timeInMilliseconds();</div><div class="line">    int rehashes = 0;</div><div class="line"></div><div class="line">    while(dictRehash(d,100)) &#123;</div><div class="line">        // 在给定毫秒数内，以 100 步为单位，对字典进行 rehash</div><div class="line">        rehashes += 100;</div><div class="line">        // 如果时间已过，跳出</div><div class="line">        if (timeInMilliseconds()-start &gt; ms) break;</div><div class="line">    &#125;</div><div class="line">    return rehashes;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另一种是在执行普通的查询或者更新操作的时候，同时执行一次rehash</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/* This function is called by common lookup or update operations in the</div><div class="line"> * dictionary so that the hash table automatically migrates from H1 to H2</div><div class="line"> * while it is actively used. */</div><div class="line">static void _dictRehashStep(dict *d) &#123;</div><div class="line">    if (d-&gt;iterators == 0) dictRehash(d,1);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Dict插入键"><a href="#Dict插入键" class="headerlink" title="Dict插入键"></a>Dict插入键</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">/* Add an element to the target hash table */</div><div class="line">int dictAdd(dict *d, void *key, void *val)</div><div class="line">&#123;</div><div class="line">    // 往字典中添加一个key</div><div class="line">    dictEntry *entry = dictAddRaw(d,key,NULL);</div><div class="line"></div><div class="line">    if (!entry) return DICT_ERR;</div><div class="line">    // 如果成功返回， 为key是指value</div><div class="line">    dictSetVal(d, entry, val);</div><div class="line">    return DICT_OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line">dictEntry *dictAddRaw(dict *d, void *key, dictEntry **existing)</div><div class="line">&#123;</div><div class="line">    int index;</div><div class="line">    dictEntry *entry;</div><div class="line">    dictht *ht;</div><div class="line"></div><div class="line">    // 如果在进行rehash操作， 执行一步rehash</div><div class="line">    if (dictIsRehashing(d)) _dictRehashStep(d);</div><div class="line"></div><div class="line">    /* Get the index of the new element, or -1 if</div><div class="line">     * the element already exists. */</div><div class="line">     // 获取key的索引，如果索引已经存在，返回NULL</div><div class="line">    if ((index = _dictKeyIndex(d, key, dictHashKey(d,key), existing)) == -1)</div><div class="line">        return NULL;</div><div class="line"></div><div class="line">    /* Allocate the memory and store the new entry.</div><div class="line">     * Insert the element in top, with the assumption that in a database</div><div class="line">     * system it is more likely that recently added entries are accessed</div><div class="line">     * more frequently. */</div><div class="line">     // 是否在进行rehash操作，如果在rehash， 放到新表ht[1]， 否则放到ht[0]</div><div class="line">    ht = dictIsRehashing(d) ? &amp;d-&gt;ht[1] : &amp;d-&gt;ht[0];</div><div class="line">    entry = zmalloc(sizeof(*entry));</div><div class="line">    // 插入新结点</div><div class="line">    entry-&gt;next = ht-&gt;table[index];</div><div class="line">    ht-&gt;table[index] = entry;</div><div class="line">    ht-&gt;used++;</div><div class="line"></div><div class="line">    /* Set the hash entry fields. */</div><div class="line">    dictSetKey(d, entry, key);</div><div class="line">    return entry;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="添加或更新元素"><a href="#添加或更新元素" class="headerlink" title="添加或更新元素"></a>添加或更新元素</h3><ul>
<li>如果之前元素不存在，添加成功后返回1</li>
<li>如果之前元素存在，更新元素，同时返回0</li>
<li>如果存在的话，设置新的值，然后释放老的值，这样做能够充分利用引用计数，如果是同一个元素的话，更改计数就行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">int dictReplace(dict *d, void *key, void *val)</div><div class="line">&#123;</div><div class="line">    dictEntry *entry, *existing, auxentry;</div><div class="line"></div><div class="line">    /* Try to add the element. If the key</div><div class="line">     * does not exists dictAdd will suceed. */</div><div class="line">    // 添加键值对，如果之前不存在的话，添加成功返回1</div><div class="line">    entry = dictAddRaw(d,key,&amp;existing);</div><div class="line">    if (entry) &#123;</div><div class="line">        dictSetVal(d, entry, val);</div><div class="line">        return 1;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* Set the new value and free the old one. Note that it is important</div><div class="line">     * to do that in this order, as the value may just be exactly the same</div><div class="line">     * as the previous one. In this context, think to reference counting,</div><div class="line">     * you want to increment (set), and then decrement (free), and not the</div><div class="line">     * reverse. */</div><div class="line">    // 如果存在的话，设置新的值，然后释放老的值，这样做能够充分利用引用计数，如果是同一个元素的话，更改计数就行</div><div class="line">    auxentry = *existing;</div><div class="line">    dictSetVal(d, existing, val);</div><div class="line">    dictFreeVal(d, &amp;auxentry);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="删除键值对"><a href="#删除键值对" class="headerlink" title="删除键值对"></a>删除键值对</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">static dictEntry *dictGenericDelete(dict *d, const void *key, int nofree) &#123;</div><div class="line">    unsigned int h, idx;</div><div class="line">    dictEntry *he, *prevHe;</div><div class="line">    int table;</div><div class="line"></div><div class="line">    // 如果两个哈希表都没有元素， 返回NULL</div><div class="line">    if (d-&gt;ht[0].used == 0 &amp;&amp; d-&gt;ht[1].used == 0) return NULL;</div><div class="line"></div><div class="line">    // 如果正在进行rehash，先执行一步rehash</div><div class="line">    if (dictIsRehashing(d)) _dictRehashStep(d);</div><div class="line">    h = dictHashKey(d, key);</div><div class="line"></div><div class="line">    // 两个表都要查看</div><div class="line">    for (table = 0; table &lt;= 1; table++) &#123;</div><div class="line">        idx = h &amp; d-&gt;ht[table].sizemask;</div><div class="line">        he = d-&gt;ht[table].table[idx];</div><div class="line">        prevHe = NULL;</div><div class="line">        while(he) &#123;</div><div class="line">            if (key==he-&gt;key || dictCompareKeys(d, key, he-&gt;key)) &#123;</div><div class="line">                /* Unlink the element from the list */</div><div class="line">                if (prevHe)</div><div class="line">                    prevHe-&gt;next = he-&gt;next;</div><div class="line">                else</div><div class="line">                    d-&gt;ht[table].table[idx] = he-&gt;next;</div><div class="line">                if (!nofree) &#123;</div><div class="line">                    dictFreeKey(d, he);</div><div class="line">                    dictFreeVal(d, he);</div><div class="line">                    zfree(he);</div><div class="line">                &#125;</div><div class="line">                d-&gt;ht[table].used--;</div><div class="line">                return he;</div><div class="line">            &#125;</div><div class="line">            prevHe = he;</div><div class="line">            he = he-&gt;next;</div><div class="line">        &#125;</div><div class="line">        // 如果没有在进行rehash，说明ht[1]没有值，就不用查看了</div><div class="line">        if (!dictIsRehashing(d)) break;</div><div class="line">    &#125;</div><div class="line">    return NULL; /* not found */</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>参数中的nofree用来标记是否真的删除，如果这个值为1的话，只是把这个键值对从table中拿下来，但并不是真的删除；如果想要移除一个键值对，但是在真的删除之前还想使用它的值，这个操作是有用的。</p>
<p>如果没有这个操作，需要先执行find操作找到结点，使用之后再执行删除，就需要进行两次查找；而这个操作只需要进行一次查找，用完之后再调用dictFreeUnlinkedEntry释放这个键值对就行。</p>
<h3 id="查看key的值"><a href="#查看key的值" class="headerlink" title="查看key的值"></a>查看key的值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">dictEntry *dictFind(dict *d, const void *key)</div><div class="line">&#123;</div><div class="line">    dictEntry *he;</div><div class="line">    unsigned int h, idx, table;</div><div class="line"></div><div class="line">    // 如果没有键值对，返回NULL</div><div class="line">    if (d-&gt;ht[0].used + d-&gt;ht[1].used == 0) return NULL; /* dict is empty */</div><div class="line">    // 如果正在进行rehash，先进行一次rehash</div><div class="line">    if (dictIsRehashing(d)) _dictRehashStep(d);</div><div class="line">    // 计算hash值</div><div class="line">    h = dictHashKey(d, key);</div><div class="line">    for (table = 0; table &lt;= 1; table++) &#123;</div><div class="line">        // 计算索引值</div><div class="line">        idx = h &amp; d-&gt;ht[table].sizemask;</div><div class="line">        he = d-&gt;ht[table].table[idx];</div><div class="line">        while(he) &#123;</div><div class="line">            if (key==he-&gt;key || dictCompareKeys(d, key, he-&gt;key))</div><div class="line">                return he;</div><div class="line">            he = he-&gt;next;</div><div class="line">        &#125;</div><div class="line">        // 如果没有在进行rehash，没有查看ht[1]的必要</div><div class="line">        if (!dictIsRehashing(d)) return NULL;</div><div class="line">    &#125;</div><div class="line">    return NULL;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void *dictFetchValue(dict *d, const void *key) &#123;</div><div class="line">    dictEntry *he;</div><div class="line"></div><div class="line">    he = dictFind(d,key);</div><div class="line">    return he ? dictGetVal(he) : NULL;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此外还有一个遍历dict的操作，如果dict保持不变，直接按照索引顺序遍历就行，但是由于dict存在扩大和缩小的可能性，如果和做到在扩大或缩小的同时，遍历dict能够不漏掉所有键值对呢，这个算法比较复杂， 单独开一篇研究。</p>
]]></content>
      
        
        <tags>
            
            <tag> redis </tag>
            
            <tag> 源码 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis源码剖析-链表list]]></title>
      <url>/2017/07/31/Redis%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E9%93%BE%E8%A1%A8list/</url>
      <content type="html"><![CDATA[<p>Redis另一个基础的数据结构是链表，C并没有内置的链表结构，因此Redis自己实现了一个列表。</p>
<p>除了链表键之外， 发布与订阅、慢查询、监视器等功能也用到了链表， Redis 服务器本身还使用链表来保存多个客户端的状态信息， 以及使用链表来构建客户端输出缓冲区。</p>
<h2 id="List结构"><a href="#List结构" class="headerlink" title="List结构"></a>List结构</h2><p>双端链表结点定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">typedef struct listNode &#123;</div><div class="line">    struct listNode *prev; // 指向前一个结点</div><div class="line">    struct listNode *next;  // 指向后一个结点</div><div class="line">    void *value;   // 结点值</div><div class="line">&#125; listNode;</div></pre></td></tr></table></figure>
<p>链表迭代器定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">typedef struct listIter &#123;  // 链表迭代器</div><div class="line">    listNode *next;   // 指向下一个结点</div><div class="line">    int direction;    // 标记迭代方向</div><div class="line">&#125; listIter;</div></pre></td></tr></table></figure>
<p>关于迭代器的方向标记，定义的全局变量用来标记：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/* Directions for iterators */</div><div class="line">#define AL_START_HEAD 0</div><div class="line">#define AL_START_TAIL 1</div></pre></td></tr></table></figure>
<p>双端列表定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 双端列表定义</div><div class="line">typedef struct list &#123;</div><div class="line">    listNode *head;  // 链表头</div><div class="line">    listNode *tail;  // 链表尾</div><div class="line">    void *(*dup)(void *ptr);  // 列表复制函数</div><div class="line">    void (*free)(void *ptr);  // 列表释放函数</div><div class="line">    int (*match)(void *ptr, void *key);  // 列表匹配函数</div><div class="line">    unsigned long len;  // 列表长度</div><div class="line">&#125; list;</div></pre></td></tr></table></figure>
<h2 id="链表操作"><a href="#链表操作" class="headerlink" title="链表操作"></a>链表操作</h2><h3 id="链表初始化"><a href="#链表初始化" class="headerlink" title="链表初始化"></a>链表初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">/* Create a new list. The created list can be freed with</div><div class="line"> * AlFreeList(), but private value of every node need to be freed</div><div class="line"> * by the user before to call AlFreeList().</div><div class="line"> *</div><div class="line"> * On error, NULL is returned. Otherwise the pointer to the new list. */</div><div class="line">list *listCreate(void)</div><div class="line">&#123;</div><div class="line">    struct list *list;  // 定义链表指针</div><div class="line">    // 分配内存，如果分配失败，返回NULL</div><div class="line">    if ((list = zmalloc(sizeof(*list))) == NULL)</div><div class="line">        return NULL;</div><div class="line">    // 链表头尾初始化</div><div class="line">    list-&gt;head = list-&gt;tail = NULL;</div><div class="line">    // 长度赋初值</div><div class="line">    list-&gt;len = 0;</div><div class="line">    // 复制函数、释放函数、匹配函数初始化为NULL</div><div class="line">    list-&gt;dup = NULL;</div><div class="line">    list-&gt;free = NULL;</div><div class="line">    list-&gt;match = NULL;</div><div class="line">    return list;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="链表清空"><a href="#链表清空" class="headerlink" title="链表清空"></a>链表清空</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">/* Remove all the elements from the list without destroying the list itself. */</div><div class="line">void listEmpty(list *list)</div><div class="line">&#123;</div><div class="line">    unsigned long len;</div><div class="line">    listNode *current, *next;</div><div class="line"></div><div class="line">    current = list-&gt;head;</div><div class="line">    len = list-&gt;len;</div><div class="line">    // 根据链表长度循环</div><div class="line">    while(len--) &#123;</div><div class="line">        next = current-&gt;next;</div><div class="line">        // 如果定义了链表释放函数，用释放函数释放结点</div><div class="line">        if (list-&gt;free) list-&gt;free(current-&gt;value);</div><div class="line">        zfree(current);</div><div class="line">        current = next;</div><div class="line">    &#125;</div><div class="line">    // 清空链表头尾结点及长度</div><div class="line">    list-&gt;head = list-&gt;tail = NULL;</div><div class="line">    list-&gt;len = 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="链表头部插入结点"><a href="#链表头部插入结点" class="headerlink" title="链表头部插入结点"></a>链表头部插入结点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">list *listAddNodeHead(list *list, void *value)</div><div class="line">&#123;</div><div class="line">    listNode *node;  // 新建链表结点</div><div class="line"></div><div class="line">    if ((node = zmalloc(sizeof(*node))) == NULL)  // 初始化结点，如果失败返回NULL</div><div class="line">        return NULL;</div><div class="line">    // 将value赋值给结点</div><div class="line">    node-&gt;value = value;</div><div class="line">    if (list-&gt;len == 0) &#123;</div><div class="line">        // 如果是第一个结点，头尾都指向该结点，该结点前后结点都为空</div><div class="line">        list-&gt;head = list-&gt;tail = node;</div><div class="line">        node-&gt;prev = node-&gt;next = NULL;</div><div class="line">    &#125; else &#123;</div><div class="line">        // 否则，将结点插入到链表头部</div><div class="line">        node-&gt;prev = NULL;</div><div class="line">        node-&gt;next = list-&gt;head;</div><div class="line">        list-&gt;head-&gt;prev = node;</div><div class="line">        list-&gt;head = node;</div><div class="line">    &#125;</div><div class="line">    // 链表长度加1</div><div class="line">    list-&gt;len++;</div><div class="line">    return list;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="往任意位置插入结点"><a href="#往任意位置插入结点" class="headerlink" title="往任意位置插入结点"></a>往任意位置插入结点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">list *listInsertNode(list *list, listNode *old_node, void *value, int after) &#123;</div><div class="line">    listNode *node;  // 新建结点</div><div class="line"></div><div class="line">    if ((node = zmalloc(sizeof(*node))) == NULL) //分配空间，失败返回NULL</div><div class="line">        return NULL;</div><div class="line">    node-&gt;value = value;</div><div class="line">    if (after) &#123;</div><div class="line">        // 如果有after标记，将新结点放在old_node后边；如果old_node是尾部，调整tail指向</div><div class="line">        node-&gt;prev = old_node;</div><div class="line">        node-&gt;next = old_node-&gt;next;</div><div class="line">        if (list-&gt;tail == old_node) &#123;</div><div class="line">            list-&gt;tail = node;</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        // 否则，将新结点放在old_node前边， 如果old_node是头部，调整head指向</div><div class="line">        node-&gt;next = old_node;</div><div class="line">        node-&gt;prev = old_node-&gt;prev;</div><div class="line">        if (list-&gt;head == old_node) &#123;</div><div class="line">            list-&gt;head = node;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    if (node-&gt;prev != NULL) &#123;</div><div class="line">        node-&gt;prev-&gt;next = node;</div><div class="line">    &#125;</div><div class="line">    if (node-&gt;next != NULL) &#123;</div><div class="line">        node-&gt;next-&gt;prev = node;</div><div class="line">    &#125;</div><div class="line">    list-&gt;len++;</div><div class="line">    return list;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同时还提供了往链表尾部插入结点的函数，也是类似的操作。</p>
<h3 id="结点释放函数"><a href="#结点释放函数" class="headerlink" title="结点释放函数"></a>结点释放函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">void listDelNode(list *list, listNode *node)</div><div class="line">&#123;</div><div class="line">    if (node-&gt;prev)</div><div class="line">        // 如果结点有前置结点，即非head结点，调整前置结点的next指向</div><div class="line">        node-&gt;prev-&gt;next = node-&gt;next;</div><div class="line">    else</div><div class="line">        // 否则，是head结点，调整head结点指向</div><div class="line">        list-&gt;head = node-&gt;next;</div><div class="line">    if (node-&gt;next)</div><div class="line">        // 如果结点有后置结点，即非tail结点，调整后置结点的prev指向</div><div class="line">        node-&gt;next-&gt;prev = node-&gt;prev;</div><div class="line">    else</div><div class="line">        // 否则，是tail结点，调整tail结点指向</div><div class="line">        list-&gt;tail = node-&gt;prev;</div><div class="line">    // 如果定义了free函数，调用本身的free函数释放</div><div class="line">    if (list-&gt;free) list-&gt;free(node-&gt;value);</div><div class="line">    zfree(node);</div><div class="line">    list-&gt;len--;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="获得链表的迭代器"><a href="#获得链表的迭代器" class="headerlink" title="获得链表的迭代器"></a>获得链表的迭代器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">listIter *listGetIterator(list *list, int direction)</div><div class="line">&#123;</div><div class="line">    listIter *iter; // 定义迭代器指针</div><div class="line"></div><div class="line">    if ((iter = zmalloc(sizeof(*iter))) == NULL) return NULL;  // 分配空间，失败返回NULL</div><div class="line">    if (direction == AL_START_HEAD)</div><div class="line">        // 如果从头开始，迭代器的next指向head</div><div class="line">        iter-&gt;next = list-&gt;head;</div><div class="line">    else</div><div class="line">        // 否则，从尾部开始，迭代器的next指向tail</div><div class="line">        iter-&gt;next = list-&gt;tail;</div><div class="line">    iter-&gt;direction = direction;</div><div class="line">    return iter;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="获得迭代器的下一个结点"><a href="#获得迭代器的下一个结点" class="headerlink" title="获得迭代器的下一个结点"></a>获得迭代器的下一个结点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">listNode *listNext(listIter *iter)</div><div class="line">&#123;</div><div class="line">    listNode *current = iter-&gt;next; // 根据迭代器的next指针得到下一个结点</div><div class="line"></div><div class="line">    if (current != NULL) &#123;</div><div class="line">        // 根据迭代器的方向，获得next的指向</div><div class="line">        if (iter-&gt;direction == AL_START_HEAD)</div><div class="line">            iter-&gt;next = current-&gt;next;</div><div class="line">        else</div><div class="line">            iter-&gt;next = current-&gt;prev;</div><div class="line">    &#125;</div><div class="line">    return current;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="复制链表"><a href="#复制链表" class="headerlink" title="复制链表"></a>复制链表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">list *listDup(list *orig)</div><div class="line">&#123;</div><div class="line">    list *copy;  // 定义复制的链表</div><div class="line">    listIter iter;</div><div class="line">    listNode *node;</div><div class="line"></div><div class="line">    if ((copy = listCreate()) == NULL)</div><div class="line">        return NULL;</div><div class="line">    // 复制相关的内置函数</div><div class="line">    copy-&gt;dup = orig-&gt;dup;</div><div class="line">    copy-&gt;free = orig-&gt;free;</div><div class="line">    copy-&gt;match = orig-&gt;match;</div><div class="line">    // 得到头结点的迭代器</div><div class="line">    listRewind(orig, &amp;iter);</div><div class="line">    while((node = listNext(&amp;iter)) != NULL) &#123;</div><div class="line">        void *value;</div><div class="line">        // 如果有定义自己的复制函数，调用其进行复制</div><div class="line">        if (copy-&gt;dup) &#123;</div><div class="line">            value = copy-&gt;dup(node-&gt;value);</div><div class="line">            if (value == NULL) &#123;</div><div class="line">                listRelease(copy);</div><div class="line">                return NULL;</div><div class="line">            &#125;</div><div class="line">        &#125; else</div><div class="line">            // 否则，直接复制结点值</div><div class="line">            value = node-&gt;value;</div><div class="line">        // 将结点加入到目标的尾部</div><div class="line">        if (listAddNodeTail(copy, value) == NULL) &#123;</div><div class="line">            listRelease(copy);</div><div class="line">            return NULL;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return copy;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="链表旋转"><a href="#链表旋转" class="headerlink" title="链表旋转"></a>链表旋转</h3><p>其实就是将尾结点拿下来，放到头部</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">/* Rotate the list removing the tail node and inserting it to the head. */</div><div class="line">void listRotate(list *list) &#123;</div><div class="line">    listNode *tail = list-&gt;tail;  // 得到尾结点</div><div class="line"></div><div class="line">    if (listLength(list) &lt;= 1) return; // 如果只有一个结点，无需进行后续的操作</div><div class="line"></div><div class="line">    /* Detach current tail */</div><div class="line">    list-&gt;tail = tail-&gt;prev;  // 链表的tail指向原来tail结点的前置结点，同时置next为空</div><div class="line">    list-&gt;tail-&gt;next = NULL;</div><div class="line">    /* Move it as head */</div><div class="line">    list-&gt;head-&gt;prev = tail;  // 将尾部挪下来的结点放到头部，将原来的head结点后移一个位置</div><div class="line">    tail-&gt;prev = NULL;</div><div class="line">    tail-&gt;next = list-&gt;head;</div><div class="line">    list-&gt;head = tail;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> redis </tag>
            
            <tag> 源码 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis源码剖析--简单动态字符串sds]]></title>
      <url>/2017/07/28/Redis%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2sds/</url>
      <content type="html"><![CDATA[<p>Redis 没有直接使用 C 语言传统的字符串表示， 而是自己构建了一种名为简单动态字符串（simple dynamic string，SDS）的抽象类型， 并将 SDS 用作 Redis 的默认字符串表示。</p>
<p>Redis中所有的键都是用sds格式来保存的， 包括一部分值的保存，也是用的sds格式。</p>
<h2 id="SDS的定义"><a href="#SDS的定义" class="headerlink" title="SDS的定义"></a>SDS的定义</h2><p>sds.h中的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * 类型别名，用于指向 sdshdr 的 buf 属性</div><div class="line"> */</div><div class="line">typedef char *sds;</div></pre></td></tr></table></figure>
<p>sds包含两部分，在最基本的字符数组之外，加了两个字符数组信息，还有一个类似header的信息，header中包括了一下几个部分：</p>
<ul>
<li>len：表示字符串真正的长度，不包含空终止字符</li>
<li>alloc：表示字符串的最大容量，不包含Header和最后的空终止字符</li>
<li>flags：表示header的类型</li>
</ul>
<p>这样做的好处是能够马上知道字符串的长度和剩余空间，而无需遍历一遍字符数组计算长度。</p>
<p>同时，由于在c语言中一般都是通过字符数组最后的”\0”来判断字符串的结束，而sds可以无视这些特殊字符的存在，可以直接根据len来获取完整的字符串。</p>
<p>此外，在修改字符串的时候，sds能够减少空间与分配的次数，提高运行效率，具体的可以稍后看代码中的实现。</p>
<h2 id="SDS基本操作"><a href="#SDS基本操作" class="headerlink" title="SDS基本操作"></a>SDS基本操作</h2><h3 id="SDS初始化"><a href="#SDS初始化" class="headerlink" title="SDS初始化"></a>SDS初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">sds sdsnewlen(const void *init, size_t initlen) &#123;</div><div class="line">    void *sh;</div><div class="line">    sds s;</div><div class="line">    //根据长度判断创建header的类型</div><div class="line">    char type = sdsReqType(initlen);</div><div class="line">    /* Empty strings are usually created in order to append. Use type 8</div><div class="line">     * since type 5 is not good at this. */</div><div class="line">    if (type == SDS_TYPE_5 &amp;&amp; initlen == 0) type = SDS_TYPE_8;</div><div class="line">    //获取header的长度</div><div class="line">    int hdrlen = sdsHdrSize(type);</div><div class="line">    unsigned char *fp; /* flags pointer. */</div><div class="line"></div><div class="line">    //分配空间，header长度+字符串长度+结束字符</div><div class="line">    sh = s_malloc(hdrlen+initlen+1);</div><div class="line">    if (!init)</div><div class="line">        memset(sh, 0, hdrlen+initlen+1);</div><div class="line">    if (sh == NULL) return NULL;</div><div class="line">    //s是字符串真正保存的地址</div><div class="line">    s = (char*)sh+hdrlen;</div><div class="line">    //fp表示header中的flag</div><div class="line">    fp = ((unsigned char*)s)-1;</div><div class="line">    switch(type) &#123;</div><div class="line">        case SDS_TYPE_5: &#123;</div><div class="line">            *fp = type | (initlen &lt;&lt; SDS_TYPE_BITS);</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">        case SDS_TYPE_8: &#123;</div><div class="line">            SDS_HDR_VAR(8,s);</div><div class="line">            sh-&gt;len = initlen;</div><div class="line">            sh-&gt;alloc = initlen;</div><div class="line">            *fp = type;</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">        case SDS_TYPE_16: &#123;</div><div class="line">            SDS_HDR_VAR(16,s);</div><div class="line">            sh-&gt;len = initlen;</div><div class="line">            sh-&gt;alloc = initlen;</div><div class="line">            *fp = type;</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">        case SDS_TYPE_32: &#123;</div><div class="line">            SDS_HDR_VAR(32,s);</div><div class="line">            sh-&gt;len = initlen;</div><div class="line">            sh-&gt;alloc = initlen;</div><div class="line">            *fp = type;</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">        case SDS_TYPE_64: &#123;</div><div class="line">            SDS_HDR_VAR(64,s);</div><div class="line">            sh-&gt;len = initlen;</div><div class="line">            sh-&gt;alloc = initlen;</div><div class="line">            *fp = type;</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    if (initlen &amp;&amp; init)</div><div class="line">        //如果有初始内容，复制</div><div class="line">        memcpy(s, init, initlen);</div><div class="line">    s[initlen] = &apos;\0&apos;;</div><div class="line">    return s;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>根据初始化长度的不同，生成的header也不同</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">/* Note: sdshdr5 is never used, we just access the flags byte directly.</div><div class="line"> * However is here to document the layout of type 5 SDS strings. */</div><div class="line">struct __attribute__ ((__packed__)) sdshdr5 &#123;</div><div class="line">    unsigned char flags; /* 3 lsb of type, and 5 msb of string length */</div><div class="line">    char buf[];</div><div class="line">&#125;;</div><div class="line">struct __attribute__ ((__packed__)) sdshdr8 &#123;</div><div class="line">    uint8_t len; /* used */</div><div class="line">    uint8_t alloc; /* excluding the header and null terminator */</div><div class="line">    unsigned char flags; /* 3 lsb of type, 5 unused bits */</div><div class="line">    char buf[];</div><div class="line">&#125;;</div><div class="line">struct __attribute__ ((__packed__)) sdshdr16 &#123;</div><div class="line">    uint16_t len; /* used */</div><div class="line">    uint16_t alloc; /* excluding the header and null terminator */</div><div class="line">    unsigned char flags; /* 3 lsb of type, 5 unused bits */</div><div class="line">    char buf[];</div><div class="line">&#125;;</div><div class="line">struct __attribute__ ((__packed__)) sdshdr32 &#123;</div><div class="line">    uint32_t len; /* used */</div><div class="line">    uint32_t alloc; /* excluding the header and null terminator */</div><div class="line">    unsigned char flags; /* 3 lsb of type, 5 unused bits */</div><div class="line">    char buf[];</div><div class="line">&#125;;</div><div class="line">struct __attribute__ ((__packed__)) sdshdr64 &#123;</div><div class="line">    uint64_t len; /* used */</div><div class="line">    uint64_t alloc; /* excluding the header and null terminator */</div><div class="line">    unsigned char flags; /* 3 lsb of type, 5 unused bits */</div><div class="line">    char buf[];</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>len表示已使用的长度， alloc表示分配的长度，包括header的长度和终止符，flag用来标记header的类型。</p>
<h3 id="SDS复制函数"><a href="#SDS复制函数" class="headerlink" title="SDS复制函数"></a>SDS复制函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/* Duplicate an sds string. */</div><div class="line">//输入sds， 返回复制成功后的地址</div><div class="line">sds sdsdup(const sds s) &#123;</div><div class="line">    return sdsnewlen(s, sdslen(s));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="SDS释放函数"><a href="#SDS释放函数" class="headerlink" title="SDS释放函数"></a>SDS释放函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/* Free an sds string. No operation is performed if &apos;s&apos; is NULL. */</div><div class="line">void sdsfree(sds s) &#123;</div><div class="line">    if (s == NULL) return;</div><div class="line">    s_free((char*)s-sdsHdrSize(s[-1]));</div><div class="line">    //s[-1] 得到header中的flag， 然后通过sdsHdrSize获得header的大小， 相减得到header的地址</div><div class="line">    //s_free释放</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="SDS扩容函数"><a href="#SDS扩容函数" class="headerlink" title="SDS扩容函数"></a>SDS扩容函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">/* Enlarge the free space at the end of the sds string so that the caller</div><div class="line"> * is sure that after calling this function can overwrite up to addlen</div><div class="line"> * bytes after the end of the string, plus one more byte for nul term.</div><div class="line"> *</div><div class="line"> * Note: this does not change the *length* of the sds string as returned</div><div class="line"> * by sdslen(), but only the free buffer space we have. */</div><div class="line">sds sdsMakeRoomFor(sds s, size_t addlen) &#123;</div><div class="line">    void *sh, *newsh;</div><div class="line">    // 获取 s 目前的空余空间长度</div><div class="line">    size_t avail = sdsavail(s);</div><div class="line">    size_t len, newlen;</div><div class="line">    char type, oldtype = s[-1] &amp; SDS_TYPE_MASK;</div><div class="line">    int hdrlen;</div><div class="line"></div><div class="line">    // s 目前的空余空间已经足够，无须再进行扩展，直接返回</div><div class="line">    /* Return ASAP if there is enough space left. */</div><div class="line">    if (avail &gt;= addlen) return s;</div><div class="line"></div><div class="line">    len = sdslen(s);</div><div class="line">    sh = (char*)s-sdsHdrSize(oldtype);</div><div class="line">    // s 最少需要的长度</div><div class="line">    newlen = (len+addlen);</div><div class="line">    if (newlen &lt; SDS_MAX_PREALLOC)</div><div class="line">        // 如果新长度小于 SDS_MAX_PREALLOC </div><div class="line">        // 那么为它分配两倍于所需长度的空间</div><div class="line">        newlen *= 2;</div><div class="line">    else</div><div class="line">        // 否则，分配长度为目前长度加上 SDS_MAX_PREALLOC</div><div class="line">        newlen += SDS_MAX_PREALLOC;</div><div class="line"></div><div class="line">    // 得到新的type类型</div><div class="line">    type = sdsReqType(newlen);</div><div class="line"></div><div class="line">    /* Don&apos;t use type 5: the user is appending to the string and type 5 is</div><div class="line">     * not able to remember empty space, so sdsMakeRoomFor() must be called</div><div class="line">     * at every appending operation. */</div><div class="line">    if (type == SDS_TYPE_5) type = SDS_TYPE_8;</div><div class="line"></div><div class="line">    hdrlen = sdsHdrSize(type);</div><div class="line">    if (oldtype==type) &#123;</div><div class="line">        // 如果前后类型不变, 无需更改header，realloc</div><div class="line">        newsh = s_realloc(sh, hdrlen+newlen+1);</div><div class="line">        if (newsh == NULL) return NULL;</div><div class="line">        s = (char*)newsh+hdrlen;</div><div class="line">    &#125; else &#123;</div><div class="line">        /* Since the header size changes, need to move the string forward,</div><div class="line">         * and can&apos;t use realloc */</div><div class="line">        newsh = s_malloc(hdrlen+newlen+1);</div><div class="line">        if (newsh == NULL) return NULL;</div><div class="line">        memcpy((char*)newsh+hdrlen, s, len+1);</div><div class="line">        s_free(sh);</div><div class="line">        s = (char*)newsh+hdrlen;</div><div class="line">        s[-1] = type;</div><div class="line">        sdssetlen(s, len);</div><div class="line">    &#125;</div><div class="line">    // 重新设置header中的alloc参数</div><div class="line">    sdssetalloc(s, newlen);</div><div class="line">    return s;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>当要增加字符在SDS之后的时候，先判断目前的剩余长度是否满足条件，如果慢煮条件，直接将字符串添加在后边</li>
<li>如果当前的剩余空间不够，需要对SDS进行扩容。如果对 SDS 进行修改之后， SDS 的长度（也即是 len 属性的值）将小于 1 MB ， 那么程序分配和 len 属性同样大小的未使用空间， 这时 SDS len 属性的值将和 free 属性的值相同。 举个例子， 如果进行修改之后， SDS 的 len 将变成 13 字节， 那么程序也会分配 13 字节的未使用空间， SDS 的 buf 数组的实际长度将变成 13 + 13 + 1 = 27 字节（额外的一字节用于保存空字符）。</li>
<li>如果对 SDS 进行修改之后， SDS 的长度将大于等于 1 MB ， 那么程序会分配 1 MB 的未使用空间。 比如， 如果进行修改之后， SDS 的 len 将变成 30 MB ， 那么程序会分配 1 MB 的未使用空间， SDS 的 buf 数组的实际长度将为 30 MB + 1 MB + 1 byte 。</li>
</ul>
<h2 id="SDS小结"><a href="#SDS小结" class="headerlink" title="SDS小结"></a>SDS小结</h2><p>SDS提供了一系列函数，不一一列出。 参考《redis设计与实现》一书的说明，SDS与C字符串的区别如下</p>
<table>
<thead>
<tr>
<th>C 字符串</th>
<th>SDS</th>
</tr>
</thead>
<tbody>
<tr>
<td>获取字符串长度的复杂度为 O(N) 。</td>
<td>获取字符串长度的复杂度为 O(1) 。</td>
</tr>
<tr>
<td>API 是不安全的，可能会造成缓冲区溢出。</td>
<td>API 是安全的，不会造成缓冲区溢出。</td>
</tr>
<tr>
<td>修改字符串长度 N 次必然需要执行 N 次内存重分配。</td>
<td>修改字符串长度 N 次最多需要执行 N 次内存重分配。</td>
</tr>
<tr>
<td>只能保存文本数据。</td>
<td>可以保存文本或者二进制数据。</td>
</tr>
<tr>
<td>可以使用所有 <string.h> 库中的函数。</string.h></td>
<td>可以使用一部分 <string.h> 库中的函数。</string.h></td>
</tr>
</tbody>
</table>
]]></content>
      
        
        <tags>
            
            <tag> redis </tag>
            
            <tag> 源码 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Tornado 线程池应用]]></title>
      <url>/2017/07/25/Tornado-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%BA%94%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>Tornado是一个异步框架，在异步操作的时候能提升程序的处理性能。但是如果在程序中碰到同步的逻辑，由于GIL的关系，会直接卡死，导致性能急剧下降。</p>
<p>目前对于mongodb以及redis都有比较不错的异步框架，但是对于Mysql，目前的异步框架都不是很成熟。</p>
<p>在实际应用中，由于一开始不是特别了解，在用了Tornado框架的同时，采用了Sqlalchemy来处理Mysql数据。但是由于这部分Mysql操作是同步的，在并发量上去的时候，不能及时返回，大量请求被拒绝。</p>
<p>由于替换Sqlalchemy会造成很大的工作量，经过研究之后发现Tornado有run_on_executor，可以利用线程池达到异步化的目的。</p>
<blockquote>
<p>Decorator to run a synchronous method asynchronously on an executor.</p>
<p>The decorated method may be called with a callback keyword argument and returns a future.</p>
<p>The IOLoop and executor to be used are determined by the io_loop and executor attributes of self. To use different attributes, pass keyword arguments to the decorator</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">#!/bin/env python</div><div class="line">import tornado.httpserver</div><div class="line">import tornado.ioloop</div><div class="line">import tornado.options</div><div class="line">import tornado.web</div><div class="line">import tornado.httpclient</div><div class="line">import tornado.gen</div><div class="line">from tornado.concurrent import run_on_executor</div><div class="line"># 这个并发库在python3自带;在python2需要安装sudo pip install futures</div><div class="line">from concurrent.futures import ThreadPoolExecutor</div><div class="line">import time</div><div class="line">from tornado.options import define, options</div><div class="line">define(&quot;port&quot;, default=8002, help=&quot;run on the given port&quot;, type=int)</div><div class="line"></div><div class="line">class SleepHandler(tornado.web.RequestHandler):</div><div class="line">    executor = ThreadPoolExecutor(2)</div><div class="line"></div><div class="line">    def get(self):</div><div class="line">        tornado.ioloop.IOLoop.instance().add_callback(self.sleep)       # 这样将在下一轮事件循环执行self.sleep</div><div class="line">        self.write(&quot;when i sleep&quot;)</div><div class="line"></div><div class="line">    @run_on_executor</div><div class="line">    def sleep(self):</div><div class="line">        time.sleep(5)</div><div class="line">        print(&quot;yes&quot;)</div><div class="line">        return 5</div><div class="line"></div><div class="line"></div><div class="line">if __name__ == &quot;__main__&quot;:</div><div class="line">    tornado.options.parse_command_line()</div><div class="line">    app = tornado.web.Application(handlers=[</div><div class="line">            (r&quot;/sleep&quot;, SleepHandler), ])</div><div class="line">    http_server = tornado.httpserver.HTTPServer(app)</div><div class="line">    http_server.listen(options.port)</div><div class="line">    tornado.ioloop.IOLoop.instance().start()</div></pre></td></tr></table></figure>
<p>当然也可以用celery来达到异步的效果，但是不如run_on_executor来的方便</p>
]]></content>
      
        
        <tags>
            
            <tag> Tornado </tag>
            
            <tag> Python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Json Web Token]]></title>
      <url>/2017/07/25/Json-Web-Token/</url>
      <content type="html"><![CDATA[<h2 id="Token-Auth机制"><a href="#Token-Auth机制" class="headerlink" title="Token Auth机制"></a>Token Auth机制</h2><p>JSON Web Token（JWT）是一个非常轻巧的规范。这个规范允许我们使用JWT在用户和服务器之间传递安全可靠的信息。</p>
<p>JWT通过用户发送用户名和密码给服务器，服务器验证通过之后，生成签名的token给客户端。客户端存储这个token，之后请求帐号相关的信息时带上token，服务端验证token之后，进行相应的处理。</p>
<h3 id="相比cookie的优势"><a href="#相比cookie的优势" class="headerlink" title="相比cookie的优势"></a>相比cookie的优势</h3><p><strong>支持跨域站点访问</strong></p>
<p>Cookie是不允许垮域访问的，可以通过设置顶级域名的方式实现部分跨域，但是跨站点的访问仍然不支持。</p>
<p>Token没有站点的限制，跨域站点的时候仍旧能够使用。</p>
<p><strong>安全性更高</strong></p>
<p>不需要考虑对CSRF（跨站请求伪造）的防范；</p>
<h3 id="相比session的优势"><a href="#相比session的优势" class="headerlink" title="相比session的优势"></a>相比session的优势</h3><p><strong>节省服务器空间</strong></p>
<p>session验证方式需要在服务端保存每个session，会占用服务器空间。如果单纯用DB存储，还有性能上的劣势；用redis等存储则不太经济。</p>
<p>Token方式将成本分摊到各个客户端，所需要的仅仅是一个解编码的过程。</p>
<h2 id="JWT的组成"><a href="#JWT的组成" class="headerlink" title="JWT的组成"></a>JWT的组成</h2><p>JWT由三部分组成，分别是头部、载荷和签名。三个部分中间用点分隔开，并且都使用 Base64 编码。</p>
<p>总体JWT示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">eyJ0eXAiOiAiSldUIiwiYWxnIjogIkhTMjU2In0.eyJpc3MiOiAiaGFybGV5IiwiaWF0IjogMTUwMDk1NTk1MCwiZXhwIjogMTUwMDk1Nzk4NywidXNlcl9pZCI6ICI3ODk4IiwidXNlcl9yb2xlIjoiQWRtaW4ifQ.b0998815569be8f4ca8518030c3d586cc5bdff12dd7ad0004a1c38fa735ce18a</div></pre></td></tr></table></figure></p>
<h3 id="头部（Header）"><a href="#头部（Header）" class="headerlink" title="头部（Header）"></a>头部（Header）</h3><p>header 部分主要包括两部分，一个是 Token 的类型，另一个是使用的算法，<br>比如Token类型是 JWT，使用的算法是 HS256。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">&quot;typ&quot;: &quot;JWT&quot;,</div><div class="line">&quot;alg&quot;: &quot;HS256&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>经过base64编码之后的值为<br>eyJ0eXAiOiAiSldUIiwiYWxnIjogIkhTMjU2In0</p>
<h3 id="有效载荷（payload）"><a href="#有效载荷（payload）" class="headerlink" title="有效载荷（payload）"></a>有效载荷（payload）</h3><p>有效载荷内部的数据可以自己定义，JWT规范也给出了一些标准字段，比如</p>
<ul>
<li>iss: 该JWT的签发者</li>
<li>sub: 该JWT所面向的用户</li>
<li>aud: 接收该JWT的一方</li>
<li>exp(expires): 什么时候过期，这里是一个Unix时间戳</li>
<li>iat(issued at): 在什么时候签发的</li>
<li>jti(JWT ID）: 唯一的JWT ID</li>
</ul>
<p>比如payload内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;iss&quot;: &quot;harley&quot;,</div><div class="line">    &quot;iat&quot;: 1500955950,</div><div class="line">    &quot;exp&quot;: 1500957987,</div><div class="line">    &quot;user_id&quot;: &quot;7898&quot;,</div><div class="line">    &quot;user_role&quot;: &quot;Admin&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>base64加密后的结果为 eyJpc3MiOiAiaGFybGV5IiwiaWF0IjogMTUwMDk1NTk1MCwiZXhwIjogMTUwMDk1Nzk4NywidXNlcl9pZCI6ICI3ODk4IiwidXNlcl9yb2xlIjoiQWRtaW4ifQ</p>
<h3 id="签名（signature）"><a href="#签名（signature）" class="headerlink" title="签名（signature）"></a>签名（signature）</h3><p>签名部分保证了token的安全性，signature的生成过程依赖前两部分的内容。<br>将Header和payload连接在一起，得到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">eyJ0eXAiOiAiSldUIiwiYWxnIjogIkhTMjU2In0.eyJpc3MiOiAiaGFybGV5IiwiaWF0IjogMTUwMDk1NTk1MCwiZXhwIjogMTUwMDk1Nzk4NywidXNlcl9pZCI6ICI3ODk4IiwidXNlcl9yb2xlIjoiQWRtaW4ifQ</div></pre></td></tr></table></figure></p>
<p>将上面拼接完的字符串用HS256算法进行加密。在加密的时候，还需要提供一个密钥。假设密钥为secret，那么就可以得到我们加密后的内容b0998815569be8f4ca8518030c3d586cc5bdff12dd7ad0004a1c38fa735ce18a</p>
<p>加在后面得到完成JWT</p>
<h2 id="JWT安全性"><a href="#JWT安全性" class="headerlink" title="JWT安全性"></a>JWT安全性</h2><p>JWT最后的签名部分对Header和payload进行了加密，如果Header和payload被篡改，最后的signature必然是不一样的。 由于加密时的secret是保密的，篡改者无法得到正确的签名。</p>
<p>但同时要注意的是，由于header和payload部分并未加密，所以不能把敏感信息放入其中。</p>
]]></content>
      
        
        <tags>
            
            <tag> JWT </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>/2017/07/12/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
      
        
    </entry>
    
  
  
</search>
