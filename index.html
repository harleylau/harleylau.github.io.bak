<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Harley_Lau</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Harley_Lau">
<meta property="og:url" content="https://harleylau.github.io/index.html">
<meta property="og:site_name" content="Harley_Lau">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Harley_Lau">
  
    <link rel="alternate" href="/atom.xml" title="Harley_Lau" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Harley_Lau</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://harleylau.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Redis源码剖析-哈希对象t-hash实现" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/04/Redis源码剖析-哈希对象t-hash实现/" class="article-date">
  <time datetime="2018-06-04T02:29:07.000Z" itemprop="datePublished">2018-06-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/04/Redis源码剖析-哈希对象t-hash实现/">Redis源码剖析--哈希对象t_hash实现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="hash对象概述"><a href="#hash对象概述" class="headerlink" title="hash对象概述"></a>hash对象概述</h2><p>哈希对象的实现有点类似于版本3.2之前的列表对象实现，它的底层编码也有两种格式：ziplist 和 hashtable。</p>
<p>当哈希对象可以同时满足以下两个条件时， 哈希对象使用 ziplist 编码：</p>
<p>哈希对象保存的所有键值对的键和值的字符串长度都小于 64 字节；<br>哈希对象保存的键值对数量小于 512 个；<br>不能满足这两个条件的哈希对象需要使用 hashtable 编码。</p>
<p>当然，这两个阈值都是可以用户自行设置的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/* redis.conf文件中的阈值 */</div><div class="line">hash-max-ziplist-value 64 // ziplist中最大能存放的值长度</div><div class="line">hash-max-ziplist-entries 512 // ziplist中最多能存放的entry节点数量</div></pre></td></tr></table></figure>
<p>对于使用 ziplist 编码的列表对象来说， 当使用 ziplist 编码所需的两个条件的任意一个不能被满足时， 对象的编码转换操作就会被执行： 原本保存在压缩列表里的所有键值对都会被转移并保存到字典里面， 对象的编码也会从 ziplist 变为 hashtable 。并且这个转换过程也是一个不可逆的过程。</p>
<p>哈希对象的结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">typedef struct redisObject &#123;</div><div class="line">    unsigned type:4; // hash类型</div><div class="line">    unsigned encoding:4;  // //对象的编码类型，分别为 OBJ_ENCODING_ZIPLIST 或 OBJ_ENCODING_HT</div><div class="line">    unsigned lru:LRU_BITS;  // 上一次操作的时间</div><div class="line">    int refcount; // 引用计数，便于内存管理</div><div class="line">    void *ptr;  // 指向底层的数据结构</div><div class="line">&#125; robj;</div></pre></td></tr></table></figure>
<h2 id="ziplist-编码的哈希对象"><a href="#ziplist-编码的哈希对象" class="headerlink" title="ziplist 编码的哈希对象"></a>ziplist 编码的哈希对象</h2><p>当哈希对象底层采用ziplist的实现的时候，每次插入一个新的键值对，程序会先将保存了键的压缩列表节点推入到压缩列表表尾， 然后再将保存了值的压缩列表节点推入到压缩列表表尾。类似下图所示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">|zlbytes | zltail | zllen |   entry1  |  entry2  |   entry3  |   entry4  | zlend |</div><div class="line">                                ↓          ↓           ↓           ↓    </div><div class="line">                          |    key1   |  value1  |    key2   |   value2  |</div></pre></td></tr></table></figure>
<h2 id="hashtable-编码的哈希对象"><a href="#hashtable-编码的哈希对象" class="headerlink" title="hashtable 编码的哈希对象"></a>hashtable 编码的哈希对象</h2><p>当哈希对象底层采用hashtable实现的时候，哈希对象中的指针ptr会指向一个dict，哈希对象中的每个键值对都使用一个字典键值对来保存， 每个键和值都是一个字符串对象。</p>
<h2 id="hashtable-的实现"><a href="#hashtable-的实现" class="headerlink" title="hashtable 的实现"></a>hashtable 的实现</h2><table>
<thead>
<tr>
<th>命令</th>
<th>ziplist 编码实现方法</th>
<th>hashtable 编码的实现方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>HSET</td>
<td>首先调用 ziplistPush 函数， 将键推入到压缩列表的表尾， 然后再次调用 ziplistPush 函数， 将值推入到压缩列表的表尾。</td>
<td>调用 dictAdd 函数， 将新节点添加到字典里面。</td>
</tr>
<tr>
<td>HGET</td>
<td>首先调用 ziplistFind 函数， 在压缩列表中查找指定键所对应的节点， 然后调用 ziplistNext 函数， 将指针移动到键节点旁边的值节点， 最后返回值节点。</td>
<td>调用 dictFind 函数， 在字典中查找给定键， 然后调用 dictGetVal 函数， 返回该键所对应的值。</td>
</tr>
<tr>
<td>HEXISTS</td>
<td>调用 ziplistFind 函数， 在压缩列表中查找指定键所对应的节点， 如果找到的话说明键值对存在， 没找到的话就说明键值对不存在。</td>
<td>调用 dictFind 函数， 在字典中查找给定键， 如果找到的话说明键值对存在， 没找到的话就说明键值对不存在。</td>
</tr>
<tr>
<td>HDEL</td>
<td>调用 ziplistFind 函数， 在压缩列表中查找指定键所对应的节点， 然后将相应的键节点、 以及键节点旁边的值节点都删除掉。</td>
<td>调用 dictDelete 函数， 将指定键所对应的键值对从字典中删除掉。</td>
</tr>
<tr>
<td>HLEN</td>
<td>调用 ziplistLen 函数， 取得压缩列表包含节点的总数量， 将这个数量除以 2 ， 得出的结果就是压缩列表保存的键值对的数量。</td>
<td>调用 dictSize 函数， 返回字典包含的键值对数量， 这个数量就是哈希对象包含的键值对数量。</td>
</tr>
<tr>
<td>HGETALL</td>
<td>遍历整个压缩列表， 用 ziplistGet 函数返回所有键和值（都是节点）。</td>
<td>遍历整个字典， 用 dictGetKey 函数返回字典的键， 用 dictGetVal 函数返回字典的值。</td>
</tr>
</tbody>
</table>
<h3 id="HSET-实现分析"><a href="#HSET-实现分析" class="headerlink" title="HSET 实现分析"></a>HSET 实现分析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div></pre></td><td class="code"><pre><div class="line">/* Add a new field, overwrite the old with the new value if it already exists.</div><div class="line"> * Return 0 on insert and 1 on update.</div><div class="line"> *</div><div class="line"> * By default, the key and value SDS strings are copied if needed, so the</div><div class="line"> * caller retains ownership of the strings passed. However this behavior</div><div class="line"> * can be effected by passing appropriate flags (possibly bitwise OR-ed):</div><div class="line"> *</div><div class="line"> * HASH_SET_TAKE_FIELD -- The SDS field ownership passes to the function.</div><div class="line"> * HASH_SET_TAKE_VALUE -- The SDS value ownership passes to the function.</div><div class="line"> *</div><div class="line"> * When the flags are used the caller does not need to release the passed</div><div class="line"> * SDS string(s). It&apos;s up to the function to use the string to create a new</div><div class="line"> * entry or to free the SDS string before returning to the caller.</div><div class="line"> *</div><div class="line"> * HASH_SET_COPY corresponds to no flags passed, and means the default</div><div class="line"> * semantics of copying the values if needed.</div><div class="line"> *</div><div class="line"> */</div><div class="line">#define HASH_SET_TAKE_FIELD (1&lt;&lt;0)</div><div class="line">#define HASH_SET_TAKE_VALUE (1&lt;&lt;1)</div><div class="line">#define HASH_SET_COPY 0</div><div class="line">int hashTypeSet(robj *o, sds field, sds value, int flags) &#123;</div><div class="line">    int update = 0;</div><div class="line">	// 如果底层是ziplist编码</div><div class="line">    if (o-&gt;encoding == OBJ_ENCODING_ZIPLIST) &#123;</div><div class="line">        unsigned char *zl, *fptr, *vptr;</div><div class="line"></div><div class="line">        zl = o-&gt;ptr;</div><div class="line">        // 得到ziplist的head</div><div class="line">        fptr = ziplistIndex(zl, ZIPLIST_HEAD);</div><div class="line">        if (fptr != NULL) &#123;</div><div class="line">        		// 查看是否已经存在了该field</div><div class="line">            fptr = ziplistFind(fptr, (unsigned char*)field, sdslen(field), 1);</div><div class="line">            if (fptr != NULL) &#123;</div><div class="line">                /* Grab pointer to the value (fptr points to the field) */</div><div class="line">                // 如果已经存在，取ziplist的next，即对应的value</div><div class="line">                vptr = ziplistNext(zl, fptr);</div><div class="line">                serverAssert(vptr != NULL);</div><div class="line">                // 标记这次为更新操作</div><div class="line">                update = 1;</div><div class="line"></div><div class="line">                /* 删除旧的值 */</div><div class="line">                zl = ziplistDelete(zl, &amp;vptr);</div><div class="line"></div><div class="line">                /* 插入新的值 */</div><div class="line">                zl = ziplistInsert(zl, vptr, (unsigned char*)value,</div><div class="line">                        sdslen(value));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (!update) &#123;</div><div class="line">        	// 如果不是一个更新操作，需要把键值对插入到ziplist的尾部</div><div class="line">            /* Push new field/value pair onto the tail of the ziplist */</div><div class="line">            // 先插入键</div><div class="line">            zl = ziplistPush(zl, (unsigned char*)field, sdslen(field),</div><div class="line">                    ZIPLIST_TAIL);</div><div class="line">            // 后插入值</div><div class="line">            zl = ziplistPush(zl, (unsigned char*)value, sdslen(value),</div><div class="line">                    ZIPLIST_TAIL);</div><div class="line">        &#125;</div><div class="line">        o-&gt;ptr = zl;</div><div class="line"></div><div class="line">        /* 检查ziplist中存放的节点个数，如果超过512(默认值)则转换成OBJ_ENCODING_HT编码 */</div><div class="line">        if (hashTypeLength(o) &gt; server.hash_max_ziplist_entries)</div><div class="line">            hashTypeConvert(o, OBJ_ENCODING_HT);</div><div class="line">    &#125; else if (o-&gt;encoding == OBJ_ENCODING_HT) &#123;</div><div class="line">    	// 如果底层是hashtable编码实现</div><div class="line">    	// 在dict中查找对应的field</div><div class="line">        dictEntry *de = dictFind(o-&gt;ptr,field);</div><div class="line">        if (de) &#123;</div><div class="line">        		// 如果已经存在，执行更新操作</div><div class="line">            sdsfree(dictGetVal(de));</div><div class="line">            if (flags &amp; HASH_SET_TAKE_VALUE) &#123;</div><div class="line">                dictGetVal(de) = value;</div><div class="line">                value = NULL;</div><div class="line">            &#125; else &#123;</div><div class="line">                dictGetVal(de) = sdsdup(value);</div><div class="line">            &#125;</div><div class="line">            update = 1;</div><div class="line">        &#125; else &#123;</div><div class="line">        		// 如果不存在，dictAdd添加键值对</div><div class="line">            sds f,v;</div><div class="line">            if (flags &amp; HASH_SET_TAKE_FIELD) &#123;</div><div class="line">                f = field;</div><div class="line">                field = NULL;</div><div class="line">            &#125; else &#123;</div><div class="line">                f = sdsdup(field);</div><div class="line">            &#125;</div><div class="line">            if (flags &amp; HASH_SET_TAKE_VALUE) &#123;</div><div class="line">                v = value;</div><div class="line">                value = NULL;</div><div class="line">            &#125; else &#123;</div><div class="line">                v = sdsdup(value);</div><div class="line">            &#125;</div><div class="line">            dictAdd(o-&gt;ptr,f,v);</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        serverPanic(&quot;Unknown hash encoding&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* Free SDS strings we did not referenced elsewhere if the flags</div><div class="line">     * want this function to be responsible. */</div><div class="line">    if (flags &amp; HASH_SET_TAKE_FIELD &amp;&amp; field) sdsfree(field);</div><div class="line">    if (flags &amp; HASH_SET_TAKE_VALUE &amp;&amp; value) sdsfree(value);</div><div class="line">    return update;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这边相比之前的版本多了一个flag的参数， 针对这个flag有对应的三个宏定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#define HASH_SET_TAKE_FIELD (1&lt;&lt;0)</div><div class="line">#define HASH_SET_TAKE_VALUE (1&lt;&lt;1)</div><div class="line">#define HASH_SET_COPY 0</div></pre></td></tr></table></figure>
<p>这几个宏用于定义用于传进去的field与value是以拷贝的方法赋值，还是直接将找到的field与value直接以指针赋值的方式设置值。 </p>
<ul>
<li>若flag为HASH_SET_COPY，field与value没有释放掉空间 </li>
<li>若以HASH_SET_TAKE_VALUE则value的值会释放掉</li>
<li>若以HASH_SET_TAKE_FIELD则field的值会释放掉 </li>
</ul>
<p>这样我们就能理解在hashtable编码格式中，更新和插入的操作中，会根据flag来区别对待：是dictGetVal(de) = value 之后value置空还是 dictGetVal(de) = sdsdup(value)。 并且在函数的最后，也需要根据flag值来判断是否需要释放对应的field和value。</p>
<h3 id="转换函数"><a href="#转换函数" class="headerlink" title="转换函数"></a>转换函数</h3><p>上面我们能够看到ziplist在一定条件下会抓换成hashtable的编码，并且目前仍旧是一个不可逆的过程， 看一下转换的函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">void hashTypeConvertZiplist(robj *o, int enc) &#123;  </div><div class="line">    //用于类型的转化，根据enc，一般是从ziplist转化为dict  </div><div class="line">    serverAssert(o-&gt;encoding == OBJ_ENCODING_ZIPLIST);  </div><div class="line">  </div><div class="line">    if (enc == OBJ_ENCODING_ZIPLIST) &#123;  </div><div class="line">        //原来就是ziplist则不转换  </div><div class="line">        /* Nothing to do... */  </div><div class="line">  </div><div class="line">    &#125; else if (enc == OBJ_ENCODING_HT) &#123;  </div><div class="line">  </div><div class="line">        hashTypeIterator *hi;  </div><div class="line">        dict *dict;  </div><div class="line">        int ret;  </div><div class="line">  </div><div class="line">        hi = hashTypeInitIterator(o);  </div><div class="line">        dict = dictCreate(&amp;hashDictType, NULL);  </div><div class="line">        //初始化迭代器，创建新的表  </div><div class="line">  </div><div class="line">        while (hashTypeNext(hi) != C_ERR) &#123;  </div><div class="line">            sds key, value;  </div><div class="line">            //不断找到key-value并且插入。  </div><div class="line">  </div><div class="line">            key = hashTypeCurrentObjectNewSds(hi,OBJ_HASH_KEY);  </div><div class="line">            value = hashTypeCurrentObjectNewSds(hi,OBJ_HASH_VALUE);  </div><div class="line">            ret = dictAdd(dict, key, value);  </div><div class="line">            if (ret != DICT_OK) &#123;  </div><div class="line">                serverLogHexDump(LL_WARNING,&quot;ziplist with dup elements dump&quot;,  </div><div class="line">                    o-&gt;ptr,ziplistBlobLen(o-&gt;ptr));  </div><div class="line">                serverPanic(&quot;Ziplist corruption detected&quot;);  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">        hashTypeReleaseIterator(hi);  </div><div class="line">        //释放迭代器  </div><div class="line">        zfree(o-&gt;ptr);  </div><div class="line">        o-&gt;encoding = OBJ_ENCODING_HT;//将robj中的元素重新赋值  </div><div class="line">        o-&gt;ptr = dict;  </div><div class="line">  </div><div class="line">    &#125; else &#123;  </div><div class="line">        serverPanic(&quot;Unknown hash encoding&quot;);  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">void hashTypeConvert(robj *o, int enc) &#123;  </div><div class="line">    //类型转换api  </div><div class="line">    if (o-&gt;encoding == OBJ_ENCODING_ZIPLIST) &#123;  </div><div class="line">        hashTypeConvertZiplist(o, enc);  </div><div class="line">    &#125; else if (o-&gt;encoding == OBJ_ENCODING_HT) &#123;  </div><div class="line">        serverPanic(&quot;Not implemented&quot;);  </div><div class="line">    &#125; else &#123;  </div><div class="line">        serverPanic(&quot;Unknown hash encoding&quot;);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>在转换的过程中， 看到又引入了一个迭代器的概念， 我们来具体看一下相关的实现。</p>
<p>迭代器的定义如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">typedef struct &#123;</div><div class="line">    robj *subject;  // 指向的hash对象</div><div class="line">    int encoding;  // 编码类型</div><div class="line">    // 用于迭代ziplist结构</div><div class="line">    unsigned char *fptr, *vptr; // 域指针和值指针</div><div class="line">    // 用于迭代dict结构</div><div class="line">    dictIterator *di; // 字典迭代器</div><div class="line">    dictEntry *de;  // 指向当前迭代字典节点的指针</div><div class="line">&#125; hashTypeIterator;</div></pre></td></tr></table></figure>
<p>初始化迭代器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">// 返回一个初始化的哈希类型的迭代器</div><div class="line">hashTypeIterator *hashTypeInitIterator(robj *subject) &#123;</div><div class="line">    // 分配空间初始化成员</div><div class="line">    hashTypeIterator *hi = zmalloc(sizeof(hashTypeIterator));</div><div class="line">    hi-&gt;subject = subject;</div><div class="line">    hi-&gt;encoding = subject-&gt;encoding;</div><div class="line"></div><div class="line">    // 根据不同的编码设置不同的成员</div><div class="line">    if (hi-&gt;encoding == OBJ_ENCODING_ZIPLIST) &#123;</div><div class="line">        hi-&gt;fptr = NULL;</div><div class="line">        hi-&gt;vptr = NULL;</div><div class="line">    &#125; else if (hi-&gt;encoding == OBJ_ENCODING_HT) &#123;</div><div class="line">        // 初始化一个字典迭代器返回给di成员</div><div class="line">        hi-&gt;di = dictGetIterator(subject-&gt;ptr);</div><div class="line">    &#125; else &#123;</div><div class="line">        serverPanic(&quot;Unknown hash encoding&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return hi;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>迭代器释放：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/* 释放一个迭代器 */</div><div class="line">void hashTypeReleaseIterator(hashTypeIterator *hi) &#123;</div><div class="line">    if (hi-&gt;encoding == OBJ_ENCODING_HT) &#123;</div><div class="line">        dictReleaseIterator(hi-&gt;di);</div><div class="line">    &#125;</div><div class="line">    zfree(hi);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>迭代步骤：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">/* 迭代到下一个节点 */ </div><div class="line">int hashTypeNext(hashTypeIterator *hi) &#123;</div><div class="line">    if (hi-&gt;encoding == OBJ_ENCODING_ZIPLIST) &#123;</div><div class="line">        unsigned char *zl;</div><div class="line">        unsigned char *fptr, *vptr;</div><div class="line">        zl = hi-&gt;subject-&gt;ptr;</div><div class="line">        fptr = hi-&gt;fptr;</div><div class="line">        vptr = hi-&gt;vptr;</div><div class="line">        if (fptr == NULL) &#123;</div><div class="line">            // 如果当前迭代器为空，则初始化指向ziplist的第一个节点</div><div class="line">            serverAssert(vptr == NULL);</div><div class="line">            fptr = ziplistIndex(zl, 0);</div><div class="line">        &#125; else &#123;</div><div class="line">            // 反之指向下一个key节点</div><div class="line">            serverAssert(vptr != NULL);</div><div class="line">            fptr = ziplistNext(zl, vptr);</div><div class="line">        &#125;</div><div class="line">        if (fptr == NULL) return C_ERR;</div><div class="line">        // fptr的下一个节点就是值节点</div><div class="line">        vptr = ziplistNext(zl, fptr);</div><div class="line">        serverAssert(vptr != NULL);</div><div class="line">        // 更新参数</div><div class="line">        hi-&gt;fptr = fptr;</div><div class="line">        hi-&gt;vptr = vptr;</div><div class="line">    &#125; else if (hi-&gt;encoding == OBJ_ENCODING_HT) &#123;</div><div class="line">        // OBJ_ENCODING_HT编码的时候就直接调用哈希的迭代器即可</div><div class="line">        if ((hi-&gt;de = dictNext(hi-&gt;di)) == NULL) return C_ERR;</div><div class="line">    &#125; else &#123;</div><div class="line">        serverPanic(&quot;Unknown hash encoding&quot;);</div><div class="line">    &#125;</div><div class="line">    return C_OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://harleylau.github.io/2018/06/04/Redis源码剖析-哈希对象t-hash实现/" data-id="cji4caxmy000oik68vgvnibcr" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/">redis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码/">源码</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Redis源码剖析-quicklist" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/31/Redis源码剖析-quicklist/" class="article-date">
  <time datetime="2018-05-31T01:43:09.000Z" itemprop="datePublished">2018-05-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/31/Redis源码剖析-quicklist/">Redis源码剖析--quicklist</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="quicklist概述"><a href="#quicklist概述" class="headerlink" title="quicklist概述"></a>quicklist概述</h2><p>上一节中，我们有说到Redis中的列表对象在版本3.2之前，列表底层的编码是 ziplist 和 linkedlist 实现的， 但是在版本3.2之后，重新引入了一个 quicklist 的数据结构，列表的底层都由quicklist实现。</p>
<p>在早期的设计中， 当列表对象中元素的长度比较小或者数量比较少的时候，采用ziplist来存储，当列表对象中元素的长度比较大或者数量比较多的时候，则会转而使用双向列表linkedlist来存储。</p>
<p>这两种存储方式都各有优缺点</p>
<ul>
<li>双向链表linkedlist便于在表的两端进行push和pop操作，在插入节点上复杂度很低，但是它的内存开销比较大。首先，它在每个节点上除了要保存数据之外，还要额外保存两个指针；其次，双向链表的各个节点是单独的内存块，地址不连续，节点多了容易产生内存碎片。</li>
<li>ziplist存储在一段连续的内存上，所以存储效率很高。但是，它不利于修改操作，插入和删除操作需要频繁的申请和释放内存。特别是当ziplist长度很长的时候，一次realloc可能会导致大批量的数据拷贝。</li>
</ul>
<p>早期版本在这边选择的折中方案是两种数据类型的转换，但是在3.2版本之后，不知道出于什么原因， 猜测会不会因为转换也是个费时且复杂的操作，引入了一种新的数据格式，结合了双向列表linkedlist和ziplist的特点，称之为quicklist。所有的节点都用quicklist存储，省去了到临界条件是的格式转换。</p>
<p>那么quicklist是一种什么样的格式呢？简单的说，我们仍旧可以将其看作一个双向列表，但是列表的每个节点都是一个ziplist，其实就是linkedlist和ziplist的结合。quicklist中的每个节点ziplist都能够存储多个数据元素。</p>
<h2 id="quicklist实现"><a href="#quicklist实现" class="headerlink" title="quicklist实现"></a>quicklist实现</h2><p>接下去我们看下quicklist的具体实现。</p>
<p>quicklist的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">typedef struct quicklist &#123;</div><div class="line">    quicklistNode *head;        // 指向quicklist的头部</div><div class="line">    quicklistNode *tail;        // 指向quicklist的尾部</div><div class="line">    unsigned long count;        // 列表中所有数据项的个数总和</div><div class="line">    unsigned int len;           // quicklist节点的个数，即ziplist的个数</div><div class="line">    int fill : 16;              // ziplist大小限定，由list-max-ziplist-size给定</div><div class="line">    unsigned int compress : 16; // 节点压缩深度设置，由list-compress-depth给定</div><div class="line">&#125; quicklist;</div></pre></td></tr></table></figure>
<p>可以看到，这边其实有两个统计值，count用来统计所有数据项的个数总和，len用来统计quicklist的节点个数， 因为每个节点ziplist都能存储多个数据项，所以有了这两个统计值。</p>
<p>另外，插一点，quicklist的这个结构体在源码中说是占用了32byte的空间，怎么计算的呢？这边涉及到了位域的概念，所谓”位域“是把一个字节中的二进位划分为几 个不同的区域， 并说明每个区域的位数。每个域有一个域名，允许在程序中按域名进行操作。比如这个“int fill : 16” 表示不用整个int存储fill，而是只用了其中的16位来存储。</p>
<p>好了，回到正题。</p>
<p>quicklist的节点node的定义如下： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">typedef struct quicklistNode &#123;</div><div class="line">    struct quicklistNode *prev;  // 指向上一个ziplist节点</div><div class="line">    struct quicklistNode *next;  // 指向下一个ziplist节点</div><div class="line">    unsigned char *zl;           // 数据指针，如果没有被压缩，就指向ziplist结构，反之指向quicklistLZF结构 </div><div class="line">    unsigned int sz;             // 表示指向ziplist结构的总长度(内存占用长度)</div><div class="line">    unsigned int count : 16;     // 表示ziplist中的数据项个数</div><div class="line">    unsigned int encoding : 2;   // 编码方式，1--ziplist，2--quicklistLZF</div><div class="line">    unsigned int container : 2;  // 预留字段，存放数据的方式，1--NONE，2--ziplist</div><div class="line">    unsigned int recompress : 1; // 解压标记，当查看一个被压缩的数据时，需要暂时解压，标记此参数为1，之后再重新进行压缩</div><div class="line">    unsigned int attempted_compress : 1; // 测试相关</div><div class="line">    unsigned int extra : 10; // 扩展字段，暂时没用</div><div class="line">&#125; quicklistNode;</div></pre></td></tr></table></figure>
<p>这样， 我们就可以知道整个quicklist的结构</p>
<p><img src="/2018/05/31/Redis源码剖析-quicklist/quicklist.jpg" alt="quicklist结构"></p>
<p>图上显示了两种ziplist的结构，一种是经过压缩的，一种是未经压缩的。</p>
<h2 id="quicklist操作"><a href="#quicklist操作" class="headerlink" title="quicklist操作"></a>quicklist操作</h2><h3 id="创建quicklist"><a href="#创建quicklist" class="headerlink" title="创建quicklist"></a>创建quicklist</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/* Create a new quicklist.</div><div class="line"> * Free with quicklistRelease(). */</div><div class="line">quicklist *quicklistCreate(void) &#123;</div><div class="line">    struct quicklist *quicklist;</div><div class="line"></div><div class="line">    quicklist = zmalloc(sizeof(*quicklist));  // 分配空间</div><div class="line">    quicklist-&gt;head = quicklist-&gt;tail = NULL;  // 头尾指针为空</div><div class="line">    quicklist-&gt;len = 0;            // 列表长度为0</div><div class="line">    quicklist-&gt;count = 0;           // 数据项总和为0</div><div class="line">    quicklist-&gt;compress = 0;        // 设定压缩深度</div><div class="line">    quicklist-&gt;fill = -2;           // 设定ziplist大小</div><div class="line">    return quicklist;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>quicklist中的节点创建</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">REDIS_STATIC quicklistNode *quicklistCreateNode(void) &#123;</div><div class="line">    quicklistNode *node;</div><div class="line">    node = zmalloc(sizeof(*node));      // 分配空间</div><div class="line">    node-&gt;zl = NULL;                    // 初始化指向ziplist的指针</div><div class="line">    node-&gt;count = 0;                    // 数据项个数为0</div><div class="line">    node-&gt;sz = 0;                       // ziplist大小为0</div><div class="line">    node-&gt;next = node-&gt;prev = NULL;     // 前后指针为空</div><div class="line">    node-&gt;encoding = QUICKLIST_NODE_ENCODING_RAW;  // 节点编码方式</div><div class="line">    node-&gt;container = QUICKLIST_NODE_CONTAINER_ZIPLIST;     // 数据存放方式</div><div class="line">    node-&gt;recompress = 0;               // 初始化压缩标记</div><div class="line">    return node;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="quicklist的push操作"><a href="#quicklist的push操作" class="headerlink" title="quicklist的push操作"></a>quicklist的push操作</h3><p>quicklist的push操作其实就是在双向列表的头节点或尾节点上插入一个新的元素。从上面我们知道，quicklist的每个节点都是一个ziplist，所以这个push操作就涉及到一个问题，当前节点的ziplist是否能够放进新元素。</p>
<ul>
<li>如果ziplist能够放入新元素，即大小没有超过限制（list-max-ziplist-size），那么直接调用ziplistPush函数压入</li>
<li>如果ziplist不能放入新元素，则新建一个quicklist节点，即新的ziplist，新的数据项会被插入到新的ziplist，新的quicklist节点插入到原有的quicklist上</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/* Wrapper to allow argument-based switching between HEAD/TAIL pop */</div><div class="line">void quicklistPush(quicklist *quicklist, void *value, const size_t sz,</div><div class="line">                   int where) &#123;</div><div class="line">    if (where == QUICKLIST_HEAD) &#123;</div><div class="line">        quicklistPushHead(quicklist, value, sz);</div><div class="line">    &#125; else if (where == QUICKLIST_TAIL) &#123;</div><div class="line">        quicklistPushTail(quicklist, value, sz);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>函数里边， 根据是头部插入还是尾部插入调用不同的函数。先看头部插入的情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">/* Add new entry to head node of quicklist.</div><div class="line"> *</div><div class="line"> * Returns 0 if used existing head.</div><div class="line"> * Returns 1 if new head created. */</div><div class="line">int quicklistPushHead(quicklist *quicklist, void *value, size_t sz) &#123;</div><div class="line">    quicklistNode *orig_head = quicklist-&gt;head;</div><div class="line">    if (likely(</div><div class="line">            // 判断头部节点是否能够插入新元素</div><div class="line">            _quicklistNodeAllowInsert(quicklist-&gt;head, quicklist-&gt;fill, sz))) &#123;</div><div class="line">        quicklist-&gt;head-&gt;zl =</div><div class="line">            // 如果能够插入，则执行ziplistPush插入新元素的当前节点的ziplist</div><div class="line">            ziplistPush(quicklist-&gt;head-&gt;zl, value, sz, ZIPLIST_HEAD);</div><div class="line">        // 更新头部大小</div><div class="line">        quicklistNodeUpdateSz(quicklist-&gt;head);</div><div class="line">    &#125; else &#123;</div><div class="line">        // 否则的话，需要创建新的quicklist节点</div><div class="line">        quicklistNode *node = quicklistCreateNode();</div><div class="line">        // 将新节点压入新创建的ziplist中，并与新创建的quicklist节点关联起来</div><div class="line">        node-&gt;zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_HEAD);</div><div class="line">        // 更新头部信息</div><div class="line">        quicklistNodeUpdateSz(node);</div><div class="line">        // 将新创建的节点插入到quicklist中</div><div class="line">        _quicklistInsertNodeBefore(quicklist, quicklist-&gt;head, node);</div><div class="line">    &#125;</div><div class="line">    // 更新quicklist的数据项个数</div><div class="line">    quicklist-&gt;count++;</div><div class="line">    // 更新头结点的数据项个数</div><div class="line">    quicklist-&gt;head-&gt;count++;</div><div class="line">    return (orig_head != quicklist-&gt;head);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在尾部插入数据的操作也是类似的， 不多具体介绍， 我们再看一下判断当前ziplist节点是否能插入的函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">REDIS_STATIC int _quicklistNodeAllowInsert(const quicklistNode *node,</div><div class="line">                                           const int fill, const size_t sz) &#123;   // 判断当前node是否还能插入数据</div><div class="line">    if (unlikely(!node))</div><div class="line">        return 0;</div><div class="line"></div><div class="line">    int ziplist_overhead;</div><div class="line">    /* size of previous offset */</div><div class="line">    if (sz &lt; 254)   // 小于254时后一个节点的pre只有1字节,否则为5字节</div><div class="line">        ziplist_overhead = 1;</div><div class="line">    else</div><div class="line">        ziplist_overhead = 5;</div><div class="line"></div><div class="line">    /* size of forward offset */</div><div class="line">    if (sz &lt; 64)    // 小于64字节当前节点的encoding为1</div><div class="line">        ziplist_overhead += 1;</div><div class="line">    else if (likely(sz &lt; 16384))    // 小于16384 encoding为2字节</div><div class="line">        ziplist_overhead += 2;</div><div class="line">    else    // encoding为5字节</div><div class="line">        ziplist_overhead += 5;</div><div class="line"></div><div class="line">    /* new_sz overestimates if &apos;sz&apos; encodes to an integer type */</div><div class="line">    unsigned int new_sz = node-&gt;sz + sz + ziplist_overhead; // 忽略了连锁更新的情况</div><div class="line">    if (likely(_quicklistNodeSizeMeetsOptimizationRequirement(new_sz, fill)))   // // 校验fill为负数是否超过单存储限制</div><div class="line">        return 1;</div><div class="line">    else if (!sizeMeetsSafetyLimit(new_sz)) // 校验单个节点是否超过8kb，主要防止fill为正数时单个节点内存过大</div><div class="line">        return 0;</div><div class="line">    else if ((int)node-&gt;count &lt; fill)   // fill为正数是否超过存储限制</div><div class="line">        return 1;</div><div class="line">    else</div><div class="line">        return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>quicklist还能在指定的位置插入数据，quicklistInsertAfter和quicklistInsertBefore就是分别在指定位置后面和前面插入数据项。当然，和在头尾节点插入一样， 任意位置插入也是需要判断当前插入节点是否能够放得下当前的元素的，这边的情况会比头尾节点更为复杂，比如在当前节点放不下的时候，还需要检查一下旁边的节点是否能够放下这个数据，能够放下的话可以放置在旁边的节点上，如果也不行的话，就是需要新建一个ziplist节点。</p>
<p>写到最后，发现虽然通篇在说每个节点ziplist能够容纳多个元素，但是没有具体介绍配置的参数。不过，从上边的分析也能看出来，这个是有quicklist的结构中的fill字段指定的， 这个fill字段会读取配置中的list-max-ziplist-size参数值。</p>
<p>这个参数它可以取正值，也可以取负值。</p>
<p>当取正值的时候，表示按照数据项个数来限定每个quicklist节点上的ziplist长度。比如，当这个参数配置成3的时候，表示每个quicklist节点的ziplist最多包含3个数据项。</p>
<p>当取负值的时候，表示按照占用字节数来限定每个quicklist节点上的ziplist长度。这时，它只能取-1到-5这五个值，每个值含义如下：</p>
<ul>
<li>-5: 每个quicklist节点上的ziplist大小不能超过64 Kb。（注：1kb =&gt; 1024 bytes）</li>
<li>-4: 每个quicklist节点上的ziplist大小不能超过32 Kb。</li>
<li>-3: 每个quicklist节点上的ziplist大小不能超过16 Kb。</li>
<li>-2: 每个quicklist节点上的ziplist大小不能超过8 Kb。（-2是Redis给出的默认值）</li>
<li>-1: 每个quicklist节点上的ziplist大小不能超过4 Kb。</li>
</ul>
<p>还有一个参数list-compress-depth表示列表两头不压缩的节点的个数</p>
<ul>
<li>0 特殊值，表示不压缩</li>
<li>1 表示quicklist两端各有一个节点不压缩，中间的节点压缩</li>
<li>2 表示quicklist两端各有两个节点不压缩，中间的节点压缩</li>
<li>3 表示quicklist两端各有三个节点不压缩，中间的节点压缩</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://harleylau.github.io/2018/05/31/Redis源码剖析-quicklist/" data-id="cji4caxli0003ik68v4zsmaq4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/">redis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码/">源码</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Redis源码剖析-列表t-list实现" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/10/Redis源码剖析-列表t-list实现/" class="article-date">
  <time datetime="2018-05-10T01:53:08.000Z" itemprop="datePublished">2018-05-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/10/Redis源码剖析-列表t-list实现/">Redis源码剖析--列表t_list实现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Redis中的列表对象比较特殊，在版本3.2之前，列表底层的编码是 ziplist 和 linkedlist 实现的， 但是在版本3.2之后，重新引入了一个 quicklist 的数据结构，列表的底层都由quicklist实现。</p>
<p>这边是在看源码和实际验证的时候发现的区别，然后上网查证。由于目前使用的redis基本都在3.2了， 而且老版本肯定会被取代， 所以我们只分析3.2版本之后的实现。对于老版本的列表实现，一笔带过吧。 </p>
<p>在老版本中，当列表对象可以同时满足以下两个条件时， 列表对象使用 ziplist 编码：</p>
<ul>
<li>列表对象保存的所有字符串元素的长度都小于 64 字节；</li>
<li>列表对象保存的元素数量小于 512 个；</li>
</ul>
<p>不能满足这两个条件的列表对象需要使用 linkedlist 编码。当这两个条件任何一个不满足的时候，就会有一个格式的转换。</p>
<p>对于quicklist的结构，下节中在具体分析，先来看下list的实现。</p>
<h2 id="List的结构"><a href="#List的结构" class="headerlink" title="List的结构"></a>List的结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/* Structure to hold list iteration abstraction. */</div><div class="line">typedef struct &#123;</div><div class="line">    robj *subject;</div><div class="line">    unsigned char encoding;</div><div class="line">    unsigned char direction; /* Iteration direction */</div><div class="line">    quicklistIter *iter;</div><div class="line">&#125; listTypeIterator;</div><div class="line"></div><div class="line">/* Structure for an entry while iterating over a list. */</div><div class="line">typedef struct &#123;</div><div class="line">    listTypeIterator *li;</div><div class="line">    quicklistEntry entry; /* Entry in quicklist */</div><div class="line">&#125; listTypeEntry;</div></pre></td></tr></table></figure>
<p>List的结构其实就是定义了一个列表的头节点， 以及一个迭代器指针，指针中指定了编码格式和迭代方向。</p>
<h2 id="List命令"><a href="#List命令" class="headerlink" title="List命令"></a>List命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>BLPOP key1 [key2 ] timeout</td>
<td>移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td>
</tr>
<tr>
<td>BRPOP key1 [key2 ] timeout</td>
<td>移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td>
</tr>
<tr>
<td>BRPOPLPUSH source destination timeout</td>
<td>从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它；如但果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td>
</tr>
<tr>
<td>LINDEX key index</td>
<td>通过索引获取列表中的元素</td>
</tr>
<tr>
<td>LINSERT key BEFORE</td>
<td>AFTER pivot value</td>
<td>在列表的元素前或者后插入元素</td>
</tr>
<tr>
<td>LLEN key</td>
<td>获取列表长度</td>
</tr>
<tr>
<td>LPOP key</td>
<td>移出并获取列表的第一个元素</td>
</tr>
<tr>
<td>LPUSH key value1 [value2]</td>
<td>将一个或多个值插入到列表头部</td>
</tr>
<tr>
<td>LPUSHX key value</td>
<td>将一个或多个值插入到已存在的列表头部</td>
</tr>
<tr>
<td>LRANGE key start stop</td>
<td>获取列表指定范围内的元素</td>
</tr>
<tr>
<td>LREM key count value</td>
<td>移除列表元素</td>
</tr>
<tr>
<td>LSET key index value</td>
<td>通过索引设置列表元素的值</td>
</tr>
<tr>
<td>LTRIM key start stop</td>
<td>对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。</td>
</tr>
<tr>
<td>RPOP key</td>
<td>移除并获取列表最后一个元素</td>
</tr>
<tr>
<td>RPOPLPUSH source destination</td>
<td>移除列表的最后一个元素，并将该元素添加到另一个列表并返回</td>
</tr>
<tr>
<td>RPUSH key value1 [value2]</td>
<td>在列表中添加一个或多个值</td>
</tr>
<tr>
<td>RPUSHX key value</td>
<td>为已存在的列表添加值</td>
</tr>
</tbody>
</table>
<h2 id="List命令实现"><a href="#List命令实现" class="headerlink" title="List命令实现"></a>List命令实现</h2><h3 id="push命令实现"><a href="#push命令实现" class="headerlink" title="push命令实现"></a>push命令实现</h3><p>lpush和rpush分别调用的下边的两个函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// lpush操作</div><div class="line">void lpushCommand(client *c) &#123;</div><div class="line">    pushGenericCommand(c,LIST_HEAD);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// rpush操作</div><div class="line">void rpushCommand(client *c) &#123;</div><div class="line">    pushGenericCommand(c,LIST_TAIL);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到， 这两个操作其实都是调用的pushGenericCommand这个函数实现， 不同的点是指定了是从HEAD的位置push一个数据还是从TAIL的位置push一个数据。接下来来看pushGenericCommand的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">void pushGenericCommand(client *c, int where) &#123;</div><div class="line">    int j, pushed = 0;</div><div class="line">    // 现在数据库中查找是否已经存在了该键</div><div class="line">    robj *lobj = lookupKeyWrite(c-&gt;db,c-&gt;argv[1]);</div><div class="line">    // 如果已经存在了该键，验证该键是否是list类型，如果不是的话，返回错误</div><div class="line">    if (lobj &amp;&amp; lobj-&gt;type != OBJ_LIST) &#123;</div><div class="line">        addReply(c,shared.wrongtypeerr);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    // 遍历剩余的参数</div><div class="line">    for (j = 2; j &lt; c-&gt;argc; j++) &#123;</div><div class="line">        // 如果该键不存在，创建一个quicklist</div><div class="line">        if (!lobj) &#123;</div><div class="line">            lobj = createQuicklistObject();</div><div class="line">            quicklistSetOptions(lobj-&gt;ptr, server.list_max_ziplist_size,</div><div class="line">                                server.list_compress_depth);</div><div class="line">            // 将创建的键添加到对应的db</div><div class="line">            dbAdd(c-&gt;db,c-&gt;argv[1],lobj);</div><div class="line">        &#125;</div><div class="line">        // 执行push操作</div><div class="line">        listTypePush(lobj,c-&gt;argv[j],where);</div><div class="line">        // 个数加1</div><div class="line">        pushed++;</div><div class="line">    &#125;</div><div class="line">    // 返回添加的节点数量</div><div class="line">    addReplyLongLong(c, (lobj ? listTypeLength(lobj) : 0));</div><div class="line">    // 至少有一个添加成功则进行操作</div><div class="line">    if (pushed) &#123;</div><div class="line">        char *event = (where == LIST_HEAD) ? &quot;lpush&quot; : &quot;rpush&quot;;</div><div class="line">        // 发送键修改信号</div><div class="line">        signalModifiedKey(c-&gt;db,c-&gt;argv[1]);</div><div class="line">        // 发送事件通知</div><div class="line">        notifyKeyspaceEvent(NOTIFY_LIST,event,c-&gt;argv[1],c-&gt;db-&gt;id);</div><div class="line">    &#125;</div><div class="line">    // 服务器的脏数据个数增加</div><div class="line">    server.dirty += pushed;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>内部最终还是调用了一个listTypePush的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">/* The function pushes an element to the specified list object &apos;subject&apos;,</div><div class="line"> * at head or tail position as specified by &apos;where&apos;.</div><div class="line"> *</div><div class="line"> * There is no need for the caller to increment the refcount of &apos;value&apos; as</div><div class="line"> * the function takes care of it if needed. */</div><div class="line">void listTypePush(robj *subject, robj *value, int where) &#123;</div><div class="line">    // 判断类型是否为quciklist，不是的话返回错误</div><div class="line">    if (subject-&gt;encoding == OBJ_ENCODING_QUICKLIST) &#123;</div><div class="line">        int pos = (where == LIST_HEAD) ? QUICKLIST_HEAD : QUICKLIST_TAIL;</div><div class="line">        // 解码数据</div><div class="line">        value = getDecodedObject(value);</div><div class="line">        // 得到数据的长度</div><div class="line">        size_t len = sdslen(value-&gt;ptr);</div><div class="line">        // 调用quicklistPush插入数据</div><div class="line">        quicklistPush(subject-&gt;ptr, value-&gt;ptr, len, pos);</div><div class="line">        // 将数据项对象的引用次数减1，也就是释放value</div><div class="line">        decrRefCount(value);</div><div class="line">    &#125; else &#123;</div><div class="line">        serverPanic(&quot;Unknown list encoding&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>pop的操作其实跟push的操作很相似，比较容易读懂。List的操作比较有特点的一项是阻塞操作，可以来分析一下。</p>
<h3 id="阻塞pop操作的实现"><a href="#阻塞pop操作的实现" class="headerlink" title="阻塞pop操作的实现"></a>阻塞pop操作的实现</h3><p>首先，一样是调用了最上层的两个函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// blpop</div><div class="line">void blpopCommand(client *c) &#123;</div><div class="line">    blockingPopGenericCommand(c,LIST_HEAD);</div><div class="line">&#125;</div><div class="line">// brpop</div><div class="line">void brpopCommand(client *c) &#123;</div><div class="line">    blockingPopGenericCommand(c,LIST_TAIL);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>他们其实都是调用blockingPopGenericCommand来实现的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">/* Blocking RPOP/LPOP */</div><div class="line">void blockingPopGenericCommand(client *c, int where) &#123;</div><div class="line">    robj *o;</div><div class="line">    mstime_t timeout;</div><div class="line">    int j;</div><div class="line"></div><div class="line">    // 取出timeout参数</div><div class="line">    if (getTimeoutFromObjectOrReply(c,c-&gt;argv[c-&gt;argc-1],&amp;timeout,UNIT_SECONDS)</div><div class="line">        != C_OK) return;</div><div class="line">    // 遍历参数</div><div class="line">    for (j = 1; j &lt; c-&gt;argc-1; j++) &#123;</div><div class="line">        // 查看数据库中是否存在该键</div><div class="line">        o = lookupKeyWrite(c-&gt;db,c-&gt;argv[j]);</div><div class="line">        if (o != NULL) &#123;</div><div class="line">            // 如果存在，判断该键是否是list类型，不是的话报错</div><div class="line">            if (o-&gt;type != OBJ_LIST) &#123;</div><div class="line">                addReply(c,shared.wrongtypeerr);</div><div class="line">                return;</div><div class="line">            &#125; else &#123;</div><div class="line">                // 当前列表非空，直接执行pop操作</div><div class="line">                if (listTypeLength(o) != 0) &#123;</div><div class="line">                    /* Non empty list, this is like a non normal [LR]POP. */</div><div class="line">                    char *event = (where == LIST_HEAD) ? &quot;lpop&quot; : &quot;rpop&quot;;</div><div class="line">                    robj *value = listTypePop(o,where);</div><div class="line">                    serverAssert(value != NULL);</div><div class="line"></div><div class="line">                    addReplyMultiBulkLen(c,2);</div><div class="line">                    addReplyBulk(c,c-&gt;argv[j]);</div><div class="line">                    addReplyBulk(c,value);</div><div class="line">                    decrRefCount(value);</div><div class="line">                    notifyKeyspaceEvent(NOTIFY_LIST,event,</div><div class="line">                                        c-&gt;argv[j],c-&gt;db-&gt;id);</div><div class="line">                    // 如果当前key弹出一个值之后为空，删除这个列表</div><div class="line">                    if (listTypeLength(o) == 0) &#123;</div><div class="line">                        dbDelete(c-&gt;db,c-&gt;argv[j]);</div><div class="line">                        notifyKeyspaceEvent(NOTIFY_GENERIC,&quot;del&quot;,</div><div class="line">                                            c-&gt;argv[j],c-&gt;db-&gt;id);</div><div class="line">                    &#125;</div><div class="line">                    signalModifiedKey(c-&gt;db,c-&gt;argv[j]);</div><div class="line">                    server.dirty++;</div><div class="line"></div><div class="line">                    /* Replicate it as an [LR]POP instead of B[LR]POP. */</div><div class="line">                    rewriteClientCommandVector(c,2,</div><div class="line">                        (where == LIST_HEAD) ? shared.lpop : shared.rpop,</div><div class="line">                        c-&gt;argv[j]);</div><div class="line">                    return;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* If we are inside a MULTI/EXEC and the list is empty the only thing</div><div class="line">     * we can do is treating it as a timeout (even with timeout 0). */</div><div class="line">    if (c-&gt;flags &amp; CLIENT_MULTI) &#123;</div><div class="line">        addReply(c,shared.nullmultibulk);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* If the list is empty or the key does not exists we must block */</div><div class="line">    // 参数中的所有键都不存在，则阻塞这些键</div><div class="line">    blockForKeys(c, c-&gt;argv + 1, c-&gt;argc - 2, timeout, NULL);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到， 当指定的list存在于当前数据库中且list不为空，就会执行一次普通的pop操作；但是当指定的list键不存在，或者该list为空，就会阻塞该操作。就是上边代码中的最后一句。</p>
<p>接下去，就是看redis如何处理这个被阻塞的操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">/* Set a client in blocking mode for the specified key, with the specified</div><div class="line"> * timeout */</div><div class="line"> // 设置键的阻塞状态</div><div class="line">void blockForKeys(client *c, robj **keys, int numkeys, mstime_t timeout, robj *target) &#123;</div><div class="line">    dictEntry *de;</div><div class="line">    list *l;</div><div class="line">    int j;</div><div class="line"></div><div class="line">    c-&gt;bpop.timeout = timeout;</div><div class="line">    c-&gt;bpop.target = target;</div><div class="line"></div><div class="line">    if (target != NULL) incrRefCount(target);</div><div class="line"></div><div class="line">    // 遍历所有的key</div><div class="line">    for (j = 0; j &lt; numkeys; j++) &#123;</div><div class="line">        /* If the key already exists in the dict ignore it. */</div><div class="line">        // 如果当前键存在，则忽略；反之则添加该键</div><div class="line">        // bpop.keys记录所有造成客户端阻塞的键</div><div class="line">        if (dictAdd(c-&gt;bpop.keys,keys[j],NULL) != DICT_OK) continue;</div><div class="line">        //当前的key引用计数加1</div><div class="line">        incrRefCount(keys[j]);</div><div class="line"></div><div class="line">        /* And in the other &quot;side&quot;, to map keys -&gt; clients */</div><div class="line">        // blocking_keys是一个字典，其键为造成阻塞的键，值是一个链表，记录所有被该键阻塞的客户端</div><div class="line">        // 查找当前造成阻塞的键</div><div class="line">        de = dictFind(c-&gt;db-&gt;blocking_keys,keys[j]);</div><div class="line">        if (de == NULL) &#123;</div><div class="line">            // 如果不存在，需要新创建一个， 并加入到blocking_keys中</div><div class="line">            int retval;</div><div class="line"></div><div class="line">            /* For every key we take a list of clients blocked for it */</div><div class="line">            l = listCreate();</div><div class="line">            // 将键和新创建的列表加入</div><div class="line">            retval = dictAdd(c-&gt;db-&gt;blocking_keys,keys[j],l);</div><div class="line">            incrRefCount(keys[j]);</div><div class="line">            serverAssertWithInfo(c,keys[j],retval == DICT_OK);</div><div class="line">        &#125; else &#123;</div><div class="line">            // 如果存在，获取该键的值，即客户端列表</div><div class="line">            l = dictGetVal(de);</div><div class="line">        &#125;</div><div class="line">        // 将当前的客户端加入的该键的阻塞列表中</div><div class="line">        listAddNodeTail(l,c);</div><div class="line">    &#125;</div><div class="line">    // 阻塞该客户端</div><div class="line">    blockClient(c,BLOCKED_LIST);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上边的代码中，可以看到客户端分别用来c-&gt;bpop.xxxx 和 c-&gt;db-&gt;blocking_keys用来保存被阻塞的键，以及阻塞的键和客户端的对应关系。</p>
<p>他们的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">// server.h</div><div class="line">typedef struct client &#123;</div><div class="line">    //client当前使用的数据库</div><div class="line">    redisDb *db;   /* Pointer to currently SELECTed DB. */</div><div class="line"></div><div class="line">    //阻塞状态</div><div class="line">    blockingState bpop;     /* blocking state */</div><div class="line">    //其他成员省略</div><div class="line">&#125; client;</div><div class="line"></div><div class="line">// 阻塞状态结构体</div><div class="line">typedef struct blockingState &#123;</div><div class="line">    mstime_t timeout;      // 阻塞超时时间</div><div class="line">    dict *keys;           // 记录所有造成客户端阻塞的键</div><div class="line">    robj *target;         // 目标选项，target在执行RPOPLPUSH命令时使用，</div><div class="line">    /* BLOCKED_WAIT */</div><div class="line">    int numreplicas;        /* Number of replicas we are waiting for ACK. */</div><div class="line">    long long reploffset;   /* Replication offset to reach. */</div><div class="line">&#125; blockingState;</div><div class="line">typedef struct redisDb &#123;</div><div class="line">    dict *blocking_keys;        // 记录所有造成阻塞的键，及其相应的客户端</div><div class="line">    // ...其他参数省略</div><div class="line">&#125; redisDb;</div><div class="line"></div><div class="line">typedef struct redisDb &#123;</div><div class="line">    //正处于阻塞状态的键</div><div class="line">    dict *blocking_keys;        /* Keys with clients waiting for data (BLPOP) */</div><div class="line">    //可以解除阻塞的键</div><div class="line">    dict *ready_keys;           /* Blocked keys that received a PUSH */</div><div class="line">&#125; redisDb;</div></pre></td></tr></table></figure>
<p>redisDb里边利用了一个名为blocking_keys的dict来存储每个阻塞的键，以及等待该键的客户端的对应关系。</p>
<p>做完这些之后，这个客户端就被阻塞了。 那么这个客户端如何从阻塞状态重新回复到非阻塞状态呢。 一个当时是等待的时间超过了timeout的时间，从阻塞状态恢复； 另一个则是其他的客户端往这个列表中插入了数据，正好是当前阻塞的客户端所需要的，当前客户端收到信号之后，从阻塞状态中恢复。</p>
<p>根据我的理解， 如果是客户端超时被解阻塞，调用的是这个函数：</p>
<h4 id="超时解阻塞"><a href="#超时解阻塞" class="headerlink" title="超时解阻塞"></a>超时解阻塞</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">//解阻塞一个正在阻塞中的client</div><div class="line">void unblockClientWaitingData(client *c) &#123;</div><div class="line">    dictEntry *de;</div><div class="line">    dictIterator *di;</div><div class="line">    list *l;</div><div class="line"></div><div class="line">    serverAssertWithInfo(c,NULL,dictSize(c-&gt;bpop.keys) != 0);</div><div class="line">    //创建一个字典的迭代器，指向的是造成client阻塞的键所组成的字典</div><div class="line">    di = dictGetIterator(c-&gt;bpop.keys);</div><div class="line">    /* The client may wait for multiple keys, so unblock it for every key. */</div><div class="line">    //因为client可能被多个key所阻塞，所以要遍历所有的键</div><div class="line">    while((de = dictNext(di)) != NULL) &#123;</div><div class="line">        robj *key = dictGetKey(de); //获得key对象</div><div class="line"></div><div class="line">        /* Remove this client from the list of clients waiting for this key. */</div><div class="line">        //根据key找到对应的列表类型值，值保存着被阻塞的client，从中找c-&gt;db-&gt;blocking_keys中寻找</div><div class="line">        l = dictFetchValue(c-&gt;db-&gt;blocking_keys,key);</div><div class="line">        serverAssertWithInfo(c,key,l != NULL);</div><div class="line">        // 将阻塞的client从列表中移除</div><div class="line">        listDelNode(l,listSearchKey(l,c));</div><div class="line">        /* If the list is empty we need to remove it to avoid wasting memory */</div><div class="line">        //如果当前列表为空了，则从c-&gt;db-&gt;blocking_keys中将key删除</div><div class="line">        if (listLength(l) == 0)</div><div class="line">            dictDelete(c-&gt;db-&gt;blocking_keys,key);</div><div class="line">    &#125;</div><div class="line">    dictReleaseIterator(di);    //释放迭代器</div><div class="line"></div><div class="line">    /* Cleanup the client structure */</div><div class="line">    //清空bpop.keys的所有节点</div><div class="line">    dictEmpty(c-&gt;bpop.keys,NULL);</div><div class="line">    //如果保存有新添加的元素，则应该释放</div><div class="line">    if (c-&gt;bpop.target) &#123;</div><div class="line">        decrRefCount(c-&gt;bpop.target);</div><div class="line">        c-&gt;bpop.target = NULL;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果是其他的客户端插入了一个数据，则是调用下边的函数：</p>
<h4 id="插入解阻塞"><a href="#插入解阻塞" class="headerlink" title="插入解阻塞"></a>插入解阻塞</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">// 如果客户端因为等待某个 key 被阻塞，那么将此key加入到server.ready_keys中</div><div class="line">// 这个列表最终会被 handleClientsBlockedOnLists() 函数处理。</div><div class="line">void signalListAsReady(redisDb *db, robj *key) &#123;</div><div class="line">    readyList *rl;</div><div class="line">    // 如果在所有造成客户端阻塞的键中找不到此键，则不作处理</div><div class="line">    if (dictFind(db-&gt;blocking_keys,key) == NULL) return;</div><div class="line">    // 这个键已经存在于ready_keys中了，则不作处理</div><div class="line">    if (dictFind(db-&gt;ready_keys,key) != NULL) return;</div><div class="line">    </div><div class="line">    // 创建一个新的readylists结构，保存键和数据库</div><div class="line">    // 然后将该结构添加到server.ready_keys中</div><div class="line">    rl = zmalloc(sizeof(*rl));</div><div class="line">    rl-&gt;key = key;</div><div class="line">    rl-&gt;db = db;</div><div class="line">    // 该键的索引加1</div><div class="line">    incrRefCount(key);</div><div class="line">    listAddNodeTail(server.ready_keys,rl);</div><div class="line">    // 同样，将key添加到db-&gt;ready_keys中</div><div class="line">    incrRefCount(key);</div><div class="line">    serverAssert(dictAdd(db-&gt;ready_keys,key,NULL) == DICT_OK);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在将所有可用的key加入到ready_keys之后，会有统一的函数去检查哪些客户端等待着这些key，然后将他们解阻塞</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div></pre></td><td class="code"><pre><div class="line">/* 遍历server.ready_keys中所有已经准备好的key，同时在c-&gt;db-&gt;blocking_keys中</div><div class="line"> 遍历所有由此键造成阻塞的客户端，如果key不为空的话，就从key中弹出一个元素返回给客户端并解除该客户端的阻塞状态，直到server.ready_keys为空，或没有因该key而阻塞的客户端为止 */</div><div class="line">/* This function should be called by Redis every time a single command,</div><div class="line"> * a MULTI/EXEC block, or a Lua script, terminated its execution after</div><div class="line"> * being called by a client.</div><div class="line"> *</div><div class="line"> * All the keys with at least one client blocked that received at least</div><div class="line"> * one new element via some PUSH operation are accumulated into</div><div class="line"> * the server.ready_keys list. This function will run the list and will</div><div class="line"> * serve clients accordingly. Note that the function will iterate again and</div><div class="line"> * again as a result of serving BRPOPLPUSH we can have new blocking clients</div><div class="line"> * to serve because of the PUSH side of BRPOPLPUSH. */</div><div class="line">void handleClientsBlockedOnLists(void) &#123;</div><div class="line">    while(listLength(server.ready_keys) != 0) &#123;</div><div class="line">        list *l;</div><div class="line"></div><div class="line">        /* Point server.ready_keys to a fresh list and save the current one</div><div class="line">         * locally. This way as we run the old list we are free to call</div><div class="line">         * signalListAsReady() that may push new elements in server.ready_keys</div><div class="line">         * when handling clients blocked into BRPOPLPUSH. */</div><div class="line">        l = server.ready_keys;</div><div class="line">        server.ready_keys = listCreate();</div><div class="line"></div><div class="line">        while(listLength(l) != 0) &#123;</div><div class="line">            listNode *ln = listFirst(l);</div><div class="line">            readyList *rl = ln-&gt;value;</div><div class="line"></div><div class="line">            /* First of all remove this key from db-&gt;ready_keys so that</div><div class="line">             * we can safely call signalListAsReady() against this key. */</div><div class="line">            dictDelete(rl-&gt;db-&gt;ready_keys,rl-&gt;key);</div><div class="line"></div><div class="line">            /* If the key exists and it&apos;s a list, serve blocked clients</div><div class="line">             * with data. */</div><div class="line">            robj *o = lookupKeyWrite(rl-&gt;db,rl-&gt;key);</div><div class="line">            if (o != NULL &amp;&amp; o-&gt;type == OBJ_LIST) &#123;</div><div class="line">                dictEntry *de;</div><div class="line"></div><div class="line">                /* We serve clients in the same order they blocked for</div><div class="line">                 * this key, from the first blocked to the last. */</div><div class="line">                de = dictFind(rl-&gt;db-&gt;blocking_keys,rl-&gt;key);</div><div class="line">                if (de) &#123;</div><div class="line">                    list *clients = dictGetVal(de);</div><div class="line">                    int numclients = listLength(clients);</div><div class="line"></div><div class="line">                    while(numclients--) &#123;</div><div class="line">                        listNode *clientnode = listFirst(clients);</div><div class="line">                        client *receiver = clientnode-&gt;value;</div><div class="line">                        robj *dstkey = receiver-&gt;bpop.target;</div><div class="line">                        int where = (receiver-&gt;lastcmd &amp;&amp;</div><div class="line">                                     receiver-&gt;lastcmd-&gt;proc == blpopCommand) ?</div><div class="line">                                    LIST_HEAD : LIST_TAIL;</div><div class="line">                        robj *value = listTypePop(o,where);</div><div class="line"></div><div class="line">                        if (value) &#123;</div><div class="line">                            /* Protect receiver-&gt;bpop.target, that will be</div><div class="line">                             * freed by the next unblockClient()</div><div class="line">                             * call. */</div><div class="line">                            if (dstkey) incrRefCount(dstkey);</div><div class="line">                            unblockClient(receiver);</div><div class="line"></div><div class="line">                            if (serveClientBlockedOnList(receiver,</div><div class="line">                                rl-&gt;key,dstkey,rl-&gt;db,value,</div><div class="line">                                where) == C_ERR)</div><div class="line">                            &#123;</div><div class="line">                                /* If we failed serving the client we need</div><div class="line">                                 * to also undo the POP operation. */</div><div class="line">                                    listTypePush(o,value,where);</div><div class="line">                            &#125;</div><div class="line"></div><div class="line">                            if (dstkey) decrRefCount(dstkey);</div><div class="line">                            decrRefCount(value);</div><div class="line">                        &#125; else &#123;</div><div class="line">                            break;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                if (listTypeLength(o) == 0) &#123;</div><div class="line">                    dbDelete(rl-&gt;db,rl-&gt;key);</div><div class="line">                &#125;</div><div class="line">                /* We don&apos;t call signalModifiedKey() as it was already called</div><div class="line">                 * when an element was pushed on the list. */</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            /* Free this item. */</div><div class="line">            decrRefCount(rl-&gt;key);</div><div class="line">            zfree(rl);</div><div class="line">            listDelNode(l,ln);</div><div class="line">        &#125;</div><div class="line">        listRelease(l); /* We have the new list on place at this point. */</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://harleylau.github.io/2018/05/10/Redis源码剖析-列表t-list实现/" data-id="cji4caxlm0005ik683qqkocri" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/">redis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码/">源码</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Redis源码剖析-字符串t-string实现" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/09/Redis源码剖析-字符串t-string实现/" class="article-date">
  <time datetime="2018-05-09T02:12:07.000Z" itemprop="datePublished">2018-05-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/09/Redis源码剖析-字符串t-string实现/">Redis源码剖析--字符串t_string实现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>介绍完Redis的底层数据结构之后， 介绍我们平时使用Redis的时候可以直接看到五种数据结构：字符串、哈希、链表、集合和有序集合。</p>
<p>首先介绍字符串t_string的实现。</p>
<h2 id="字符串的结构"><a href="#字符串的结构" class="headerlink" title="字符串的结构"></a>字符串的结构</h2><p>上一篇文章讲到过字符串的底层实现其实有三种编码：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>编码</th>
<th>对象</th>
</tr>
</thead>
<tbody>
<tr>
<td>REDIS_STRING</td>
<td>REDIS_ENCODING_INT</td>
<td>使用整数值实现的字符串对象。</td>
</tr>
<tr>
<td>REDIS_STRING</td>
<td>REDIS_ENCODING_EMBSTR</td>
<td>使用 embstr 编码的简单动态字符串实现的字符串对象。</td>
</tr>
<tr>
<td>REDIS_STRING</td>
<td>REDIS_ENCODING_RAW</td>
<td>使用简单动态字符串实现的字符串对象。</td>
</tr>
</tbody>
</table>
<p>这三种类型分别对应的底层数据结构为int，embstr, sds。</p>
<p>字符串的定义代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">typedef struct redisObject &#123;</div><div class="line">    //对象的数据类型，字符串对象应该为 OBJ_STRING</div><div class="line">    unsigned type:4;        </div><div class="line">    //对象的编码类型，分别为OBJ_STRING、OBJ_ENCODING_INT或OBJ_ENCODING_EMBSTR</div><div class="line">    unsigned encoding:4;</div><div class="line">    //LRU_BITS为24位，最近一次的访问时间</div><div class="line">    unsigned lru:LRU_BITS; /* lru time (relative to server.lruclock) */</div><div class="line">    //引用计数</div><div class="line">    int refcount;</div><div class="line">    //指向底层数据实现的指针</div><div class="line">    void *ptr;</div><div class="line">&#125; robj;</div></pre></td></tr></table></figure>
<p>那么字符串具体用哪种编码实现呢？</p>
<p>如果一个字符串对象保存的是整数值， 并且这个整数值可以用 long 类型来表示， 那么字符串对象会将整数值保存在字符串对象结构的 ptr 属性里面（将 void* 转换成 long ）， 并将字符串对象的编码设置为 int 。</p>
<p>如果字符串对象保存的是一个字符串值， 并且这个字符串值的长度大于 39 字节， 那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值， 并将对象的编码设置为 raw 。</p>
<p>如果字符串对象保存的是一个字符串值， 并且这个字符串值的长度小于等于 39 字节， 那么字符串对象将使用 embstr 编码的方式来保存这个字符串值。</p>
<p>embstr 编码是专门用于保存短字符串的一种优化编码方式， 这种编码和 raw 编码一样， 都使用 redisObject 结构和 sdshdr 结构来表示字符串对象， 但 raw 编码会调用两次内存分配函数来分别创建 redisObject 结构和 sdshdr 结构， 而 embstr 编码则通过调用一次内存分配函数来分配一块连续的空间， 空间中依次包含 redisObject 和 sdshdr 两个结构</p>
<p>这边采用int和embstr编码的原因是：相较于raw格式的2次分配内存， 这两种格式只需要一次分配内存空间就可以；并且在回收的时候，也只需要调用一次内存释放函数。在存储小的字符串的时候更有速度优势。</p>
<h2 id="字符串命令"><a href="#字符串命令" class="headerlink" title="字符串命令"></a>字符串命令</h2><p>字符串支持的命令如下：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>命令描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>SET key value [ex 秒数][px 毫秒数][nx/xx]</td>
<td>设置指定key的值</td>
</tr>
<tr>
<td>GET key</td>
<td>获取指定key的值</td>
</tr>
<tr>
<td>APPEND key value</td>
<td>将value追加到指定key的值末尾</td>
</tr>
<tr>
<td>INCRBY key increment</td>
<td>将指定key的值加上增量increment</td>
</tr>
<tr>
<td>DECRBY key decrement</td>
<td>将指定key的值减去增量decrement</td>
</tr>
<tr>
<td>STRLEN key</td>
<td>返回指定key的值长度</td>
</tr>
<tr>
<td>SETRANGE key offset value</td>
<td>将value覆写到指定key的值上，从offset位开始</td>
</tr>
<tr>
<td>GETRANGE key start end</td>
<td>获取指定key中字符串的子串[start,end]</td>
</tr>
<tr>
<td>MSET key value [key value …]</td>
<td>一次设定多个key的值</td>
</tr>
<tr>
<td>MGET key1 [key2..]</td>
<td>一次获取多个key的值</td>
</tr>
</tbody>
</table>
<h2 id="字符串命令实现"><a href="#字符串命令实现" class="headerlink" title="字符串命令实现"></a>字符串命令实现</h2><h3 id="set命令的实现"><a href="#set命令的实现" class="headerlink" title="set命令的实现"></a>set命令的实现</h3><p>set命令用于设置指定的值，其具体命令格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">set key value [ex 秒数] [px 毫秒数] [nx/xx]</div></pre></td></tr></table></figure>
<p>其中，各个选项的含义如下：</p>
<ul>
<li>ex 设置指定的到期时间，单位为秒</li>
<li>px 设置指定的到期时间，单位为毫秒</li>
<li>nx 只有在key不存在的时候，才设置key的值</li>
<li>xx 只有key存在时，才对key进行设置操作</li>
</ul>
<p>set命令是调用setCommand实现的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">// 关于set命令的操作有三种宏定义</div><div class="line">#define OBJ_SET_NO_FLAGS 0    // 没有设定参数</div><div class="line">#define OBJ_SET_NX (1&lt;&lt;0)     // 只有键不存在时才设定其值</div><div class="line">#define OBJ_SET_XX (1&lt;&lt;1)      // 只有键存在时才设定其值</div><div class="line">#define OBJ_SET_EX (1&lt;&lt;2)       // ex属性，到期时间单位为秒</div><div class="line">#define OBJ_SET_PX (1&lt;&lt;3)     	// px属性，到期时间单位为毫秒</div><div class="line"></div><div class="line">/* set命令实现函数 */</div><div class="line">void setCommand(client *c) &#123;</div><div class="line">    int j;</div><div class="line">    robj *expire = NULL;</div><div class="line">    int unit = UNIT_SECONDS;</div><div class="line">  	// 用于标记ex/px和nx/xx命令参数</div><div class="line">    int flags = OBJ_SET_NO_FLAGS;</div><div class="line">	// 从命令串的第四个参数开始，查看其是否设定了ex/px和nx/xx</div><div class="line">    for (j = 3; j &lt; c-&gt;argc; j++) &#123;</div><div class="line">        char *a = c-&gt;argv[j]-&gt;ptr;</div><div class="line">        robj *next = (j == c-&gt;argc-1) ? NULL : c-&gt;argv[j+1];</div><div class="line">        if ((a[0] == &apos;n&apos; || a[0] == &apos;N&apos;) &amp;&amp;</div><div class="line">            (a[1] == &apos;x&apos; || a[1] == &apos;X&apos;) &amp;&amp; a[2] == &apos;\0&apos; &amp;&amp;</div><div class="line">            !(flags &amp; OBJ_SET_XX)) // 标记</div><div class="line">        &#123;</div><div class="line">            flags |= OBJ_SET_NX;</div><div class="line">        &#125; else if ((a[0] == &apos;x&apos; || a[0] == &apos;X&apos;) &amp;&amp;</div><div class="line">                   (a[1] == &apos;x&apos; || a[1] == &apos;X&apos;) &amp;&amp; a[2] == &apos;\0&apos; &amp;&amp;</div><div class="line">                   !(flags &amp; OBJ_SET_NX))</div><div class="line">        &#123;</div><div class="line">            flags |= OBJ_SET_XX;</div><div class="line">        &#125; else if ((a[0] == &apos;e&apos; || a[0] == &apos;E&apos;) &amp;&amp;</div><div class="line">                   (a[1] == &apos;x&apos; || a[1] == &apos;X&apos;) &amp;&amp; a[2] == &apos;\0&apos; &amp;&amp;</div><div class="line">                   !(flags &amp; OBJ_SET_PX) &amp;&amp; next)</div><div class="line">        &#123;</div><div class="line">            flags |= OBJ_SET_EX;</div><div class="line">            unit = UNIT_SECONDS;</div><div class="line">            expire = next;</div><div class="line">            j++;</div><div class="line">        &#125; else if ((a[0] == &apos;p&apos; || a[0] == &apos;P&apos;) &amp;&amp;</div><div class="line">                   (a[1] == &apos;x&apos; || a[1] == &apos;X&apos;) &amp;&amp; a[2] == &apos;\0&apos; &amp;&amp;</div><div class="line">                   !(flags &amp; OBJ_SET_EX) &amp;&amp; next)</div><div class="line">        &#123;</div><div class="line">            flags |= OBJ_SET_PX;</div><div class="line">            unit = UNIT_MILLISECONDS;</div><div class="line">            expire = next;</div><div class="line">            j++;</div><div class="line">        &#125; else &#123;</div><div class="line">          	// 如果不是上述参数，则需要报错，命令错误</div><div class="line">            addReply(c,shared.syntaxerr);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    // 判断value是否可以编码成整数，如果能则编码；反之不做处理</div><div class="line">    c-&gt;argv[2] = tryObjectEncoding(c-&gt;argv[2]);</div><div class="line">    // 调用底层函数进行键值对设定</div><div class="line">    setGenericCommand(c,flags,c-&gt;argv[1],c-&gt;argv[2],expire,unit,NULL,NULL);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>函数的一开始先检查传入的参数，看是否设定了过期时间以及过期时间的精度等，然后设置对应的flag， 最后根据flag调用setGenericCommand实现具体的操作。</p>
<p>接下去看一下setGenericCommand函数的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">//setGenericCommand()函数是以下命令: SET, SETEX, PSETEX, SETNX.的最底层实现</div><div class="line">//flags 可以是NX或XX，由上面的宏提供</div><div class="line">//expire 定义key的过期时间，格式由unit指定</div><div class="line">//ok_reply和abort_reply保存着回复client的内容，NX和XX也会改变回复</div><div class="line">//如果ok_reply为空，则使用 &quot;+OK&quot;</div><div class="line">//如果abort_reply为空，则使用 &quot;$-1&quot;</div><div class="line">void setGenericCommand(client *c, int flags, robj *key, robj *val, robj *expire, int unit, robj *ok_reply, robj *abort_reply) &#123;</div><div class="line">    long long milliseconds = 0; /* initialized to avoid any harmness warning */ //初始化，避免错误</div><div class="line"></div><div class="line">    //如果定义了key的过期时间</div><div class="line">    if (expire) &#123;</div><div class="line">        //从expire对象中取出值，保存在milliseconds中，如果出错发送默认的信息给client</div><div class="line">        if (getLongLongFromObjectOrReply(c, expire, &amp;milliseconds, NULL) != C_OK)</div><div class="line">            return;</div><div class="line">        // 如果过期时间小于等于0，则发送错误信息给client</div><div class="line">        if (milliseconds &lt;= 0) &#123;</div><div class="line">            addReplyErrorFormat(c,&quot;invalid expire time in %s&quot;,c-&gt;cmd-&gt;name);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        //如果unit的单位是秒，则需要转换为毫秒保存</div><div class="line">        if (unit == UNIT_SECONDS) milliseconds *= 1000;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //lookupKeyWrite函数是为执行写操作而取出key的值对象</div><div class="line">    //如果设置了NX(不存在)，并且在数据库中 找到 该key，或者</div><div class="line">    //设置了XX(存在)，并且在数据库中 没有找到 该key</div><div class="line">    //回复abort_reply给client</div><div class="line">    if ((flags &amp; OBJ_SET_NX &amp;&amp; lookupKeyWrite(c-&gt;db,key) != NULL) ||</div><div class="line">        (flags &amp; OBJ_SET_XX &amp;&amp; lookupKeyWrite(c-&gt;db,key) == NULL))</div><div class="line">    &#123;</div><div class="line">        addReply(c, abort_reply ? abort_reply : shared.nullbulk);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    //在当前db设置键为key的值为val</div><div class="line">    setKey(c-&gt;db,key,val);</div><div class="line"></div><div class="line">    //设置数据库为脏(dirty)，服务器每次修改一个key后，都会对脏键(dirty)增1</div><div class="line">    server.dirty++;</div><div class="line"></div><div class="line">    //设置key的过期时间</div><div class="line">    //mstime()返回毫秒为单位的格林威治时间</div><div class="line">    if (expire) setExpire(c-&gt;db,key,mstime()+milliseconds);</div><div class="line"></div><div class="line">    //发送&quot;set&quot;事件的通知，用于发布订阅模式，通知客户端接受发生的事件</div><div class="line">    notifyKeyspaceEvent(NOTIFY_STRING,&quot;set&quot;,key,c-&gt;db-&gt;id);</div><div class="line"></div><div class="line">    //发送&quot;expire&quot;事件通知</div><div class="line">    if (expire) notifyKeyspaceEvent(NOTIFY_GENERIC,</div><div class="line">        &quot;expire&quot;,key,c-&gt;db-&gt;id);</div><div class="line"></div><div class="line">    //设置成功，则向客户端发送ok_reply</div><div class="line">    addReply(c, ok_reply ? ok_reply : shared.ok);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="get命令的实现"><a href="#get命令的实现" class="headerlink" title="get命令的实现"></a>get命令的实现</h3><p>类似于set命令，get命令也是最终调用一个getGenericcommand的函数实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">//GET 命令的底层实现</div><div class="line">int getGenericCommand(client *c) &#123;</div><div class="line">    robj *o;</div><div class="line"></div><div class="line">    //lookupKeyReadOrReply函数是为执行读操作而返回key的值对象，找到返回该对象，找不到会发送信息给client</div><div class="line">    //如果key不存在直接，返回0表示GET命令执行成功</div><div class="line">    if ((o = lookupKeyReadOrReply(c,c-&gt;argv[1],shared.nullbulk)) == NULL)</div><div class="line">        return C_OK;</div><div class="line"></div><div class="line">    //如果key的值的编码类型不是字符串对象</div><div class="line">    if (o-&gt;type != OBJ_STRING) &#123;</div><div class="line">        addReply(c,shared.wrongtypeerr);    //返回类型错误的信息给client，返回-1表示GET命令执行失败</div><div class="line">        return C_ERR;</div><div class="line">    &#125; else &#123;</div><div class="line">        addReplyBulk(c,o);  //返回之前找到的对象作为回复给client，返回0表示GET命令执行成功</div><div class="line">        return C_OK;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="编码的转换"><a href="#编码的转换" class="headerlink" title="编码的转换"></a>编码的转换</h2><p>上边说到字符串类型底层其实有三种数据类型，这三种数据类型在特定的情况下也会互相转换。</p>
<h3 id="int编码转换为raw编码"><a href="#int编码转换为raw编码" class="headerlink" title="int编码转换为raw编码"></a>int编码转换为raw编码</h3><p>对于 int 编码的字符串对象来说， 如果我们向对象执行了一些命令， 使得这个对象保存的不再是整数值， 而是一个字符串值， 比如在最开始的数字类型后边执行了一个append的操作，加上了一串字符串，那么字符串对象的编码将从 int 变为 raw 。</p>
<h3 id="embstr编码转换为raw编码"><a href="#embstr编码转换为raw编码" class="headerlink" title="embstr编码转换为raw编码"></a>embstr编码转换为raw编码</h3><p>因为 Redis 没有为 embstr 编码的字符串对象编写任何相应的修改程序 （只有 int 编码的字符串对象和 raw 编码的字符串对象有这些程序）， 所以 embstr 编码的字符串对象实际上是只读的： 当我们对 embstr 编码的字符串对象执行任何修改命令时， 程序会先将对象的编码从 embstr 转换成 raw ， 然后再执行修改命令； 因为这个原因， embstr 编码的字符串对象在执行修改命令之后， 总会变成一个 raw 编码的字符串对象。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://harleylau.github.io/2018/05/09/Redis源码剖析-字符串t-string实现/" data-id="cji4caxmw000nik683x23oe1w" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/">redis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码/">源码</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-tornado-websocket实现二维码扫描" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/12/tornado-websocket实现二维码扫描/" class="article-date">
  <time datetime="2018-02-12T04:17:11.000Z" itemprop="datePublished">2018-02-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/12/tornado-websocket实现二维码扫描/">tornado websocket实现二维码扫描</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Websocket-实现扫码二维码登录"><a href="#Websocket-实现扫码二维码登录" class="headerlink" title="Websocket 实现扫码二维码登录"></a>Websocket 实现扫码二维码登录</h2><p>首先简单的讲一下二维码实现登录的步骤：<br>1、网页端向服务端请求二维码，服务端生成一个二维码提供给网页端； 这个二维码其实是一个地址<br>2、客户端通过扫描网页端的二维码，跳转到二维码指向的地址， 然后通过鉴权验证机制，通知服务端鉴权的结果<br>3、客户端端根据不同的鉴权结果通知网页端做出相应的动作</p>
<p>对于步骤有了简单的概念之后， 我们可以显而易见的看到整个流程中主要需要解决的主要是两个问题：</p>
<p>1、如果处理用户的授权机制，保证用户权限的安全性</p>
<p>2、如何让网页端根据用户在客户端上的选择及时的做出不同的响应</p>
<p>针对第一个问题， 一方面，我们在生成二维码的时候，会同时生成一个唯一的session_id的标志，然后将其加入到二维码的url中， 当客户端扫描二维码跳转到指定地址的时候，能够根据session_id保证这个二维码是我们自己生成的； 另一方面， 客户端跳转过来的时候，会同时带上用户的id和用户的token， 通过id和token的验证保证用户的有效性，同时也能讲对应的session_id和用户id绑定，通知网页端是哪个用户扫描了这个二维码。</p>
<p>另外，多讲一点， 客户端扫描的同时带上来的用户id和用户的token，在实际使用的时候，我们是用户在登录的时候通过OAuth2.0的鉴权逻辑获取的， 所以能直接通过token验证安全性。</p>
<p>那么第二个问题， 如何及时的通知网页端做出变化呢。 这边一开始有两个方案： 一个是网页端采用轮询的机制，间隔一小段时间来询问服务端， 是否有用户扫描了这个二维码，以及扫描的结果； 另一个方案就是网页端在请求二维码的时候发起的就是一个websocket请求，这样网页端和服务端就能一直保持连接， 在客户端扫描二维码之后， 服务端就能够及时的通知到网页端，做到实时化。</p>
<p>两者的优缺点相信也比较明显， 在实际的开发过程中，我们采用了websocket的方式。 这边其实还有一个问题， 用户在客户端扫描二维码并授权了之后，如果通知到对应的网页端呢。 在网页端请求二维码的同时，我们会将当前的请求以session_id为key的方式进行注册， 当客户端扫描或者授权的时候，会将这个session_id带上来， 根据这个session_id就可以取到对应的请求，然后发回操作结果给网页端。</p>
<h2 id="tornado-websocket实现二维码扫描登录"><a href="#tornado-websocket实现二维码扫描登录" class="headerlink" title="tornado websocket实现二维码扫描登录"></a>tornado websocket实现二维码扫描登录</h2><h3 id="网页端请求二维码"><a href="#网页端请求二维码" class="headerlink" title="网页端请求二维码"></a>网页端请求二维码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">@router.Route(&apos;qrcode&apos;, name=&apos;ConnectQRcode&apos;)</div><div class="line">class ConnectQRcode(tornado.websocket.WebSocketHandler):</div><div class="line">    @tornado.gen.coroutine</div><div class="line">    def open(self):</div><div class="line">    	 #生成唯一的id，并带在url中</div><div class="line">        req_id = id(self)</div><div class="line">        url = &quot;https://xxxxxxx?uid=&quot; + uid + &quot;&amp;req_id=&quot; + str(req_id)</div><div class="line">        # 根据URL生成对应的二维码</div><div class="line">        q = qrcode.main.QRCode()</div><div class="line">        q.add_data(url)</div><div class="line">        q.make()</div><div class="line">        m = q.make_image()</div><div class="line">        png_name = &quot;static/&quot; + uid + &quot;.png&quot;</div><div class="line">        m.save(png_name)</div><div class="line">        # 注册回调函数</div><div class="line">        self.application.cart.register(req_id, self.callback)</div><div class="line">        # 返回二维码</div><div class="line">        self.write_message(&quot;https://xxxx/&quot; + png_name)</div><div class="line"></div><div class="line"></div><div class="line">    def on_close(self):</div><div class="line">    	# 关闭的时候删除掉注册的回调函数</div><div class="line">        self.application.cart.unregister(id(self), self.callback)</div><div class="line">        logging.info(&quot;remove register&quot;)</div><div class="line">        logging.info(&apos;WebSocket closed&apos;)</div><div class="line"></div><div class="line">    def callback(self, event, extra_info):</div><div class="line">        # 回调函数具体的操作</div><div class="line">        self.write_message(xxxx)</div></pre></td></tr></table></figure>
<h3 id="客户端扫描二维码"><a href="#客户端扫描二维码" class="headerlink" title="客户端扫描二维码"></a>客户端扫描二维码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@router.Route(&apos;/qrscan&apos;, name=&apos;qrscan&apos;)</div><div class="line">class ConnectQRscan(tornado.web.RequestHandler):</div><div class="line">    @tornado.gen.coroutine</div><div class="line">    def get(self):</div><div class="line">        try:</div><div class="line">            # 得到本次请求的req_id， 然后根据req_id调用对应的回调函数</div><div class="line">            req_id = self.get_argument(&apos;req_id&apos;, strip=False)</div><div class="line">            self.application.cart.notify(req_id, &quot;scan&quot;, &#123;&apos;req_id&apos;: req_id&#125;)</div><div class="line">            ret = &#123;&#125;</div><div class="line">        except Exception as e:</div><div class="line">            logging.error(&quot;qrscan error: %s&quot; % e)</div><div class="line">            ret = &#123;&apos;errorno&apos;: -1, &apos;errormsg&apos;: &quot;Error&quot;, &apos;data&apos;: None&#125;</div><div class="line">        self.write(ret)</div></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://harleylau.github.io/2018/02/12/tornado-websocket实现二维码扫描/" data-id="cji4caxnk0016ik683jecbzw2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/tornado/">tornado</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/websocket/">websocket</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/二维码/">二维码</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-tornado之WebSocket" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/12/tornado之WebSocket/" class="article-date">
  <time datetime="2018-02-12T03:29:39.000Z" itemprop="datePublished">2018-02-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/12/tornado之WebSocket/">tornado之WebSocket</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><p>WebSocket是HTML5开始提供的一种浏览器与服务器间进行全双工通讯的网络技术。 WebSocket通信协议于2011年被IETF定为标准RFC 6455，WebSocketAPI被W3C定为标准。 在WebSocket API中，浏览器和服务器只需要要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。</p>
<p>WebSocket是建立在 TCP 协议之上，与 HTTP 协议有着良好的兼容性。那么既然已经有了HTTP协议，为什么还需要一个WebSocket协议呢。这是因为HTTP只允许由客户端向服务端发送数据， 而无法直接由服务端主动向客户端推送信息。</p>
<p>WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端直接向客户端推送数据而不需要客户端进行请求，两者之间可以创建持久性的连接，并允许数据进行双向传送。WebSocket协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。</p>
<h3 id="1-Tornado的WebSocket模块"><a href="#1-Tornado的WebSocket模块" class="headerlink" title="1. Tornado的WebSocket模块"></a>1. Tornado的WebSocket模块</h3><p>Tornado提供支持WebSocket的模块是tornado.websocket，其中提供了一个WebSocketHandler类用来处理通讯。</p>
<p>WebSocketHandler.open()<br>当一个WebSocket连接建立后被调用。</p>
<p>WebSocketHandler.on_message(message)<br>当客户端发送消息message过来时被调用，注意此方法必须被重写。</p>
<p>WebSocketHandler.on_close()<br>当WebSocket连接关闭后被调用。</p>
<p>WebSocketHandler.write_message(message, binary=False)<br>向客户端发送消息messagea，message可以是字符串或字典（字典会被转为json字符串）。若binary为False，则message以utf8编码发送；二进制模式（binary=True）时，可发送任何字节码。</p>
<p>WebSocketHandler.close()<br>关闭WebSocket连接。</p>
<p>WebSocketHandler.check_origin(origin)<br>判断源origin，对于符合条件（返回判断结果为True）的请求源origin允许其连接，否则返回403。可以重写此方法来解决WebSocket的跨域请求（如始终return True）。</p>
<h3 id="2-WebSocket使用示例"><a href="#2-WebSocket使用示例" class="headerlink" title="2. WebSocket使用示例"></a>2. WebSocket使用示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class WebSocketHandler(tornado.websocket.WebSocketHandler):</div><div class="line">    def open(self):</div><div class="line">        self.application.cart.register(self.callback)</div><div class="line"></div><div class="line">    def on_close(self):</div><div class="line">        self.application.cart.unregister(self.callback)</div><div class="line"></div><div class="line">    def on_message(self):</div><div class="line">        pass</div><div class="line"></div><div class="line">    def callback(self,count):</div><div class="line">        self.write_message(&apos;&#123;&quot;count&quot;:&quot;%s&quot;&#125;&apos;%count)</div></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://harleylau.github.io/2018/02/12/tornado之WebSocket/" data-id="cji4caxnp001bik68h59f1rcf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/tornado/">tornado</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Redis源码剖析-字符串对象" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/09/12/Redis源码剖析-字符串对象/" class="article-date">
  <time datetime="2017-09-12T01:58:09.000Z" itemprop="datePublished">2017-09-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/12/Redis源码剖析-字符串对象/">Redis源码剖析--字符串对象</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>上一篇文章里分析了，字符串对象在redis的底层结构上有三种存储格式，分别是： int 、 raw 或者 embstr</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>编码</th>
<th>对象</th>
</tr>
</thead>
<tbody>
<tr>
<td>REDIS_STRING</td>
<td>REDIS_ENCODING_INT</td>
<td>使用整数值实现的字符串对象。</td>
</tr>
<tr>
<td>REDIS_STRING</td>
<td>REDIS_ENCODING_EMBSTR</td>
<td>使用 embstr 编码的简单动态字符串实现的字符串对象。</td>
</tr>
<tr>
<td>REDIS_STRING</td>
<td>REDIS_ENCODING_RAW</td>
<td>使用简单动态字符串实现的字符串对象。</td>
</tr>
</tbody>
</table>
<p>那么这三种底层表示分别在什么情况下使用呢。</p>
<ul>
<li>如果一个字符串对象保存的是整数值， 并且这个整数值可以用 long 类型来表示， 那么字符串对象会将整数值保存在字符串对象结构的 ptr 属性里面， 并将字符串对象的编码设置为 REDIS_ENCODING_INT 。</li>
<li>如果字符串对象保存的是一个字符串值， 并且这个字符串值的长度大于 39 字节， 那么字符串对象将使用一个简单动态字符串（SDS，这个之前的文章也分析过）来保存这个字符串值， 并将对象的编码设置为 raw 。</li>
<li>如果字符串对象保存的是一个字符串值， 并且这个字符串值的长度小于等于 39 字节， 那么字符串对象将使用 embstr 编码的方式来保存这个字符串值。</li>
</ul>
<p>int的表示比较简单， raw的表示我们之前也分析过，这边多了一个embstr的方式，简单的分析一下。</p>
<p>正常的创建Redis的对象，一般都需要创建两次，一次创建RedisObject结构，另一次创建ptr指向的实际存储的内容。比如raw 编码， 使用 redisObject 结构和 sdshdr 结构来表示字符串对象， 但 raw 编码会调用两次内存分配函数来分别创建 redisObject 结构和 sdshdr 结构。但是在存储比较小的字符串的时候，这边用了个小技巧，embstr 编码通过调用一次内存分配函数来分配一块连续的空间， 空间中依次包含 redisObject 和 sdshdr 两个结构。</p>
<h2 id="编码的转换"><a href="#编码的转换" class="headerlink" title="编码的转换"></a>编码的转换</h2><p>int 和 embstr 在一定的条件下，会转化为 raw 格式的字符串。</p>
<p>此外， int 编码的字符串对象和 raw 编码的字符串对象都能够进行修改，但是 Redis 没有为 embstr 编码的字符串对象编写任何相应的修改程序 ， 所以 embstr 编码的字符串对象实际上是只读的。</p>
<p>当我们需要修改 embstr 编码的字符串， 程序会先将对象的编码从 embstr 转换成 raw ， 然后再执行修改命令； 所以 embstr 编码的字符串对象在执行修改命令之后， 总会变成一个 raw 编码的字符串对象。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>int 编码的实现方法</th>
<th>embstr 编码的实现方法</th>
<th>raw 编码的实现方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>SET</td>
<td>使用 int 编码保存值。</td>
<td>使用 embstr 编码保存值。</td>
<td>使用 raw 编码保存值。</td>
</tr>
<tr>
<td>GET</td>
<td>拷贝对象所保存的整数值， 将这个拷贝转换成字符串值， 然后向客户端返回这个字符串值。</td>
<td>直接向客户端返回字符串值。</td>
<td>直接向客户端返回字符串值。</td>
</tr>
<tr>
<td>APPEND</td>
<td>将对象转换成 raw 编码， 然后按 raw 编码的方式执行此操作。</td>
<td>将对象转换成 raw 编码， 然后按 raw 编码的方式执行此操作。</td>
<td>调用 sdscatlen 函数， 将给定字符串追加到现有字符串的末尾。</td>
</tr>
<tr>
<td>INCRBYFLOAT</td>
<td>取出整数值并将其转换成 long double 类型的浮点数， 对这个浮点数进行加法计算， 然后将得出的浮点数结果保存起来。</td>
<td>取出字符串值并尝试将其转换成 long double 类型的浮点数， 对这个浮点数进行加法计算， 然后将得出的浮点数结果保存起来。 如果字符串值不能被转换成浮点数， 那么向客户端返回一个错误。</td>
<td>取出字符串值并尝试将其转换成 long double 类型的浮点数， 对这个浮点数进行加法计算， 然后将得出的浮点数结果保存起来。 如果字符串值不能被转换成浮点数， 那么向客户端返回一个错误。</td>
</tr>
<tr>
<td>INCRBY</td>
<td>对整数值进行加法计算， 得出的计算结果会作为整数被保存起来。</td>
<td>embstr 编码不能执行此命令， 向客户端返回一个错误。</td>
<td>raw 编码不能执行此命令， 向客户端返回一个错误。</td>
</tr>
<tr>
<td>DECRBY</td>
<td>对整数值进行减法计算， 得出的计算结果会作为整数被保存起来。</td>
<td>embstr 编码不能执行此命令， 向客户端返回一个错误。</td>
<td>raw 编码不能执行此命令， 向客户端返回一个错误。</td>
</tr>
<tr>
<td>STRLEN</td>
<td>拷贝对象所保存的整数值， 将这个拷贝转换成字符串值， 计算并返回这个字符串值的长度。</td>
<td>调用 sdslen 函数， 返回字符串的长度。</td>
<td>调用 sdslen 函数， 返回字符串的长度。</td>
</tr>
<tr>
<td>SETRANGE</td>
<td>将对象转换成 raw 编码， 然后按 raw 编码的方式执行此命令。</td>
<td>将对象转换成 raw 编码， 然后按 raw 编码的方式执行此命令。</td>
<td>将字符串特定索引上的值设置为给定的字符。</td>
</tr>
<tr>
<td>GETRANGE</td>
<td>拷贝对象所保存的整数值， 将这个拷贝转换成字符串值， 然后取出并返回字符串指定索引上的字符。</td>
<td>直接取出并返回字符串指定索引上的字符。</td>
<td>直接取出并返回字符串指定索引上的字符。</td>
</tr>
</tbody>
</table>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://harleylau.github.io/2017/09/12/Redis源码剖析-字符串对象/" data-id="cji4caxn4000sik68dqudt4kl" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Redis源码剖析-对象Object" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/09/07/Redis源码剖析-对象Object/" class="article-date">
  <time datetime="2017-09-07T10:20:21.000Z" itemprop="datePublished">2017-09-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/07/Redis源码剖析-对象Object/">Redis源码剖析--对象Object</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>之前介绍的都是Redis的基础数据结构，比如简单动态字符串（SDS）、双端链表、字典、压缩列表、整数集合， 等等，不过Redis并没有直接用这些结构来实现键值对的数据库，而是对其进行了封装， 所有的键和值都是用对象Object来表示的。</p>
<p>Redis构建的对象分为5类， 字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象， 分别对应Redis操作中的string、list、hash、set和zset。</p>
<h2 id="对象的结构"><a href="#对象的结构" class="headerlink" title="对象的结构"></a>对象的结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">typedef struct redisObject &#123;</div><div class="line">    unsigned type:4;</div><div class="line">    unsigned encoding:4;</div><div class="line">    unsigned lru:LRU_BITS; // LRU_BITS为24</div><div class="line">    int refcount;</div><div class="line">    void *ptr;</div><div class="line">&#125; robj;</div></pre></td></tr></table></figure>
<p>type表示类型， encoding表示编码，prt表示指向底层数据实现的指针。</p>
<p>refcount用来实现基于引用计数技术的内存回收机制：通过引用计数技术实现了对象共享机制， 这一机制可以在适当的条件下， 通过让多个数据库键共享同一个对象来节约内存。</p>
<h3 id="类型type"><a href="#类型type" class="headerlink" title="类型type"></a>类型type</h3><p>上面说到Redis中有5中对象类型，对应的定义如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#define OBJ_STRING 0</div><div class="line">#define OBJ_LIST 1</div><div class="line">#define OBJ_SET 2</div><div class="line">#define OBJ_ZSET 3</div><div class="line">#define OBJ_HASH 4</div></pre></td></tr></table></figure>
<p>对于 Redis 数据库保存的键值对来说， 键总是一个字符串对象， 而值则可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象的其中一种。</p>
<h3 id="编码和底层实现"><a href="#编码和底层实现" class="headerlink" title="编码和底层实现"></a>编码和底层实现</h3><p>Redis对象的编码方式由encoding参数指定，也就是表示ptr指向的数据以何种数据结构作为底层实现。该字段也占用4个bit位。其取值和对应类型对应如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#define OBJ_ENCODING_RAW 0     /* Raw representation */</div><div class="line">#define OBJ_ENCODING_INT 1     /* Encoded as integer */</div><div class="line">#define OBJ_ENCODING_HT 2      /* Encoded as hash table */</div><div class="line">#define OBJ_ENCODING_ZIPMAP 3  /* Encoded as zipmap */</div><div class="line">#define OBJ_ENCODING_LINKEDLIST 4 /* Encoded as regular linked list */</div><div class="line">#define OBJ_ENCODING_ZIPLIST 5 /* Encoded as ziplist */</div><div class="line">#define OBJ_ENCODING_INTSET 6  /* Encoded as intset */</div><div class="line">#define OBJ_ENCODING_SKIPLIST 7  /* Encoded as skiplist */</div><div class="line">#define OBJ_ENCODING_EMBSTR 8  /* Embedded sds string encoding */</div><div class="line">#define OBJ_ENCODING_QUICKLIST 9 /* Encoded as linked list of ziplists */</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>编码常量</th>
<th>编码所对应的底层数据结构</th>
</tr>
</thead>
<tbody>
<tr>
<td>REDIS_ENCODING_INT</td>
<td>long 类型的整数</td>
</tr>
<tr>
<td>REDIS_ENCODING_EMBSTR</td>
<td>embstr 编码的简单动态字符串</td>
</tr>
<tr>
<td>REDIS_ENCODING_RAW</td>
<td>简单动态字符串</td>
</tr>
<tr>
<td>REDIS_ENCODING_HT</td>
<td>字典</td>
</tr>
<tr>
<td>REDIS_ENCODING_LINKEDLIST</td>
<td>双端链表</td>
</tr>
<tr>
<td>REDIS_ENCODING_ZIPLIST</td>
<td>压缩列表</td>
</tr>
<tr>
<td>REDIS_ENCODING_INTSET</td>
<td>整数集合</td>
</tr>
<tr>
<td>REDIS_ENCODING_SKIPLIST</td>
<td>跳跃表和字典</td>
</tr>
</tbody>
</table>
<p>Redis中的5中类型的对象，都对应着不止一种的底层实现</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>编码</th>
<th>对象</th>
</tr>
</thead>
<tbody>
<tr>
<td>REDIS_STRING</td>
<td>REDIS_ENCODING_INT</td>
<td>使用整数值实现的字符串对象。</td>
</tr>
<tr>
<td>REDIS_STRING</td>
<td>REDIS_ENCODING_EMBSTR</td>
<td>使用 embstr 编码的简单动态字符串实现的字符串对象。</td>
</tr>
<tr>
<td>REDIS_STRING</td>
<td>REDIS_ENCODING_RAW</td>
<td>使用简单动态字符串实现的字符串对象。</td>
</tr>
<tr>
<td>REDIS_LIST</td>
<td>REDIS_ENCODING_ZIPLIST</td>
<td>使用压缩列表实现的列表对象。</td>
</tr>
<tr>
<td>REDIS_LIST</td>
<td>REDIS_ENCODING_LINKEDLIST</td>
<td>使用双端链表实现的列表对象。</td>
</tr>
<tr>
<td>REDIS_HASH</td>
<td>REDIS_ENCODING_ZIPLIST</td>
<td>使用压缩列表实现的哈希对象。</td>
</tr>
<tr>
<td>REDIS_HASH</td>
<td>REDIS_ENCODING_HT</td>
<td>使用字典实现的哈希对象。</td>
</tr>
<tr>
<td>REDIS_SET</td>
<td>REDIS_ENCODING_INTSET</td>
<td>使用整数集合实现的集合对象。</td>
</tr>
<tr>
<td>REDIS_SET</td>
<td>REDIS_ENCODING_HT</td>
<td>使用字典实现的集合对象。</td>
</tr>
<tr>
<td>REDIS_ZSET</td>
<td>REDIS_ENCODING_ZIPLIST</td>
<td>使用压缩列表实现的有序集合对象。</td>
</tr>
<tr>
<td>REDIS_ZSET</td>
<td>REDIS_ENCODING_SKIPLIST</td>
<td>使用跳跃表和字典实现的有序集合对象。</td>
</tr>
</tbody>
</table>
<p>通过encoding参数来区分底层的实现，这样既灵活，也能节省内存。比如hash表的实现的时候，当元素比较少的时候，可以用压缩列表来实现；当元素不断增长，压缩列表失去优势的时候，就将其转化成hash table来实现。</p>
<p>之后几篇分别介绍 Redis 中的五种不同类型的对象， 说明这些对象底层所使用的编码方式。 由于每种对象类型都有不止一种底层结构，所以同时列出对象从一种编码转换成另一种编码所需的条件， 以及同一个命令在多种不同编码上的实现方法。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://harleylau.github.io/2017/09/07/Redis源码剖析-对象Object/" data-id="cji4caxne000yik686fg501ua" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/">redis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码/">源码</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-tornado-打印block日志" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/09/07/tornado-打印block日志/" class="article-date">
  <time datetime="2017-09-07T03:21:02.000Z" itemprop="datePublished">2017-09-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/07/tornado-打印block日志/">tornado--打印block日志</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Tornado在使用过程，碰到过性能瓶颈。 当碰到Tornado中有比较耗时的任务的时候，请求一多就会阻塞整个服务。这个时候就需要查看到底是什么任务阻塞了服务，然后针对性的进行优化。</p>
<p>Tornado使用logging打印日志，我们可以指定当某个请求的处理时间超过设定时间的时候，打印这个请求的stack trace。</p>
<p>源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">def set_blocking_log_threshold(self, seconds):</div><div class="line">       &quot;&quot;&quot;Logs a stack trace if the `IOLoop` is blocked for more than</div><div class="line">       ``s`` seconds.</div><div class="line"></div><div class="line">       Equivalent to ``set_blocking_signal_threshold(seconds,</div><div class="line">       self.log_stack)``</div><div class="line">       &quot;&quot;&quot;</div><div class="line">       self.set_blocking_signal_threshold(seconds, self.log_stack)</div></pre></td></tr></table></figure>
<p>如何使用呢，只需要在启动服务的时候设置block的时间即可，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line"></div><div class="line">    app = create_app()</div><div class="line"></div><div class="line">    server = tornado.httpserver.HTTPServer(app)</div><div class="line">    server.listen(options.port)</div><div class="line">    io_loop = tornado.ioloop.IOLoop.instance()</div><div class="line">    io_loop.set_blocking_log_threshold(0.5)</div><div class="line">    io_loop.start()</div></pre></td></tr></table></figure>
<p>如果某个请求的处理时间超过0.5秒，就会打印该请求的栈。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://harleylau.github.io/2017/09/07/tornado-打印block日志/" data-id="cji4caxo4001sik680wjl8bss" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/tornado/">tornado</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Redis源码剖析-压缩列表" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/09/05/Redis源码剖析-压缩列表/" class="article-date">
  <time datetime="2017-09-05T01:51:55.000Z" itemprop="datePublished">2017-09-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/05/Redis源码剖析-压缩列表/">Redis源码剖析--压缩列表</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>压缩列表（ziplist）是列表键和哈希键的底层实现之一。<br>Redis的列表键，哈希键，有序集合的底层实现都用到了ziplist。</p>
<p>当列表键中包含比较少的元素，并且元素都是数字或者比较小的字符串的时候， redis会用压缩列表来作为列表键的底层实现。</p>
<p>当哈希键的键和值都是比较小的整数或者较短的字符的时候，也是用压缩列表来作为底层实现。 因为压缩列表也能够节省内存。</p>
<h2 id="压缩列表结构"><a href="#压缩列表结构" class="headerlink" title="压缩列表结构"></a>压缩列表结构</h2><p>压缩列表的结构如下：</p>
<p><img src="/2017/09/05/Redis源码剖析-压缩列表/ziplist.png" alt="压缩列表结构"></p>
<p>列表头包括三部分内容，分别是zlbytes，zltail，zllen</p>
<ul>
<li>zlbytes： 记录整个压缩列表占用的内存字节数：在对压缩列表进行内存重分配， 或者计算 zlend 的位置时使用。</li>
<li>zltail：记录压缩列表表尾节点距离压缩列表的起始地址有多少字节： 通过这个偏移量，程序无须遍历整个压缩列表就可以确定表尾节点的地址。</li>
<li>zllen：记录了压缩列表包含的节点数量： 当这个属性的值小于 UINT16_MAX （65535）时， 这个属性的值就是压缩列表包含节点的数量； 当这个值等于 UINT16_MAX 时， 节点的真实数量需要遍历整个压缩列表才能计算得出。</li>
</ul>
<p>压缩列表中间一次保存着各个列表项entry。</p>
<p>压缩列表尾部的zlend则表示压缩列表结束，其值固定为0xFF。</p>
<h3 id="压缩列表结点"><a href="#压缩列表结点" class="headerlink" title="压缩列表结点"></a>压缩列表结点</h3><p>先看结点的数据结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">typedef struct zlentry &#123;</div><div class="line">    unsigned int prevrawlensize, prevrawlen; // 前置节点长度和编码所需长度</div><div class="line">    unsigned int lensize, len; // 当前节点长度和编码所需长度</div><div class="line">    unsigned int headersize; // 头的大小</div><div class="line">    unsigned char encoding; // 编码类型</div><div class="line">    unsigned char *p; // 数据部分</div><div class="line">&#125; zlentry;</div></pre></td></tr></table></figure>
<p>每个压缩列表节点都由 previous_entry_length 、 encoding 、 content 三个部分组成。</p>
<h4 id="previous-entry-length"><a href="#previous-entry-length" class="headerlink" title="previous_entry_length"></a>previous_entry_length</h4><p>节点的 previous_entry_length 记录了压缩列表中前一个节点的长度。</p>
<p>previous_entry_length 属性的长度可以是 1 字节或者 5 字节：</p>
<ul>
<li>如果前一节点的长度小于 254 字节， 那么 previous_entry_length 属性的长度为 1 字节： 前一节点的长度就保存在这一个字节里面。</li>
<li>如果前一节点的长度大于等于 254 字节， 那么 previous_entry_length 属性的长度为 5 字节： 其中属性的第一字节会被设置为 0xFE （十进制值 254）， 而之后的四个字节则用于保存前一节点的长度。</li>
</ul>
<p>压缩列表zltail和previous_entry_length的存在，我们能够轻松得到一个列表的尾部，然后从尾部实现向前遍历整个压缩列表。</p>
<h4 id="encoding"><a href="#encoding" class="headerlink" title="encoding"></a>encoding</h4><p>压缩列表能够保存字节数组和整数，当读取压缩列表的时候，如何区分当前的结点存储的是字节数组还是整数呢，就需要靠encoding字段来判断。</p>
<h5 id="1、字节数组"><a href="#1、字节数组" class="headerlink" title="1、字节数组"></a>1、字节数组</h5><p>保存字节数组的时候，encoding字段可以是一字节、两字节或者五字节长， 值的最高位为 00 、 01 或者 10 ，数组的长度由编码除去最高两位之后的其他位记录。</p>
<table>
<thead>
<tr>
<th>编码</th>
<th>编码长度</th>
<th>content 属性保存的值</th>
</tr>
</thead>
<tbody>
<tr>
<td>00bbbbbb</td>
<td>1 字节</td>
<td>长度小于等于 63 字节的字节数组。</td>
</tr>
<tr>
<td>01bbbbbb xxxxxxxx</td>
<td>2 字节</td>
<td>长度小于等于 16383 字节的字节数组。</td>
</tr>
<tr>
<td>10<strong>__</strong> aaaaaaaa bbbbbbbb cccccccc dddddddd</td>
<td>5 字节</td>
<td>长度小于等于 4294967295 的字节数组。</td>
</tr>
</tbody>
</table>
<p>如上表所示，三种长度的字节数组分别用不同长度的encoding字段来表示，用来节省空间。 而encoding的前两位用来标记encoding本身的类型。</p>
<h5 id="2、整数"><a href="#2、整数" class="headerlink" title="2、整数"></a>2、整数</h5><p>保存整数的时候，encoding字段为一字节长， 值的最高位以 11 开头。 整数值的类型和长度由编码除去最高两位之后的其他位记录。</p>
<table>
<thead>
<tr>
<th>编码</th>
<th>编码长度</th>
<th>content 属性保存的值</th>
</tr>
</thead>
<tbody>
<tr>
<td>11000000</td>
<td>1 字节</td>
<td>int16_t 类型的整数。</td>
</tr>
<tr>
<td>11010000</td>
<td>1 字节</td>
<td>int32_t 类型的整数。</td>
</tr>
<tr>
<td>11100000</td>
<td>1 字节</td>
<td>int64_t 类型的整数。</td>
</tr>
<tr>
<td>11110000</td>
<td>1 字节</td>
<td>24 位有符号整数。</td>
</tr>
<tr>
<td>11111110</td>
<td>1 字节</td>
<td>8 位有符号整数。</td>
</tr>
<tr>
<td>1111xxxx</td>
<td>1 字节</td>
<td>使用这一编码的节点没有相应的 content 属性， 因为编码本身的 xxxx 四个位已经保存了一个介于 0 和 12 之间的值， 所以它无须 content 属性。</td>
</tr>
</tbody>
</table>
<p>当encoding最前两位字段为11的时候，表示当前结点为整数。 同时encoding的后几位用来表示不同的整数类型。可以看到后几位中用000000表示int16_t 类型的整数， 用010000表示int32_t 类型的整数， 用100000表示int64_t 类型的整数。</p>
<p>可以注意到，为了进一步节省内存，当编码为1111xxxx时，表示没有内容部分，xxxx已经存放了当前的整数值，包括整数0~12，即xxxx可以表示0000~1101。这样就节省了content的内存空间。这边编码为11111111代表ziplist的结尾。</p>
<h3 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h3><p>由于每个压缩列表的结点保存了上一个结点的大小，所以当前结点的变化有可能引起下一个结点的变化。如果前一节点的长度小于 254 字节， 那么 previous_entry_length 属性需要用 1 字节长的空间来保存这个长度值； 如果超过了254字节，这个属性值就需要 5 个字节的长度来保存。</p>
<p>所以最坏的情况下，压缩列表中某一个结点的更新，会引起所有结点的一个更新操作，就是所谓的连锁更新。</p>
<p>此外，插入或者删除结点也有可能引起连锁更新的操作。不过虽然连锁更新带来的消耗很大，但是仍旧可以放心的使用压缩列表，因为连锁更新引起的条件比较苛刻，概率比较小。 首先， 压缩列表里要恰好有多个连续的、长度介于 250 字节至 253 字节之间的节点， 连锁更新才有可能被引发， 在实际中， 这种情况并不多见；<br>其次， 即使出现连锁更新， 但只要被更新的节点数量不多， 就不会对性能造成任何影响： 比如说， 对三五个节点进行连锁更新是绝对不会影响性能的。</p>
<h2 id="压缩列表基本操作"><a href="#压缩列表基本操作" class="headerlink" title="压缩列表基本操作"></a>压缩列表基本操作</h2><h3 id="创建新的压缩列表"><a href="#创建新的压缩列表" class="headerlink" title="创建新的压缩列表"></a>创建新的压缩列表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/* Create a new empty ziplist. */</div><div class="line">unsigned char *ziplistNew(void) &#123;</div><div class="line">    // 空ziplist的大小为11个字节，头部10字节，尾部1字节</div><div class="line">    unsigned int bytes = ZIPLIST_HEADER_SIZE+1;</div><div class="line">    // 开辟空间</div><div class="line">    unsigned char *zl = zmalloc(bytes);</div><div class="line">    // 设定压缩列表的大小</div><div class="line">    ZIPLIST_BYTES(zl) = intrev32ifbe(bytes);</div><div class="line">    // 设置尾结点相对头部的偏移量</div><div class="line">    ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(ZIPLIST_HEADER_SIZE);</div><div class="line">    // 压缩列表结点数为0</div><div class="line">    ZIPLIST_LENGTH(zl) = 0;</div><div class="line">    // 设定尾部一个字节位0xFF</div><div class="line">    zl[bytes-1] = ZIP_END;</div><div class="line">    return zl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="插入结点"><a href="#插入结点" class="headerlink" title="插入结点"></a>插入结点</h3><p>由于连锁更新的存在，插入结点的复杂度平均 O(N) ，最坏 O(N^2)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div></pre></td><td class="code"><pre><div class="line">// ziplist插入节点只能往头或者尾部插入</div><div class="line">// zl: 待插入的ziplist</div><div class="line">// s，slen: 待插入节点和其长度</div><div class="line">// where: 带插入的位置，0代表头部插入，1代表尾部插入</div><div class="line">unsigned char *ziplistPush(unsigned char *zl, unsigned char *s, unsigned int slen, int where) &#123;</div><div class="line">    unsigned char *p;</div><div class="line">    // 获取插入的位置</div><div class="line">    p = (where == ZIPLIST_HEAD) ? ZIPLIST_ENTRY_HEAD(zl) : ZIPLIST_ENTRY_END(zl);</div><div class="line">    // 执行具体的插入过程</div><div class="line">    return __ziplistInsert(zl,p,s,slen);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Insert item at &quot;p&quot;. */</div><div class="line">unsigned char *__ziplistInsert(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen) &#123;</div><div class="line">    size_t curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), reqlen;</div><div class="line">    unsigned int prevlensize, prevlen = 0; // 前置节点长度和编码该长度值所需的长度</div><div class="line">    size_t offset;</div><div class="line">    int nextdiff = 0;</div><div class="line">    unsigned char encoding = 0;</div><div class="line">    long long value = 123456789; /* 为了防止警告，进行初始化；用一个比较特殊的值以便能够方便的观察到不恰当的使用 */</div><div class="line">    zlentry tail;</div><div class="line"></div><div class="line">    /* Find out prevlen for the entry that is inserted. */</div><div class="line">    if (p[0] != ZIP_END) &#123;</div><div class="line">        // 如果不是压缩列表的结束标志，说明p指向了一个已存在的结点</div><div class="line">        // 解码得到p的前置结点和长度</div><div class="line">        ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);</div><div class="line">    &#125; else &#123;</div><div class="line">        // 如果p指向列表末端，表示列表为空</div><div class="line">        unsigned char *ptail = ZIPLIST_ENTRY_TAIL(zl);</div><div class="line">        if (ptail[0] != ZIP_END) &#123;</div><div class="line">            prevlen = zipRawEntryLength(ptail);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* See if the entry can be encoded */</div><div class="line">    // 判断是否能够编码为整数</div><div class="line">    if (zipTryEncoding(s,slen,&amp;value,&amp;encoding)) &#123;</div><div class="line">        /* &apos;encoding&apos; is set to the appropriate integer encoding */</div><div class="line">        reqlen = zipIntSize(encoding);</div><div class="line">    &#125; else &#123;</div><div class="line">        /* &apos;encoding&apos; is untouched, however zipStoreEntryEncoding will use the</div><div class="line">         * string length to figure out how to encode it. */</div><div class="line">        // 编码为字节数组</div><div class="line">        reqlen = slen;</div><div class="line">    &#125;</div><div class="line">    /* We need space for both the length of the previous entry and</div><div class="line">     * the length of the payload. */</div><div class="line">    // 加上前置结点的编码长度和当前结点的编码长度</div><div class="line">    reqlen += zipStorePrevEntryLength(NULL,prevlen);</div><div class="line">    reqlen += zipStoreEntryEncoding(NULL,encoding,slen);</div><div class="line"></div><div class="line">    /* When the insert position is not equal to the tail, we need to</div><div class="line">     * make sure that the next entry can hold this entry&apos;s length in</div><div class="line">     * its prevlen field. */</div><div class="line">    // 如果不是插入到列表的末端，都需要判断下一个结点是否能存放新节点的长度编码</div><div class="line">    // nextdiff保存新旧编码之间的字节大小差，如果这个值大于0</div><div class="line">    // 那就说明当前p指向的节点的header进行扩展</div><div class="line">    int forcelarge = 0;</div><div class="line">    nextdiff = (p[0] != ZIP_END) ? zipPrevLenByteDiff(p,reqlen) : 0;</div><div class="line">    if (nextdiff == -4 &amp;&amp; reqlen &lt; 4) &#123;</div><div class="line">        nextdiff = 0;</div><div class="line">        forcelarge = 1;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* Store offset because a realloc may change the address of zl. */</div><div class="line">    // 保存偏移量</div><div class="line">    offset = p-zl;</div><div class="line">    // 重新分配空间，curlen当前列表的长度</div><div class="line">    // reqlen 新节点的全部长度</div><div class="line">    // nextdiff 新节点的后继节点扩展header的长度</div><div class="line">    zl = ziplistResize(zl,curlen+reqlen+nextdiff);</div><div class="line">    // 根据新的压缩列表地址得到新的p的地址</div><div class="line">    p = zl+offset;</div><div class="line"></div><div class="line">    /* Apply memory move when necessary and update tail offset. */</div><div class="line">    if (p[0] != ZIP_END) &#123;</div><div class="line">        // 如果不是表尾插入，需要更新表尾的偏移地址</div><div class="line">        /* Subtract one because of the ZIP_END bytes */</div><div class="line">        memmove(p+reqlen,p-nextdiff,curlen-offset-1+nextdiff);</div><div class="line"></div><div class="line">        /* Encode this entry&apos;s raw length in the next entry. */</div><div class="line">        // 编码新结点的长度到下一个结点中</div><div class="line">        if (forcelarge)</div><div class="line">            zipStorePrevEntryLengthLarge(p+reqlen,reqlen);</div><div class="line">        else</div><div class="line">            zipStorePrevEntryLength(p+reqlen,reqlen);</div><div class="line"></div><div class="line">        /* Update offset for tail */</div><div class="line">        ZIPLIST_TAIL_OFFSET(zl) =</div><div class="line">            intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+reqlen);</div><div class="line"></div><div class="line">        /* When the tail contains more than one entry, we need to take</div><div class="line">         * &quot;nextdiff&quot; in account as well. Otherwise, a change in the</div><div class="line">         * size of prevlen doesn&apos;t have an effect on the *tail* offset. */</div><div class="line">        zipEntry(p+reqlen, &amp;tail);</div><div class="line">        if (p[reqlen+tail.headersize+tail.len] != ZIP_END) &#123;</div><div class="line">            ZIPLIST_TAIL_OFFSET(zl) =</div><div class="line">                intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+nextdiff);</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        /* This element will be the new tail. */</div><div class="line">        ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(p-zl);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 如果nextdiff不等于0， 下一个结点的头部需要进行扩展</div><div class="line">    if (nextdiff != 0) &#123;</div><div class="line">        offset = p-zl;</div><div class="line">        zl = __ziplistCascadeUpdate(zl,p+reqlen);</div><div class="line">        p = zl+offset;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* Write the entry */</div><div class="line">    // 将新节点前置节点的长度写入新节点的header</div><div class="line">    p += zipStorePrevEntryLength(p,prevlen);</div><div class="line">    // 编码新结点</div><div class="line">    p += zipStoreEntryEncoding(p,encoding,slen);</div><div class="line">    if (ZIP_IS_STR(encoding)) &#123;</div><div class="line">        memcpy(p,s,slen);</div><div class="line">    &#125; else &#123;</div><div class="line">        zipSaveInteger(p,value,encoding);</div><div class="line">    &#125;</div><div class="line">    ZIPLIST_INCR_LENGTH(zl,1);</div><div class="line">    return zl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="查找结点"><a href="#查找结点" class="headerlink" title="查找结点"></a>查找结点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">/* 寻找节点值和 vstr 相等的列表节点，并返回该节点的指针。</div><div class="line"> * 每次比对之前都跳过 skip 个节点。</div><div class="line"> * 如果找不到相应的节点，则返回 NULL 。 */</div><div class="line">unsigned char *ziplistFind(unsigned char *p, unsigned char *vstr, unsigned int vlen, unsigned int skip) &#123;</div><div class="line">    int skipcnt = 0;</div><div class="line">    unsigned char vencoding = 0;</div><div class="line">    long long vll = 0;</div><div class="line"></div><div class="line">    // 循环直到碰到结束标志</div><div class="line">    while (p[0] != ZIP_END) &#123;</div><div class="line">        unsigned int prevlensize, encoding, lensize, len;</div><div class="line">        unsigned char *q;</div><div class="line"></div><div class="line">        // 解码得到前置结点的长度</div><div class="line">        ZIP_DECODE_PREVLENSIZE(p, prevlensize);</div><div class="line">        // 当前结点的长度</div><div class="line">        ZIP_DECODE_LENGTH(p + prevlensize, encoding, lensize, len);</div><div class="line">        q = p + prevlensize + lensize;</div><div class="line"></div><div class="line">        if (skipcnt == 0) &#123;</div><div class="line">            /* Compare current entry with specified entry */</div><div class="line">            // 如果是字节数组，直接比较</div><div class="line">            if (ZIP_IS_STR(encoding)) &#123;</div><div class="line">                if (len == vlen &amp;&amp; memcmp(q, vstr, vlen) == 0) &#123;</div><div class="line">                    return p;</div><div class="line">                &#125;</div><div class="line">            &#125; else &#123;</div><div class="line">                /* 查看目标值是否能被编码，只会在第一次循环的时候检查；</div><div class="line">                 * 检查一次之后vencoding会被置为非0 */</div><div class="line">                if (vencoding == 0) &#123;</div><div class="line">                    if (!zipTryEncoding(vstr, vlen, &amp;vll, &amp;vencoding)) &#123;</div><div class="line">                        /* 如果不能被编码，设置格式为UCHAR_MAX ， 下次不会再检查*/</div><div class="line">                        vencoding = UCHAR_MAX;</div><div class="line">                    &#125;</div><div class="line">                    /* Must be non-zero by now */</div><div class="line">                    assert(vencoding);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                /* Compare current entry with specified entry, do it only</div><div class="line">                 * if vencoding != UCHAR_MAX because if there is no encoding</div><div class="line">                 * possible for the field it can&apos;t be a valid integer. */</div><div class="line">                if (vencoding != UCHAR_MAX) &#123;</div><div class="line">                    long long ll = zipLoadInteger(q, encoding);</div><div class="line">                    if (ll == vll) &#123;</div><div class="line">                        return p;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            /* Reset skip count */</div><div class="line">            skipcnt = skip;</div><div class="line">        &#125; else &#123;</div><div class="line">            /* Skip entry */</div><div class="line">            skipcnt--;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        /* Move to next entry */</div><div class="line">        // 后移指针，指向后置节点</div><div class="line">        p = q + len;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return NULL;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="删除结点"><a href="#删除结点" class="headerlink" title="删除结点"></a>删除结点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line">// 删除给定节点，输入压缩列表zl和指向删除节点的指针p</div><div class="line">unsigned char *ziplistDelete(unsigned char *zl, unsigned char **p) &#123;</div><div class="line">    size_t offset = *p-zl;</div><div class="line">    // 调用底层函数__ziplistDelete进行删除操作</div><div class="line">    zl = __ziplistDelete(zl,*p,1);</div><div class="line">    // 删除操作可能会改变zl，因为会重新分配内存</div><div class="line">    *p = zl+offset;</div><div class="line">    return zl;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* 从位置 p 开始，连续删除 num 个节点。</div><div class="line"> * 函数的返回值为处理删除操作之后的 ziplist */</div><div class="line">unsigned char *__ziplistDelete(unsigned char *zl, unsigned char *p, unsigned int num) &#123;</div><div class="line">    unsigned int i, totlen, deleted = 0;</div><div class="line">    size_t offset;</div><div class="line">    int nextdiff = 0;</div><div class="line">    zlentry first, tail;</div><div class="line"></div><div class="line">    zipEntry(p, &amp;first);</div><div class="line">    // 计算被删除节点的总个数</div><div class="line">    for (i = 0; p[0] != ZIP_END &amp;&amp; i &lt; num; i++) &#123;</div><div class="line">        p += zipRawEntryLength(p);</div><div class="line">        deleted++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // totlen 是所有被删除节点总共占用的内存字节数</div><div class="line">    totlen = p-first.p; /* Bytes taken by the element(s) to delete. */</div><div class="line">    if (totlen &gt; 0) &#123;</div><div class="line">        if (p[0] != ZIP_END) &#123;</div><div class="line">            // 不是尾结点，表示被删除节点之后仍然有节点存在</div><div class="line">            </div><div class="line">            // 因为位于被删除范围之后的第一个节点的 header 部分的大小</div><div class="line">            // 可能容纳不了新的前置节点，所以需要计算新旧前置节点之间的字节数差</div><div class="line">            nextdiff = zipPrevLenByteDiff(p,first.prevrawlen);</div><div class="line"></div><div class="line">            /* Note that there is always space when p jumps backward: if</div><div class="line">             * the new previous entry is large, one of the deleted elements</div><div class="line">             * had a 5 bytes prevlen header, so there is for sure at least</div><div class="line">             * 5 bytes free and we need just 4. */</div><div class="line">            // 如果有需要的话，将指针 p 后退 nextdiff 字节，为新 header 空出空间</div><div class="line">            // 由于会删除之前的结点，所以肯定会有足够的空间用来扩展</div><div class="line">            p -= nextdiff;</div><div class="line">            // 将 first 的前置节点的长度编码至 p 中</div><div class="line">            zipStorePrevEntryLength(p,first.prevrawlen);</div><div class="line"></div><div class="line">            /* Update offset for tail */</div><div class="line">            ZIPLIST_TAIL_OFFSET(zl) =</div><div class="line">                intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))-totlen);</div><div class="line"></div><div class="line">            /* When the tail contains more than one entry, we need to take</div><div class="line">             * &quot;nextdiff&quot; in account as well. Otherwise, a change in the</div><div class="line">             * size of prevlen doesn&apos;t have an effect on the *tail* offset. */</div><div class="line">            // 如果被删除节点之后，有多于一个节点</div><div class="line">            // 那么程序需要将 nextdiff 记录的字节数也计算到表尾偏移量中</div><div class="line">            // 这样才能让表尾偏移量正确对齐表尾节点</div><div class="line">            zipEntry(p, &amp;tail);</div><div class="line">            if (p[tail.headersize+tail.len] != ZIP_END) &#123;</div><div class="line">                ZIPLIST_TAIL_OFFSET(zl) =</div><div class="line">                   intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+nextdiff);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            /* Move tail to the front of the ziplist */</div><div class="line">            // 从表尾向表头移动数据，覆盖被删除节点的数据</div><div class="line">            memmove(first.p,p,</div><div class="line">                intrev32ifbe(ZIPLIST_BYTES(zl))-(p-zl)-1);</div><div class="line">        &#125; else &#123;</div><div class="line">            /* The entire tail was deleted. No need to move memory. */</div><div class="line">            // 执行这里，表示被删除节点之后已经没有其他节点了， 不需要移动结点</div><div class="line">            ZIPLIST_TAIL_OFFSET(zl) =</div><div class="line">                intrev32ifbe((first.p-zl)-first.prevrawlen);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        /* Resize and update length */</div><div class="line">        // 缩小并更新 ziplist 的长度</div><div class="line">        offset = first.p-zl;</div><div class="line">        zl = ziplistResize(zl, intrev32ifbe(ZIPLIST_BYTES(zl))-totlen+nextdiff);</div><div class="line">        ZIPLIST_INCR_LENGTH(zl,-deleted);</div><div class="line">        p = zl+offset;</div><div class="line"></div><div class="line">        /* When nextdiff != 0, the raw length of the next entry has changed, so</div><div class="line">         * we need to cascade the update throughout the ziplist */</div><div class="line">        // 如果 p 所指向的节点的大小已经变更，那么进行级联更新</div><div class="line">        // 检查 p 之后的所有节点是否符合 ziplist 的编码要求</div><div class="line">        if (nextdiff != 0)</div><div class="line">            zl = __ziplistCascadeUpdate(zl,p);</div><div class="line">    &#125;</div><div class="line">    return zl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://harleylau.github.io/2017/09/05/Redis源码剖析-压缩列表/" data-id="cji4caxn2000qik68r49ihati" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/">redis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码/">源码</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JWT/">JWT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tornado/">Tornado</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tornado/">tornado</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/websocket/">websocket</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/二维码/">二维码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/源码/">源码</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/JWT/" style="font-size: 10px;">JWT</a> <a href="/tags/Python/" style="font-size: 10px;">Python</a> <a href="/tags/Tornado/" style="font-size: 10px;">Tornado</a> <a href="/tags/redis/" style="font-size: 20px;">redis</a> <a href="/tags/tornado/" style="font-size: 15px;">tornado</a> <a href="/tags/websocket/" style="font-size: 10px;">websocket</a> <a href="/tags/二维码/" style="font-size: 10px;">二维码</a> <a href="/tags/源码/" style="font-size: 20px;">源码</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">六月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/06/04/Redis源码剖析-哈希对象t-hash实现/">Redis源码剖析--哈希对象t_hash实现</a>
          </li>
        
          <li>
            <a href="/2018/05/31/Redis源码剖析-quicklist/">Redis源码剖析--quicklist</a>
          </li>
        
          <li>
            <a href="/2018/05/10/Redis源码剖析-列表t-list实现/">Redis源码剖析--列表t_list实现</a>
          </li>
        
          <li>
            <a href="/2018/05/09/Redis源码剖析-字符串t-string实现/">Redis源码剖析--字符串t_string实现</a>
          </li>
        
          <li>
            <a href="/2018/02/12/tornado-websocket实现二维码扫描/">tornado websocket实现二维码扫描</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 Harley Liu<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>