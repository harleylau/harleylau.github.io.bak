<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Harley_Lau</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Harley_Lau">
<meta property="og:url" content="https://harleylau.github.io/index.html">
<meta property="og:site_name" content="Harley_Lau">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Harley_Lau">
  
    <link rel="alternate" href="/atom.xml" title="Harley_Lau" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Harley_Lau</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://harleylau.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Redis源码剖析-列表t-list实现" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/10/Redis源码剖析-列表t-list实现/" class="article-date">
  <time datetime="2018-05-10T01:53:08.000Z" itemprop="datePublished">2018-05-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/10/Redis源码剖析-列表t-list实现/">Redis源码剖析--列表t_list实现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Redis中的列表对象比较特殊，在版本3.2之前，列表底层的编码是 ziplist 和 linkedlist 实现的， 但是在版本3.2之后，重新引入了一个 quicklist 的数据结构，列表的底层都由quicklist实现。</p>
<p>这边是在看源码和实际验证的时候发现的区别，然后上网查证。由于目前使用的redis基本都在3.2了， 而且老版本肯定会被取代， 所以我们只分析3.2版本之后的实现。对于老版本的列表实现，一笔带过吧。 </p>
<p>在老版本中，当列表对象可以同时满足以下两个条件时， 列表对象使用 ziplist 编码：</p>
<ul>
<li>列表对象保存的所有字符串元素的长度都小于 64 字节；</li>
<li>列表对象保存的元素数量小于 512 个；</li>
</ul>
<p>不能满足这两个条件的列表对象需要使用 linkedlist 编码。当这两个条件任何一个不满足的时候，就会有一个格式的转换。</p>
<p>对于quicklist的结构，下节中在具体分析，先来看下list的实现。</p>
<h2 id="List的结构"><a href="#List的结构" class="headerlink" title="List的结构"></a>List的结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/* Structure to hold list iteration abstraction. */</div><div class="line">typedef struct &#123;</div><div class="line">    robj *subject;</div><div class="line">    unsigned char encoding;</div><div class="line">    unsigned char direction; /* Iteration direction */</div><div class="line">    quicklistIter *iter;</div><div class="line">&#125; listTypeIterator;</div><div class="line"></div><div class="line">/* Structure for an entry while iterating over a list. */</div><div class="line">typedef struct &#123;</div><div class="line">    listTypeIterator *li;</div><div class="line">    quicklistEntry entry; /* Entry in quicklist */</div><div class="line">&#125; listTypeEntry;</div></pre></td></tr></table></figure>
<p>List的结构其实就是定义了一个列表的头节点， 以及一个迭代器指针，指针中指定了编码格式和迭代方向。</p>
<h2 id="List命令"><a href="#List命令" class="headerlink" title="List命令"></a>List命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>BLPOP key1 [key2 ] timeout</td>
<td>移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td>
</tr>
<tr>
<td>BRPOP key1 [key2 ] timeout</td>
<td>移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td>
</tr>
<tr>
<td>BRPOPLPUSH source destination timeout</td>
<td>从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它；如但果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td>
</tr>
<tr>
<td>LINDEX key index</td>
<td>通过索引获取列表中的元素</td>
</tr>
<tr>
<td>LINSERT key BEFORE</td>
<td>AFTER pivot value</td>
<td>在列表的元素前或者后插入元素</td>
</tr>
<tr>
<td>LLEN key</td>
<td>获取列表长度</td>
</tr>
<tr>
<td>LPOP key</td>
<td>移出并获取列表的第一个元素</td>
</tr>
<tr>
<td>LPUSH key value1 [value2]</td>
<td>将一个或多个值插入到列表头部</td>
</tr>
<tr>
<td>LPUSHX key value</td>
<td>将一个或多个值插入到已存在的列表头部</td>
</tr>
<tr>
<td>LRANGE key start stop</td>
<td>获取列表指定范围内的元素</td>
</tr>
<tr>
<td>LREM key count value</td>
<td>移除列表元素</td>
</tr>
<tr>
<td>LSET key index value</td>
<td>通过索引设置列表元素的值</td>
</tr>
<tr>
<td>LTRIM key start stop</td>
<td>对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。</td>
</tr>
<tr>
<td>RPOP key</td>
<td>移除并获取列表最后一个元素</td>
</tr>
<tr>
<td>RPOPLPUSH source destination</td>
<td>移除列表的最后一个元素，并将该元素添加到另一个列表并返回</td>
</tr>
<tr>
<td>RPUSH key value1 [value2]</td>
<td>在列表中添加一个或多个值</td>
</tr>
<tr>
<td>RPUSHX key value</td>
<td>为已存在的列表添加值</td>
</tr>
</tbody>
</table>
<h2 id="List命令实现"><a href="#List命令实现" class="headerlink" title="List命令实现"></a>List命令实现</h2><h3 id="push命令实现"><a href="#push命令实现" class="headerlink" title="push命令实现"></a>push命令实现</h3><p>lpush和rpush分别调用的下边的两个函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// lpush操作</div><div class="line">void lpushCommand(client *c) &#123;</div><div class="line">    pushGenericCommand(c,LIST_HEAD);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// rpush操作</div><div class="line">void rpushCommand(client *c) &#123;</div><div class="line">    pushGenericCommand(c,LIST_TAIL);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到， 这两个操作其实都是调用的pushGenericCommand这个函数实现， 不同的点是指定了是从HEAD的位置push一个数据还是从TAIL的位置push一个数据。接下来来看pushGenericCommand的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">void pushGenericCommand(client *c, int where) &#123;</div><div class="line">    int j, pushed = 0;</div><div class="line">    // 现在数据库中查找是否已经存在了该键</div><div class="line">    robj *lobj = lookupKeyWrite(c-&gt;db,c-&gt;argv[1]);</div><div class="line">    // 如果已经存在了该键，验证该键是否是list类型，如果不是的话，返回错误</div><div class="line">    if (lobj &amp;&amp; lobj-&gt;type != OBJ_LIST) &#123;</div><div class="line">        addReply(c,shared.wrongtypeerr);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    // 遍历剩余的参数</div><div class="line">    for (j = 2; j &lt; c-&gt;argc; j++) &#123;</div><div class="line">        // 如果该键不存在，创建一个quicklist</div><div class="line">        if (!lobj) &#123;</div><div class="line">            lobj = createQuicklistObject();</div><div class="line">            quicklistSetOptions(lobj-&gt;ptr, server.list_max_ziplist_size,</div><div class="line">                                server.list_compress_depth);</div><div class="line">            // 将创建的键添加到对应的db</div><div class="line">            dbAdd(c-&gt;db,c-&gt;argv[1],lobj);</div><div class="line">        &#125;</div><div class="line">        // 执行push操作</div><div class="line">        listTypePush(lobj,c-&gt;argv[j],where);</div><div class="line">        // 个数加1</div><div class="line">        pushed++;</div><div class="line">    &#125;</div><div class="line">    // 返回添加的节点数量</div><div class="line">    addReplyLongLong(c, (lobj ? listTypeLength(lobj) : 0));</div><div class="line">    // 至少有一个添加成功则进行操作</div><div class="line">    if (pushed) &#123;</div><div class="line">        char *event = (where == LIST_HEAD) ? &quot;lpush&quot; : &quot;rpush&quot;;</div><div class="line">        // 发送键修改信号</div><div class="line">        signalModifiedKey(c-&gt;db,c-&gt;argv[1]);</div><div class="line">        // 发送事件通知</div><div class="line">        notifyKeyspaceEvent(NOTIFY_LIST,event,c-&gt;argv[1],c-&gt;db-&gt;id);</div><div class="line">    &#125;</div><div class="line">    // 服务器的脏数据个数增加</div><div class="line">    server.dirty += pushed;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>内部最终还是调用了一个listTypePush的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">/* The function pushes an element to the specified list object &apos;subject&apos;,</div><div class="line"> * at head or tail position as specified by &apos;where&apos;.</div><div class="line"> *</div><div class="line"> * There is no need for the caller to increment the refcount of &apos;value&apos; as</div><div class="line"> * the function takes care of it if needed. */</div><div class="line">void listTypePush(robj *subject, robj *value, int where) &#123;</div><div class="line">    // 判断类型是否为quciklist，不是的话返回错误</div><div class="line">    if (subject-&gt;encoding == OBJ_ENCODING_QUICKLIST) &#123;</div><div class="line">        int pos = (where == LIST_HEAD) ? QUICKLIST_HEAD : QUICKLIST_TAIL;</div><div class="line">        // 解码数据</div><div class="line">        value = getDecodedObject(value);</div><div class="line">        // 得到数据的长度</div><div class="line">        size_t len = sdslen(value-&gt;ptr);</div><div class="line">        // 调用quicklistPush插入数据</div><div class="line">        quicklistPush(subject-&gt;ptr, value-&gt;ptr, len, pos);</div><div class="line">        // 将数据项对象的引用次数减1，也就是释放value</div><div class="line">        decrRefCount(value);</div><div class="line">    &#125; else &#123;</div><div class="line">        serverPanic(&quot;Unknown list encoding&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>pop的操作其实跟push的操作很相似，比较容易读懂。List的操作比较有特点的一项是阻塞操作，可以来分析一下。</p>
<h3 id="阻塞pop操作的实现"><a href="#阻塞pop操作的实现" class="headerlink" title="阻塞pop操作的实现"></a>阻塞pop操作的实现</h3><p>首先，一样是调用了最上层的两个函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// blpop</div><div class="line">void blpopCommand(client *c) &#123;</div><div class="line">    blockingPopGenericCommand(c,LIST_HEAD);</div><div class="line">&#125;</div><div class="line">// brpop</div><div class="line">void brpopCommand(client *c) &#123;</div><div class="line">    blockingPopGenericCommand(c,LIST_TAIL);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>他们其实都是调用blockingPopGenericCommand来实现的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">/* Blocking RPOP/LPOP */</div><div class="line">void blockingPopGenericCommand(client *c, int where) &#123;</div><div class="line">    robj *o;</div><div class="line">    mstime_t timeout;</div><div class="line">    int j;</div><div class="line"></div><div class="line">    // 取出timeout参数</div><div class="line">    if (getTimeoutFromObjectOrReply(c,c-&gt;argv[c-&gt;argc-1],&amp;timeout,UNIT_SECONDS)</div><div class="line">        != C_OK) return;</div><div class="line">    // 遍历参数</div><div class="line">    for (j = 1; j &lt; c-&gt;argc-1; j++) &#123;</div><div class="line">        // 查看数据库中是否存在该键</div><div class="line">        o = lookupKeyWrite(c-&gt;db,c-&gt;argv[j]);</div><div class="line">        if (o != NULL) &#123;</div><div class="line">            // 如果存在，判断该键是否是list类型，不是的话报错</div><div class="line">            if (o-&gt;type != OBJ_LIST) &#123;</div><div class="line">                addReply(c,shared.wrongtypeerr);</div><div class="line">                return;</div><div class="line">            &#125; else &#123;</div><div class="line">                // 当前列表非空，直接执行pop操作</div><div class="line">                if (listTypeLength(o) != 0) &#123;</div><div class="line">                    /* Non empty list, this is like a non normal [LR]POP. */</div><div class="line">                    char *event = (where == LIST_HEAD) ? &quot;lpop&quot; : &quot;rpop&quot;;</div><div class="line">                    robj *value = listTypePop(o,where);</div><div class="line">                    serverAssert(value != NULL);</div><div class="line"></div><div class="line">                    addReplyMultiBulkLen(c,2);</div><div class="line">                    addReplyBulk(c,c-&gt;argv[j]);</div><div class="line">                    addReplyBulk(c,value);</div><div class="line">                    decrRefCount(value);</div><div class="line">                    notifyKeyspaceEvent(NOTIFY_LIST,event,</div><div class="line">                                        c-&gt;argv[j],c-&gt;db-&gt;id);</div><div class="line">                    // 如果当前key弹出一个值之后为空，删除这个列表</div><div class="line">                    if (listTypeLength(o) == 0) &#123;</div><div class="line">                        dbDelete(c-&gt;db,c-&gt;argv[j]);</div><div class="line">                        notifyKeyspaceEvent(NOTIFY_GENERIC,&quot;del&quot;,</div><div class="line">                                            c-&gt;argv[j],c-&gt;db-&gt;id);</div><div class="line">                    &#125;</div><div class="line">                    signalModifiedKey(c-&gt;db,c-&gt;argv[j]);</div><div class="line">                    server.dirty++;</div><div class="line"></div><div class="line">                    /* Replicate it as an [LR]POP instead of B[LR]POP. */</div><div class="line">                    rewriteClientCommandVector(c,2,</div><div class="line">                        (where == LIST_HEAD) ? shared.lpop : shared.rpop,</div><div class="line">                        c-&gt;argv[j]);</div><div class="line">                    return;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* If we are inside a MULTI/EXEC and the list is empty the only thing</div><div class="line">     * we can do is treating it as a timeout (even with timeout 0). */</div><div class="line">    if (c-&gt;flags &amp; CLIENT_MULTI) &#123;</div><div class="line">        addReply(c,shared.nullmultibulk);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* If the list is empty or the key does not exists we must block */</div><div class="line">    // 参数中的所有键都不存在，则阻塞这些键</div><div class="line">    blockForKeys(c, c-&gt;argv + 1, c-&gt;argc - 2, timeout, NULL);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到， 当指定的list存在于当前数据库中且list不为空，就会执行一次普通的pop操作；但是当指定的list键不存在，或者该list为空，就会阻塞该操作。就是上边代码中的最后一句。</p>
<p>接下去，就是看redis如何处理这个被阻塞的操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">/* Set a client in blocking mode for the specified key, with the specified</div><div class="line"> * timeout */</div><div class="line"> // 设置键的阻塞状态</div><div class="line">void blockForKeys(client *c, robj **keys, int numkeys, mstime_t timeout, robj *target) &#123;</div><div class="line">    dictEntry *de;</div><div class="line">    list *l;</div><div class="line">    int j;</div><div class="line"></div><div class="line">    c-&gt;bpop.timeout = timeout;</div><div class="line">    c-&gt;bpop.target = target;</div><div class="line"></div><div class="line">    if (target != NULL) incrRefCount(target);</div><div class="line"></div><div class="line">    // 遍历所有的key</div><div class="line">    for (j = 0; j &lt; numkeys; j++) &#123;</div><div class="line">        /* If the key already exists in the dict ignore it. */</div><div class="line">        // 如果当前键存在，则忽略；反之则添加该键</div><div class="line">        // bpop.keys记录所有造成客户端阻塞的键</div><div class="line">        if (dictAdd(c-&gt;bpop.keys,keys[j],NULL) != DICT_OK) continue;</div><div class="line">        //当前的key引用计数加1</div><div class="line">        incrRefCount(keys[j]);</div><div class="line"></div><div class="line">        /* And in the other &quot;side&quot;, to map keys -&gt; clients */</div><div class="line">        // blocking_keys是一个字典，其键为造成阻塞的键，值是一个链表，记录所有被该键阻塞的客户端</div><div class="line">        // 查找当前造成阻塞的键</div><div class="line">        de = dictFind(c-&gt;db-&gt;blocking_keys,keys[j]);</div><div class="line">        if (de == NULL) &#123;</div><div class="line">            // 如果不存在，需要新创建一个， 并加入到blocking_keys中</div><div class="line">            int retval;</div><div class="line"></div><div class="line">            /* For every key we take a list of clients blocked for it */</div><div class="line">            l = listCreate();</div><div class="line">            // 将键和新创建的列表加入</div><div class="line">            retval = dictAdd(c-&gt;db-&gt;blocking_keys,keys[j],l);</div><div class="line">            incrRefCount(keys[j]);</div><div class="line">            serverAssertWithInfo(c,keys[j],retval == DICT_OK);</div><div class="line">        &#125; else &#123;</div><div class="line">            // 如果存在，获取该键的值，即客户端列表</div><div class="line">            l = dictGetVal(de);</div><div class="line">        &#125;</div><div class="line">        // 将当前的客户端加入的该键的阻塞列表中</div><div class="line">        listAddNodeTail(l,c);</div><div class="line">    &#125;</div><div class="line">    // 阻塞该客户端</div><div class="line">    blockClient(c,BLOCKED_LIST);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上边的代码中，可以看到客户端分别用来c-&gt;bpop.xxxx 和 c-&gt;db-&gt;blocking_keys用来保存被阻塞的键，以及阻塞的键和客户端的对应关系。</p>
<p>他们的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">// server.h</div><div class="line">typedef struct client &#123;</div><div class="line">    //client当前使用的数据库</div><div class="line">    redisDb *db;   /* Pointer to currently SELECTed DB. */</div><div class="line"></div><div class="line">    //阻塞状态</div><div class="line">    blockingState bpop;     /* blocking state */</div><div class="line">    //其他成员省略</div><div class="line">&#125; client;</div><div class="line"></div><div class="line">// 阻塞状态结构体</div><div class="line">typedef struct blockingState &#123;</div><div class="line">    mstime_t timeout;      // 阻塞超时时间</div><div class="line">    dict *keys;           // 记录所有造成客户端阻塞的键</div><div class="line">    robj *target;         // 目标选项，target在执行RPOPLPUSH命令时使用，</div><div class="line">    /* BLOCKED_WAIT */</div><div class="line">    int numreplicas;        /* Number of replicas we are waiting for ACK. */</div><div class="line">    long long reploffset;   /* Replication offset to reach. */</div><div class="line">&#125; blockingState;</div><div class="line">typedef struct redisDb &#123;</div><div class="line">    dict *blocking_keys;        // 记录所有造成阻塞的键，及其相应的客户端</div><div class="line">    // ...其他参数省略</div><div class="line">&#125; redisDb;</div><div class="line"></div><div class="line">typedef struct redisDb &#123;</div><div class="line">    //正处于阻塞状态的键</div><div class="line">    dict *blocking_keys;        /* Keys with clients waiting for data (BLPOP) */</div><div class="line">    //可以解除阻塞的键</div><div class="line">    dict *ready_keys;           /* Blocked keys that received a PUSH */</div><div class="line">&#125; redisDb;</div></pre></td></tr></table></figure>
<p>redisDb里边利用了一个名为blocking_keys的dict来存储每个阻塞的键，以及等待该键的客户端的对应关系。</p>
<p>做完这些之后，这个客户端就被阻塞了。 那么这个客户端如何从阻塞状态重新回复到非阻塞状态呢。 一个当时是等待的时间超过了timeout的时间，从阻塞状态恢复； 另一个则是其他的客户端往这个列表中插入了数据，正好是当前阻塞的客户端所需要的，当前客户端收到信号之后，从阻塞状态中恢复。</p>
<p>根据我的理解， 如果是客户端超时被解阻塞，调用的是这个函数：</p>
<h4 id="超时解阻塞"><a href="#超时解阻塞" class="headerlink" title="超时解阻塞"></a>超时解阻塞</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">//解阻塞一个正在阻塞中的client</div><div class="line">void unblockClientWaitingData(client *c) &#123;</div><div class="line">    dictEntry *de;</div><div class="line">    dictIterator *di;</div><div class="line">    list *l;</div><div class="line"></div><div class="line">    serverAssertWithInfo(c,NULL,dictSize(c-&gt;bpop.keys) != 0);</div><div class="line">    //创建一个字典的迭代器，指向的是造成client阻塞的键所组成的字典</div><div class="line">    di = dictGetIterator(c-&gt;bpop.keys);</div><div class="line">    /* The client may wait for multiple keys, so unblock it for every key. */</div><div class="line">    //因为client可能被多个key所阻塞，所以要遍历所有的键</div><div class="line">    while((de = dictNext(di)) != NULL) &#123;</div><div class="line">        robj *key = dictGetKey(de); //获得key对象</div><div class="line"></div><div class="line">        /* Remove this client from the list of clients waiting for this key. */</div><div class="line">        //根据key找到对应的列表类型值，值保存着被阻塞的client，从中找c-&gt;db-&gt;blocking_keys中寻找</div><div class="line">        l = dictFetchValue(c-&gt;db-&gt;blocking_keys,key);</div><div class="line">        serverAssertWithInfo(c,key,l != NULL);</div><div class="line">        // 将阻塞的client从列表中移除</div><div class="line">        listDelNode(l,listSearchKey(l,c));</div><div class="line">        /* If the list is empty we need to remove it to avoid wasting memory */</div><div class="line">        //如果当前列表为空了，则从c-&gt;db-&gt;blocking_keys中将key删除</div><div class="line">        if (listLength(l) == 0)</div><div class="line">            dictDelete(c-&gt;db-&gt;blocking_keys,key);</div><div class="line">    &#125;</div><div class="line">    dictReleaseIterator(di);    //释放迭代器</div><div class="line"></div><div class="line">    /* Cleanup the client structure */</div><div class="line">    //清空bpop.keys的所有节点</div><div class="line">    dictEmpty(c-&gt;bpop.keys,NULL);</div><div class="line">    //如果保存有新添加的元素，则应该释放</div><div class="line">    if (c-&gt;bpop.target) &#123;</div><div class="line">        decrRefCount(c-&gt;bpop.target);</div><div class="line">        c-&gt;bpop.target = NULL;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果是其他的客户端插入了一个数据，则是调用下边的函数：</p>
<h4 id="插入解阻塞"><a href="#插入解阻塞" class="headerlink" title="插入解阻塞"></a>插入解阻塞</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">// 如果客户端因为等待某个 key 被阻塞，那么将此key加入到server.ready_keys中</div><div class="line">// 这个列表最终会被 handleClientsBlockedOnLists() 函数处理。</div><div class="line">void signalListAsReady(redisDb *db, robj *key) &#123;</div><div class="line">    readyList *rl;</div><div class="line">    // 如果在所有造成客户端阻塞的键中找不到此键，则不作处理</div><div class="line">    if (dictFind(db-&gt;blocking_keys,key) == NULL) return;</div><div class="line">    // 这个键已经存在于ready_keys中了，则不作处理</div><div class="line">    if (dictFind(db-&gt;ready_keys,key) != NULL) return;</div><div class="line">    </div><div class="line">    // 创建一个新的readylists结构，保存键和数据库</div><div class="line">    // 然后将该结构添加到server.ready_keys中</div><div class="line">    rl = zmalloc(sizeof(*rl));</div><div class="line">    rl-&gt;key = key;</div><div class="line">    rl-&gt;db = db;</div><div class="line">    // 该键的索引加1</div><div class="line">    incrRefCount(key);</div><div class="line">    listAddNodeTail(server.ready_keys,rl);</div><div class="line">    // 同样，将key添加到db-&gt;ready_keys中</div><div class="line">    incrRefCount(key);</div><div class="line">    serverAssert(dictAdd(db-&gt;ready_keys,key,NULL) == DICT_OK);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在将所有可用的key加入到ready_keys之后，会有统一的函数去检查哪些客户端等待着这些key，然后将他们解阻塞</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div></pre></td><td class="code"><pre><div class="line">/* 遍历server.ready_keys中所有已经准备好的key，同时在c-&gt;db-&gt;blocking_keys中</div><div class="line"> 遍历所有由此键造成阻塞的客户端，如果key不为空的话，就从key中弹出一个元素返回给客户端并解除该客户端的阻塞状态，直到server.ready_keys为空，或没有因该key而阻塞的客户端为止 */</div><div class="line">/* This function should be called by Redis every time a single command,</div><div class="line"> * a MULTI/EXEC block, or a Lua script, terminated its execution after</div><div class="line"> * being called by a client.</div><div class="line"> *</div><div class="line"> * All the keys with at least one client blocked that received at least</div><div class="line"> * one new element via some PUSH operation are accumulated into</div><div class="line"> * the server.ready_keys list. This function will run the list and will</div><div class="line"> * serve clients accordingly. Note that the function will iterate again and</div><div class="line"> * again as a result of serving BRPOPLPUSH we can have new blocking clients</div><div class="line"> * to serve because of the PUSH side of BRPOPLPUSH. */</div><div class="line">void handleClientsBlockedOnLists(void) &#123;</div><div class="line">    while(listLength(server.ready_keys) != 0) &#123;</div><div class="line">        list *l;</div><div class="line"></div><div class="line">        /* Point server.ready_keys to a fresh list and save the current one</div><div class="line">         * locally. This way as we run the old list we are free to call</div><div class="line">         * signalListAsReady() that may push new elements in server.ready_keys</div><div class="line">         * when handling clients blocked into BRPOPLPUSH. */</div><div class="line">        l = server.ready_keys;</div><div class="line">        server.ready_keys = listCreate();</div><div class="line"></div><div class="line">        while(listLength(l) != 0) &#123;</div><div class="line">            listNode *ln = listFirst(l);</div><div class="line">            readyList *rl = ln-&gt;value;</div><div class="line"></div><div class="line">            /* First of all remove this key from db-&gt;ready_keys so that</div><div class="line">             * we can safely call signalListAsReady() against this key. */</div><div class="line">            dictDelete(rl-&gt;db-&gt;ready_keys,rl-&gt;key);</div><div class="line"></div><div class="line">            /* If the key exists and it&apos;s a list, serve blocked clients</div><div class="line">             * with data. */</div><div class="line">            robj *o = lookupKeyWrite(rl-&gt;db,rl-&gt;key);</div><div class="line">            if (o != NULL &amp;&amp; o-&gt;type == OBJ_LIST) &#123;</div><div class="line">                dictEntry *de;</div><div class="line"></div><div class="line">                /* We serve clients in the same order they blocked for</div><div class="line">                 * this key, from the first blocked to the last. */</div><div class="line">                de = dictFind(rl-&gt;db-&gt;blocking_keys,rl-&gt;key);</div><div class="line">                if (de) &#123;</div><div class="line">                    list *clients = dictGetVal(de);</div><div class="line">                    int numclients = listLength(clients);</div><div class="line"></div><div class="line">                    while(numclients--) &#123;</div><div class="line">                        listNode *clientnode = listFirst(clients);</div><div class="line">                        client *receiver = clientnode-&gt;value;</div><div class="line">                        robj *dstkey = receiver-&gt;bpop.target;</div><div class="line">                        int where = (receiver-&gt;lastcmd &amp;&amp;</div><div class="line">                                     receiver-&gt;lastcmd-&gt;proc == blpopCommand) ?</div><div class="line">                                    LIST_HEAD : LIST_TAIL;</div><div class="line">                        robj *value = listTypePop(o,where);</div><div class="line"></div><div class="line">                        if (value) &#123;</div><div class="line">                            /* Protect receiver-&gt;bpop.target, that will be</div><div class="line">                             * freed by the next unblockClient()</div><div class="line">                             * call. */</div><div class="line">                            if (dstkey) incrRefCount(dstkey);</div><div class="line">                            unblockClient(receiver);</div><div class="line"></div><div class="line">                            if (serveClientBlockedOnList(receiver,</div><div class="line">                                rl-&gt;key,dstkey,rl-&gt;db,value,</div><div class="line">                                where) == C_ERR)</div><div class="line">                            &#123;</div><div class="line">                                /* If we failed serving the client we need</div><div class="line">                                 * to also undo the POP operation. */</div><div class="line">                                    listTypePush(o,value,where);</div><div class="line">                            &#125;</div><div class="line"></div><div class="line">                            if (dstkey) decrRefCount(dstkey);</div><div class="line">                            decrRefCount(value);</div><div class="line">                        &#125; else &#123;</div><div class="line">                            break;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                if (listTypeLength(o) == 0) &#123;</div><div class="line">                    dbDelete(rl-&gt;db,rl-&gt;key);</div><div class="line">                &#125;</div><div class="line">                /* We don&apos;t call signalModifiedKey() as it was already called</div><div class="line">                 * when an element was pushed on the list. */</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            /* Free this item. */</div><div class="line">            decrRefCount(rl-&gt;key);</div><div class="line">            zfree(rl);</div><div class="line">            listDelNode(l,ln);</div><div class="line">        &#125;</div><div class="line">        listRelease(l); /* We have the new list on place at this point. */</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://harleylau.github.io/2018/05/10/Redis源码剖析-列表t-list实现/" data-id="cjhr1rzbm0004v368lz4jtpey" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/">redis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码/">源码</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Redis源码剖析-字符串t-string实现" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/09/Redis源码剖析-字符串t-string实现/" class="article-date">
  <time datetime="2018-05-09T02:12:07.000Z" itemprop="datePublished">2018-05-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/09/Redis源码剖析-字符串t-string实现/">Redis源码剖析--字符串t_string实现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>介绍完Redis的底层数据结构之后， 介绍我们平时使用Redis的时候可以直接看到五种数据结构：字符串、哈希、链表、集合和有序集合。</p>
<p>首先介绍字符串t_string的实现。</p>
<h2 id="字符串的结构"><a href="#字符串的结构" class="headerlink" title="字符串的结构"></a>字符串的结构</h2><p>上一篇文章讲到过字符串的底层实现其实有三种编码：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>编码</th>
<th>对象</th>
</tr>
</thead>
<tbody>
<tr>
<td>REDIS_STRING</td>
<td>REDIS_ENCODING_INT</td>
<td>使用整数值实现的字符串对象。</td>
</tr>
<tr>
<td>REDIS_STRING</td>
<td>REDIS_ENCODING_EMBSTR</td>
<td>使用 embstr 编码的简单动态字符串实现的字符串对象。</td>
</tr>
<tr>
<td>REDIS_STRING</td>
<td>REDIS_ENCODING_RAW</td>
<td>使用简单动态字符串实现的字符串对象。</td>
</tr>
</tbody>
</table>
<p>这三种类型分别对应的底层数据结构为int，embstr, sds。</p>
<p>字符串的定义代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">typedef struct redisObject &#123;</div><div class="line">    //对象的数据类型，字符串对象应该为 OBJ_STRING</div><div class="line">    unsigned type:4;        </div><div class="line">    //对象的编码类型，分别为OBJ_STRING、OBJ_ENCODING_INT或OBJ_ENCODING_EMBSTR</div><div class="line">    unsigned encoding:4;</div><div class="line">    //LRU_BITS为24位，最近一次的访问时间</div><div class="line">    unsigned lru:LRU_BITS; /* lru time (relative to server.lruclock) */</div><div class="line">    //引用计数</div><div class="line">    int refcount;</div><div class="line">    //指向底层数据实现的指针</div><div class="line">    void *ptr;</div><div class="line">&#125; robj;</div></pre></td></tr></table></figure>
<p>那么字符串具体用哪种编码实现呢？</p>
<p>如果一个字符串对象保存的是整数值， 并且这个整数值可以用 long 类型来表示， 那么字符串对象会将整数值保存在字符串对象结构的 ptr 属性里面（将 void* 转换成 long ）， 并将字符串对象的编码设置为 int 。</p>
<p>如果字符串对象保存的是一个字符串值， 并且这个字符串值的长度大于 39 字节， 那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值， 并将对象的编码设置为 raw 。</p>
<p>如果字符串对象保存的是一个字符串值， 并且这个字符串值的长度小于等于 39 字节， 那么字符串对象将使用 embstr 编码的方式来保存这个字符串值。</p>
<p>embstr 编码是专门用于保存短字符串的一种优化编码方式， 这种编码和 raw 编码一样， 都使用 redisObject 结构和 sdshdr 结构来表示字符串对象， 但 raw 编码会调用两次内存分配函数来分别创建 redisObject 结构和 sdshdr 结构， 而 embstr 编码则通过调用一次内存分配函数来分配一块连续的空间， 空间中依次包含 redisObject 和 sdshdr 两个结构</p>
<p>这边采用int和embstr编码的原因是：相较于raw格式的2次分配内存， 这两种格式只需要一次分配内存空间就可以；并且在回收的时候，也只需要调用一次内存释放函数。在存储小的字符串的时候更有速度优势。</p>
<h2 id="字符串命令"><a href="#字符串命令" class="headerlink" title="字符串命令"></a>字符串命令</h2><p>字符串支持的命令如下：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>命令描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>SET key value [ex 秒数][px 毫秒数][nx/xx]</td>
<td>设置指定key的值</td>
</tr>
<tr>
<td>GET key</td>
<td>获取指定key的值</td>
</tr>
<tr>
<td>APPEND key value</td>
<td>将value追加到指定key的值末尾</td>
</tr>
<tr>
<td>INCRBY key increment</td>
<td>将指定key的值加上增量increment</td>
</tr>
<tr>
<td>DECRBY key decrement</td>
<td>将指定key的值减去增量decrement</td>
</tr>
<tr>
<td>STRLEN key</td>
<td>返回指定key的值长度</td>
</tr>
<tr>
<td>SETRANGE key offset value</td>
<td>将value覆写到指定key的值上，从offset位开始</td>
</tr>
<tr>
<td>GETRANGE key start end</td>
<td>获取指定key中字符串的子串[start,end]</td>
</tr>
<tr>
<td>MSET key value [key value …]</td>
<td>一次设定多个key的值</td>
</tr>
<tr>
<td>MGET key1 [key2..]</td>
<td>一次获取多个key的值</td>
</tr>
</tbody>
</table>
<h2 id="字符串命令实现"><a href="#字符串命令实现" class="headerlink" title="字符串命令实现"></a>字符串命令实现</h2><h3 id="set命令的实现"><a href="#set命令的实现" class="headerlink" title="set命令的实现"></a>set命令的实现</h3><p>set命令用于设置指定的值，其具体命令格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">set key value [ex 秒数] [px 毫秒数] [nx/xx]</div></pre></td></tr></table></figure>
<p>其中，各个选项的含义如下：</p>
<ul>
<li>ex 设置指定的到期时间，单位为秒</li>
<li>px 设置指定的到期时间，单位为毫秒</li>
<li>nx 只有在key不存在的时候，才设置key的值</li>
<li>xx 只有key存在时，才对key进行设置操作</li>
</ul>
<p>set命令是调用setCommand实现的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">// 关于set命令的操作有三种宏定义</div><div class="line">#define OBJ_SET_NO_FLAGS 0    // 没有设定参数</div><div class="line">#define OBJ_SET_NX (1&lt;&lt;0)     // 只有键不存在时才设定其值</div><div class="line">#define OBJ_SET_XX (1&lt;&lt;1)      // 只有键存在时才设定其值</div><div class="line">#define OBJ_SET_EX (1&lt;&lt;2)       // ex属性，到期时间单位为秒</div><div class="line">#define OBJ_SET_PX (1&lt;&lt;3)     	// px属性，到期时间单位为毫秒</div><div class="line"></div><div class="line">/* set命令实现函数 */</div><div class="line">void setCommand(client *c) &#123;</div><div class="line">    int j;</div><div class="line">    robj *expire = NULL;</div><div class="line">    int unit = UNIT_SECONDS;</div><div class="line">  	// 用于标记ex/px和nx/xx命令参数</div><div class="line">    int flags = OBJ_SET_NO_FLAGS;</div><div class="line">	// 从命令串的第四个参数开始，查看其是否设定了ex/px和nx/xx</div><div class="line">    for (j = 3; j &lt; c-&gt;argc; j++) &#123;</div><div class="line">        char *a = c-&gt;argv[j]-&gt;ptr;</div><div class="line">        robj *next = (j == c-&gt;argc-1) ? NULL : c-&gt;argv[j+1];</div><div class="line">        if ((a[0] == &apos;n&apos; || a[0] == &apos;N&apos;) &amp;&amp;</div><div class="line">            (a[1] == &apos;x&apos; || a[1] == &apos;X&apos;) &amp;&amp; a[2] == &apos;\0&apos; &amp;&amp;</div><div class="line">            !(flags &amp; OBJ_SET_XX)) // 标记</div><div class="line">        &#123;</div><div class="line">            flags |= OBJ_SET_NX;</div><div class="line">        &#125; else if ((a[0] == &apos;x&apos; || a[0] == &apos;X&apos;) &amp;&amp;</div><div class="line">                   (a[1] == &apos;x&apos; || a[1] == &apos;X&apos;) &amp;&amp; a[2] == &apos;\0&apos; &amp;&amp;</div><div class="line">                   !(flags &amp; OBJ_SET_NX))</div><div class="line">        &#123;</div><div class="line">            flags |= OBJ_SET_XX;</div><div class="line">        &#125; else if ((a[0] == &apos;e&apos; || a[0] == &apos;E&apos;) &amp;&amp;</div><div class="line">                   (a[1] == &apos;x&apos; || a[1] == &apos;X&apos;) &amp;&amp; a[2] == &apos;\0&apos; &amp;&amp;</div><div class="line">                   !(flags &amp; OBJ_SET_PX) &amp;&amp; next)</div><div class="line">        &#123;</div><div class="line">            flags |= OBJ_SET_EX;</div><div class="line">            unit = UNIT_SECONDS;</div><div class="line">            expire = next;</div><div class="line">            j++;</div><div class="line">        &#125; else if ((a[0] == &apos;p&apos; || a[0] == &apos;P&apos;) &amp;&amp;</div><div class="line">                   (a[1] == &apos;x&apos; || a[1] == &apos;X&apos;) &amp;&amp; a[2] == &apos;\0&apos; &amp;&amp;</div><div class="line">                   !(flags &amp; OBJ_SET_EX) &amp;&amp; next)</div><div class="line">        &#123;</div><div class="line">            flags |= OBJ_SET_PX;</div><div class="line">            unit = UNIT_MILLISECONDS;</div><div class="line">            expire = next;</div><div class="line">            j++;</div><div class="line">        &#125; else &#123;</div><div class="line">          	// 如果不是上述参数，则需要报错，命令错误</div><div class="line">            addReply(c,shared.syntaxerr);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    // 判断value是否可以编码成整数，如果能则编码；反之不做处理</div><div class="line">    c-&gt;argv[2] = tryObjectEncoding(c-&gt;argv[2]);</div><div class="line">    // 调用底层函数进行键值对设定</div><div class="line">    setGenericCommand(c,flags,c-&gt;argv[1],c-&gt;argv[2],expire,unit,NULL,NULL);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>函数的一开始先检查传入的参数，看是否设定了过期时间以及过期时间的精度等，然后设置对应的flag， 最后根据flag调用setGenericCommand实现具体的操作。</p>
<p>接下去看一下setGenericCommand函数的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">//setGenericCommand()函数是以下命令: SET, SETEX, PSETEX, SETNX.的最底层实现</div><div class="line">//flags 可以是NX或XX，由上面的宏提供</div><div class="line">//expire 定义key的过期时间，格式由unit指定</div><div class="line">//ok_reply和abort_reply保存着回复client的内容，NX和XX也会改变回复</div><div class="line">//如果ok_reply为空，则使用 &quot;+OK&quot;</div><div class="line">//如果abort_reply为空，则使用 &quot;$-1&quot;</div><div class="line">void setGenericCommand(client *c, int flags, robj *key, robj *val, robj *expire, int unit, robj *ok_reply, robj *abort_reply) &#123;</div><div class="line">    long long milliseconds = 0; /* initialized to avoid any harmness warning */ //初始化，避免错误</div><div class="line"></div><div class="line">    //如果定义了key的过期时间</div><div class="line">    if (expire) &#123;</div><div class="line">        //从expire对象中取出值，保存在milliseconds中，如果出错发送默认的信息给client</div><div class="line">        if (getLongLongFromObjectOrReply(c, expire, &amp;milliseconds, NULL) != C_OK)</div><div class="line">            return;</div><div class="line">        // 如果过期时间小于等于0，则发送错误信息给client</div><div class="line">        if (milliseconds &lt;= 0) &#123;</div><div class="line">            addReplyErrorFormat(c,&quot;invalid expire time in %s&quot;,c-&gt;cmd-&gt;name);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        //如果unit的单位是秒，则需要转换为毫秒保存</div><div class="line">        if (unit == UNIT_SECONDS) milliseconds *= 1000;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //lookupKeyWrite函数是为执行写操作而取出key的值对象</div><div class="line">    //如果设置了NX(不存在)，并且在数据库中 找到 该key，或者</div><div class="line">    //设置了XX(存在)，并且在数据库中 没有找到 该key</div><div class="line">    //回复abort_reply给client</div><div class="line">    if ((flags &amp; OBJ_SET_NX &amp;&amp; lookupKeyWrite(c-&gt;db,key) != NULL) ||</div><div class="line">        (flags &amp; OBJ_SET_XX &amp;&amp; lookupKeyWrite(c-&gt;db,key) == NULL))</div><div class="line">    &#123;</div><div class="line">        addReply(c, abort_reply ? abort_reply : shared.nullbulk);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    //在当前db设置键为key的值为val</div><div class="line">    setKey(c-&gt;db,key,val);</div><div class="line"></div><div class="line">    //设置数据库为脏(dirty)，服务器每次修改一个key后，都会对脏键(dirty)增1</div><div class="line">    server.dirty++;</div><div class="line"></div><div class="line">    //设置key的过期时间</div><div class="line">    //mstime()返回毫秒为单位的格林威治时间</div><div class="line">    if (expire) setExpire(c-&gt;db,key,mstime()+milliseconds);</div><div class="line"></div><div class="line">    //发送&quot;set&quot;事件的通知，用于发布订阅模式，通知客户端接受发生的事件</div><div class="line">    notifyKeyspaceEvent(NOTIFY_STRING,&quot;set&quot;,key,c-&gt;db-&gt;id);</div><div class="line"></div><div class="line">    //发送&quot;expire&quot;事件通知</div><div class="line">    if (expire) notifyKeyspaceEvent(NOTIFY_GENERIC,</div><div class="line">        &quot;expire&quot;,key,c-&gt;db-&gt;id);</div><div class="line"></div><div class="line">    //设置成功，则向客户端发送ok_reply</div><div class="line">    addReply(c, ok_reply ? ok_reply : shared.ok);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="get命令的实现"><a href="#get命令的实现" class="headerlink" title="get命令的实现"></a>get命令的实现</h3><p>类似于set命令，get命令也是最终调用一个getGenericcommand的函数实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">//GET 命令的底层实现</div><div class="line">int getGenericCommand(client *c) &#123;</div><div class="line">    robj *o;</div><div class="line"></div><div class="line">    //lookupKeyReadOrReply函数是为执行读操作而返回key的值对象，找到返回该对象，找不到会发送信息给client</div><div class="line">    //如果key不存在直接，返回0表示GET命令执行成功</div><div class="line">    if ((o = lookupKeyReadOrReply(c,c-&gt;argv[1],shared.nullbulk)) == NULL)</div><div class="line">        return C_OK;</div><div class="line"></div><div class="line">    //如果key的值的编码类型不是字符串对象</div><div class="line">    if (o-&gt;type != OBJ_STRING) &#123;</div><div class="line">        addReply(c,shared.wrongtypeerr);    //返回类型错误的信息给client，返回-1表示GET命令执行失败</div><div class="line">        return C_ERR;</div><div class="line">    &#125; else &#123;</div><div class="line">        addReplyBulk(c,o);  //返回之前找到的对象作为回复给client，返回0表示GET命令执行成功</div><div class="line">        return C_OK;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="编码的转换"><a href="#编码的转换" class="headerlink" title="编码的转换"></a>编码的转换</h2><p>上边说到字符串类型底层其实有三种数据类型，这三种数据类型在特定的情况下也会互相转换。</p>
<h3 id="int编码转换为raw编码"><a href="#int编码转换为raw编码" class="headerlink" title="int编码转换为raw编码"></a>int编码转换为raw编码</h3><p>对于 int 编码的字符串对象来说， 如果我们向对象执行了一些命令， 使得这个对象保存的不再是整数值， 而是一个字符串值， 比如在最开始的数字类型后边执行了一个append的操作，加上了一串字符串，那么字符串对象的编码将从 int 变为 raw 。</p>
<h3 id="embstr编码转换为raw编码"><a href="#embstr编码转换为raw编码" class="headerlink" title="embstr编码转换为raw编码"></a>embstr编码转换为raw编码</h3><p>因为 Redis 没有为 embstr 编码的字符串对象编写任何相应的修改程序 （只有 int 编码的字符串对象和 raw 编码的字符串对象有这些程序）， 所以 embstr 编码的字符串对象实际上是只读的： 当我们对 embstr 编码的字符串对象执行任何修改命令时， 程序会先将对象的编码从 embstr 转换成 raw ， 然后再执行修改命令； 因为这个原因， embstr 编码的字符串对象在执行修改命令之后， 总会变成一个 raw 编码的字符串对象。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://harleylau.github.io/2018/05/09/Redis源码剖析-字符串t-string实现/" data-id="cjhr1rzbt0007v3682bzsz2pz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/">redis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码/">源码</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-tornado-websocket实现二维码扫描" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/12/tornado-websocket实现二维码扫描/" class="article-date">
  <time datetime="2018-02-12T04:17:11.000Z" itemprop="datePublished">2018-02-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/12/tornado-websocket实现二维码扫描/">tornado websocket实现二维码扫描</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Websocket-实现扫码二维码登录"><a href="#Websocket-实现扫码二维码登录" class="headerlink" title="Websocket 实现扫码二维码登录"></a>Websocket 实现扫码二维码登录</h2><p>首先简单的讲一下二维码实现登录的步骤：<br>1、网页端向服务端请求二维码，服务端生成一个二维码提供给网页端； 这个二维码其实是一个地址<br>2、客户端通过扫描网页端的二维码，跳转到二维码指向的地址， 然后通过鉴权验证机制，通知服务端鉴权的结果<br>3、客户端端根据不同的鉴权结果通知网页端做出相应的动作</p>
<p>对于步骤有了简单的概念之后， 我们可以显而易见的看到整个流程中主要需要解决的主要是两个问题：</p>
<p>1、如果处理用户的授权机制，保证用户权限的安全性</p>
<p>2、如何让网页端根据用户在客户端上的选择及时的做出不同的响应</p>
<p>针对第一个问题， 一方面，我们在生成二维码的时候，会同时生成一个唯一的session_id的标志，然后将其加入到二维码的url中， 当客户端扫描二维码跳转到指定地址的时候，能够根据session_id保证这个二维码是我们自己生成的； 另一方面， 客户端跳转过来的时候，会同时带上用户的id和用户的token， 通过id和token的验证保证用户的有效性，同时也能讲对应的session_id和用户id绑定，通知网页端是哪个用户扫描了这个二维码。</p>
<p>另外，多讲一点， 客户端扫描的同时带上来的用户id和用户的token，在实际使用的时候，我们是用户在登录的时候通过OAuth2.0的鉴权逻辑获取的， 所以能直接通过token验证安全性。</p>
<p>那么第二个问题， 如何及时的通知网页端做出变化呢。 这边一开始有两个方案： 一个是网页端采用轮询的机制，间隔一小段时间来询问服务端， 是否有用户扫描了这个二维码，以及扫描的结果； 另一个方案就是网页端在请求二维码的时候发起的就是一个websocket请求，这样网页端和服务端就能一直保持连接， 在客户端扫描二维码之后， 服务端就能够及时的通知到网页端，做到实时化。</p>
<p>两者的优缺点相信也比较明显， 在实际的开发过程中，我们采用了websocket的方式。 这边其实还有一个问题， 用户在客户端扫描二维码并授权了之后，如果通知到对应的网页端呢。 在网页端请求二维码的同时，我们会将当前的请求以session_id为key的方式进行注册， 当客户端扫描或者授权的时候，会将这个session_id带上来， 根据这个session_id就可以取到对应的请求，然后发回操作结果给网页端。</p>
<h2 id="tornado-websocket实现二维码扫描登录"><a href="#tornado-websocket实现二维码扫描登录" class="headerlink" title="tornado websocket实现二维码扫描登录"></a>tornado websocket实现二维码扫描登录</h2><h3 id="网页端请求二维码"><a href="#网页端请求二维码" class="headerlink" title="网页端请求二维码"></a>网页端请求二维码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">@router.Route(&apos;qrcode&apos;, name=&apos;ConnectQRcode&apos;)</div><div class="line">class ConnectQRcode(tornado.websocket.WebSocketHandler):</div><div class="line">    @tornado.gen.coroutine</div><div class="line">    def open(self):</div><div class="line">    	 #生成唯一的id，并带在url中</div><div class="line">        req_id = id(self)</div><div class="line">        url = &quot;https://xxxxxxx?uid=&quot; + uid + &quot;&amp;req_id=&quot; + str(req_id)</div><div class="line">        # 根据URL生成对应的二维码</div><div class="line">        q = qrcode.main.QRCode()</div><div class="line">        q.add_data(url)</div><div class="line">        q.make()</div><div class="line">        m = q.make_image()</div><div class="line">        png_name = &quot;static/&quot; + uid + &quot;.png&quot;</div><div class="line">        m.save(png_name)</div><div class="line">        # 注册回调函数</div><div class="line">        self.application.cart.register(req_id, self.callback)</div><div class="line">        # 返回二维码</div><div class="line">        self.write_message(&quot;https://xxxx/&quot; + png_name)</div><div class="line"></div><div class="line"></div><div class="line">    def on_close(self):</div><div class="line">    	# 关闭的时候删除掉注册的回调函数</div><div class="line">        self.application.cart.unregister(id(self), self.callback)</div><div class="line">        logging.info(&quot;remove register&quot;)</div><div class="line">        logging.info(&apos;WebSocket closed&apos;)</div><div class="line"></div><div class="line">    def callback(self, event, extra_info):</div><div class="line">        # 回调函数具体的操作</div><div class="line">        self.write_message(xxxx)</div></pre></td></tr></table></figure>
<h3 id="客户端扫描二维码"><a href="#客户端扫描二维码" class="headerlink" title="客户端扫描二维码"></a>客户端扫描二维码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@router.Route(&apos;/qrscan&apos;, name=&apos;qrscan&apos;)</div><div class="line">class ConnectQRscan(tornado.web.RequestHandler):</div><div class="line">    @tornado.gen.coroutine</div><div class="line">    def get(self):</div><div class="line">        try:</div><div class="line">            # 得到本次请求的req_id， 然后根据req_id调用对应的回调函数</div><div class="line">            req_id = self.get_argument(&apos;req_id&apos;, strip=False)</div><div class="line">            self.application.cart.notify(req_id, &quot;scan&quot;, &#123;&apos;req_id&apos;: req_id&#125;)</div><div class="line">            ret = &#123;&#125;</div><div class="line">        except Exception as e:</div><div class="line">            logging.error(&quot;qrscan error: %s&quot; % e)</div><div class="line">            ret = &#123;&apos;errorno&apos;: -1, &apos;errormsg&apos;: &quot;Error&quot;, &apos;data&apos;: None&#125;</div><div class="line">        self.write(ret)</div></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://harleylau.github.io/2018/02/12/tornado-websocket实现二维码扫描/" data-id="cjhr1rzco000qv368yyd16xhx" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/tornado/">tornado</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/websocket/">websocket</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/二维码/">二维码</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-tornado之WebSocket" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/12/tornado之WebSocket/" class="article-date">
  <time datetime="2018-02-12T03:29:39.000Z" itemprop="datePublished">2018-02-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/12/tornado之WebSocket/">tornado之WebSocket</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><p>WebSocket是HTML5开始提供的一种浏览器与服务器间进行全双工通讯的网络技术。 WebSocket通信协议于2011年被IETF定为标准RFC 6455，WebSocketAPI被W3C定为标准。 在WebSocket API中，浏览器和服务器只需要要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。</p>
<p>WebSocket是建立在 TCP 协议之上，与 HTTP 协议有着良好的兼容性。那么既然已经有了HTTP协议，为什么还需要一个WebSocket协议呢。这是因为HTTP只允许由客户端向服务端发送数据， 而无法直接由服务端主动向客户端推送信息。</p>
<p>WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端直接向客户端推送数据而不需要客户端进行请求，两者之间可以创建持久性的连接，并允许数据进行双向传送。WebSocket协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。</p>
<h3 id="1-Tornado的WebSocket模块"><a href="#1-Tornado的WebSocket模块" class="headerlink" title="1. Tornado的WebSocket模块"></a>1. Tornado的WebSocket模块</h3><p>Tornado提供支持WebSocket的模块是tornado.websocket，其中提供了一个WebSocketHandler类用来处理通讯。</p>
<p>WebSocketHandler.open()<br>当一个WebSocket连接建立后被调用。</p>
<p>WebSocketHandler.on_message(message)<br>当客户端发送消息message过来时被调用，注意此方法必须被重写。</p>
<p>WebSocketHandler.on_close()<br>当WebSocket连接关闭后被调用。</p>
<p>WebSocketHandler.write_message(message, binary=False)<br>向客户端发送消息messagea，message可以是字符串或字典（字典会被转为json字符串）。若binary为False，则message以utf8编码发送；二进制模式（binary=True）时，可发送任何字节码。</p>
<p>WebSocketHandler.close()<br>关闭WebSocket连接。</p>
<p>WebSocketHandler.check_origin(origin)<br>判断源origin，对于符合条件（返回判断结果为True）的请求源origin允许其连接，否则返回403。可以重写此方法来解决WebSocket的跨域请求（如始终return True）。</p>
<h3 id="2-WebSocket使用示例"><a href="#2-WebSocket使用示例" class="headerlink" title="2. WebSocket使用示例"></a>2. WebSocket使用示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class WebSocketHandler(tornado.websocket.WebSocketHandler):</div><div class="line">    def open(self):</div><div class="line">        self.application.cart.register(self.callback)</div><div class="line"></div><div class="line">    def on_close(self):</div><div class="line">        self.application.cart.unregister(self.callback)</div><div class="line"></div><div class="line">    def on_message(self):</div><div class="line">        pass</div><div class="line"></div><div class="line">    def callback(self,count):</div><div class="line">        self.write_message(&apos;&#123;&quot;count&quot;:&quot;%s&quot;&#125;&apos;%count)</div></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://harleylau.github.io/2018/02/12/tornado之WebSocket/" data-id="cjhr1rzct000vv368ynu31gn8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/tornado/">tornado</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Redis源码剖析-字符串对象" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/09/12/Redis源码剖析-字符串对象/" class="article-date">
  <time datetime="2017-09-12T01:58:09.000Z" itemprop="datePublished">2017-09-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/12/Redis源码剖析-字符串对象/">Redis源码剖析--字符串对象</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>上一篇文章里分析了，字符串对象在redis的底层结构上有三种存储格式，分别是： int 、 raw 或者 embstr</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>编码</th>
<th>对象</th>
</tr>
</thead>
<tbody>
<tr>
<td>REDIS_STRING</td>
<td>REDIS_ENCODING_INT</td>
<td>使用整数值实现的字符串对象。</td>
</tr>
<tr>
<td>REDIS_STRING</td>
<td>REDIS_ENCODING_EMBSTR</td>
<td>使用 embstr 编码的简单动态字符串实现的字符串对象。</td>
</tr>
<tr>
<td>REDIS_STRING</td>
<td>REDIS_ENCODING_RAW</td>
<td>使用简单动态字符串实现的字符串对象。</td>
</tr>
</tbody>
</table>
<p>那么这三种底层表示分别在什么情况下使用呢。</p>
<ul>
<li>如果一个字符串对象保存的是整数值， 并且这个整数值可以用 long 类型来表示， 那么字符串对象会将整数值保存在字符串对象结构的 ptr 属性里面， 并将字符串对象的编码设置为 REDIS_ENCODING_INT 。</li>
<li>如果字符串对象保存的是一个字符串值， 并且这个字符串值的长度大于 39 字节， 那么字符串对象将使用一个简单动态字符串（SDS，这个之前的文章也分析过）来保存这个字符串值， 并将对象的编码设置为 raw 。</li>
<li>如果字符串对象保存的是一个字符串值， 并且这个字符串值的长度小于等于 39 字节， 那么字符串对象将使用 embstr 编码的方式来保存这个字符串值。</li>
</ul>
<p>int的表示比较简单， raw的表示我们之前也分析过，这边多了一个embstr的方式，简单的分析一下。</p>
<p>正常的创建Redis的对象，一般都需要创建两次，一次创建RedisObject结构，另一次创建ptr指向的实际存储的内容。比如raw 编码， 使用 redisObject 结构和 sdshdr 结构来表示字符串对象， 但 raw 编码会调用两次内存分配函数来分别创建 redisObject 结构和 sdshdr 结构。但是在存储比较小的字符串的时候，这边用了个小技巧，embstr 编码通过调用一次内存分配函数来分配一块连续的空间， 空间中依次包含 redisObject 和 sdshdr 两个结构。</p>
<h2 id="编码的转换"><a href="#编码的转换" class="headerlink" title="编码的转换"></a>编码的转换</h2><p>int 和 embstr 在一定的条件下，会转化为 raw 格式的字符串。</p>
<p>此外， int 编码的字符串对象和 raw 编码的字符串对象都能够进行修改，但是 Redis 没有为 embstr 编码的字符串对象编写任何相应的修改程序 ， 所以 embstr 编码的字符串对象实际上是只读的。</p>
<p>当我们需要修改 embstr 编码的字符串， 程序会先将对象的编码从 embstr 转换成 raw ， 然后再执行修改命令； 所以 embstr 编码的字符串对象在执行修改命令之后， 总会变成一个 raw 编码的字符串对象。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>int 编码的实现方法</th>
<th>embstr 编码的实现方法</th>
<th>raw 编码的实现方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>SET</td>
<td>使用 int 编码保存值。</td>
<td>使用 embstr 编码保存值。</td>
<td>使用 raw 编码保存值。</td>
</tr>
<tr>
<td>GET</td>
<td>拷贝对象所保存的整数值， 将这个拷贝转换成字符串值， 然后向客户端返回这个字符串值。</td>
<td>直接向客户端返回字符串值。</td>
<td>直接向客户端返回字符串值。</td>
</tr>
<tr>
<td>APPEND</td>
<td>将对象转换成 raw 编码， 然后按 raw 编码的方式执行此操作。</td>
<td>将对象转换成 raw 编码， 然后按 raw 编码的方式执行此操作。</td>
<td>调用 sdscatlen 函数， 将给定字符串追加到现有字符串的末尾。</td>
</tr>
<tr>
<td>INCRBYFLOAT</td>
<td>取出整数值并将其转换成 long double 类型的浮点数， 对这个浮点数进行加法计算， 然后将得出的浮点数结果保存起来。</td>
<td>取出字符串值并尝试将其转换成 long double 类型的浮点数， 对这个浮点数进行加法计算， 然后将得出的浮点数结果保存起来。 如果字符串值不能被转换成浮点数， 那么向客户端返回一个错误。</td>
<td>取出字符串值并尝试将其转换成 long double 类型的浮点数， 对这个浮点数进行加法计算， 然后将得出的浮点数结果保存起来。 如果字符串值不能被转换成浮点数， 那么向客户端返回一个错误。</td>
</tr>
<tr>
<td>INCRBY</td>
<td>对整数值进行加法计算， 得出的计算结果会作为整数被保存起来。</td>
<td>embstr 编码不能执行此命令， 向客户端返回一个错误。</td>
<td>raw 编码不能执行此命令， 向客户端返回一个错误。</td>
</tr>
<tr>
<td>DECRBY</td>
<td>对整数值进行减法计算， 得出的计算结果会作为整数被保存起来。</td>
<td>embstr 编码不能执行此命令， 向客户端返回一个错误。</td>
<td>raw 编码不能执行此命令， 向客户端返回一个错误。</td>
</tr>
<tr>
<td>STRLEN</td>
<td>拷贝对象所保存的整数值， 将这个拷贝转换成字符串值， 计算并返回这个字符串值的长度。</td>
<td>调用 sdslen 函数， 返回字符串的长度。</td>
<td>调用 sdslen 函数， 返回字符串的长度。</td>
</tr>
<tr>
<td>SETRANGE</td>
<td>将对象转换成 raw 编码， 然后按 raw 编码的方式执行此命令。</td>
<td>将对象转换成 raw 编码， 然后按 raw 编码的方式执行此命令。</td>
<td>将字符串特定索引上的值设置为给定的字符。</td>
</tr>
<tr>
<td>GETRANGE</td>
<td>拷贝对象所保存的整数值， 将这个拷贝转换成字符串值， 然后取出并返回字符串指定索引上的字符。</td>
<td>直接取出并返回字符串指定索引上的字符。</td>
<td>直接取出并返回字符串指定索引上的字符。</td>
</tr>
</tbody>
</table>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://harleylau.github.io/2017/09/12/Redis源码剖析-字符串对象/" data-id="cjhr1rzbw0008v36884y21zh2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Redis源码剖析-对象Object" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/09/07/Redis源码剖析-对象Object/" class="article-date">
  <time datetime="2017-09-07T10:20:21.000Z" itemprop="datePublished">2017-09-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/07/Redis源码剖析-对象Object/">Redis源码剖析--对象Object</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>之前介绍的都是Redis的基础数据结构，比如简单动态字符串（SDS）、双端链表、字典、压缩列表、整数集合， 等等，不过Redis并没有直接用这些结构来实现键值对的数据库，而是对其进行了封装， 所有的键和值都是用对象Object来表示的。</p>
<p>Redis构建的对象分为5类， 字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象， 分别对应Redis操作中的string、list、hash、set和zset。</p>
<h2 id="对象的结构"><a href="#对象的结构" class="headerlink" title="对象的结构"></a>对象的结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">typedef struct redisObject &#123;</div><div class="line">    unsigned type:4;</div><div class="line">    unsigned encoding:4;</div><div class="line">    unsigned lru:LRU_BITS; // LRU_BITS为24</div><div class="line">    int refcount;</div><div class="line">    void *ptr;</div><div class="line">&#125; robj;</div></pre></td></tr></table></figure>
<p>type表示类型， encoding表示编码，prt表示指向底层数据实现的指针。</p>
<p>refcount用来实现基于引用计数技术的内存回收机制：通过引用计数技术实现了对象共享机制， 这一机制可以在适当的条件下， 通过让多个数据库键共享同一个对象来节约内存。</p>
<h3 id="类型type"><a href="#类型type" class="headerlink" title="类型type"></a>类型type</h3><p>上面说到Redis中有5中对象类型，对应的定义如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#define OBJ_STRING 0</div><div class="line">#define OBJ_LIST 1</div><div class="line">#define OBJ_SET 2</div><div class="line">#define OBJ_ZSET 3</div><div class="line">#define OBJ_HASH 4</div></pre></td></tr></table></figure>
<p>对于 Redis 数据库保存的键值对来说， 键总是一个字符串对象， 而值则可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象的其中一种。</p>
<h3 id="编码和底层实现"><a href="#编码和底层实现" class="headerlink" title="编码和底层实现"></a>编码和底层实现</h3><p>Redis对象的编码方式由encoding参数指定，也就是表示ptr指向的数据以何种数据结构作为底层实现。该字段也占用4个bit位。其取值和对应类型对应如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#define OBJ_ENCODING_RAW 0     /* Raw representation */</div><div class="line">#define OBJ_ENCODING_INT 1     /* Encoded as integer */</div><div class="line">#define OBJ_ENCODING_HT 2      /* Encoded as hash table */</div><div class="line">#define OBJ_ENCODING_ZIPMAP 3  /* Encoded as zipmap */</div><div class="line">#define OBJ_ENCODING_LINKEDLIST 4 /* Encoded as regular linked list */</div><div class="line">#define OBJ_ENCODING_ZIPLIST 5 /* Encoded as ziplist */</div><div class="line">#define OBJ_ENCODING_INTSET 6  /* Encoded as intset */</div><div class="line">#define OBJ_ENCODING_SKIPLIST 7  /* Encoded as skiplist */</div><div class="line">#define OBJ_ENCODING_EMBSTR 8  /* Embedded sds string encoding */</div><div class="line">#define OBJ_ENCODING_QUICKLIST 9 /* Encoded as linked list of ziplists */</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>编码常量</th>
<th>编码所对应的底层数据结构</th>
</tr>
</thead>
<tbody>
<tr>
<td>REDIS_ENCODING_INT</td>
<td>long 类型的整数</td>
</tr>
<tr>
<td>REDIS_ENCODING_EMBSTR</td>
<td>embstr 编码的简单动态字符串</td>
</tr>
<tr>
<td>REDIS_ENCODING_RAW</td>
<td>简单动态字符串</td>
</tr>
<tr>
<td>REDIS_ENCODING_HT</td>
<td>字典</td>
</tr>
<tr>
<td>REDIS_ENCODING_LINKEDLIST</td>
<td>双端链表</td>
</tr>
<tr>
<td>REDIS_ENCODING_ZIPLIST</td>
<td>压缩列表</td>
</tr>
<tr>
<td>REDIS_ENCODING_INTSET</td>
<td>整数集合</td>
</tr>
<tr>
<td>REDIS_ENCODING_SKIPLIST</td>
<td>跳跃表和字典</td>
</tr>
</tbody>
</table>
<p>Redis中的5中类型的对象，都对应着不止一种的底层实现</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>编码</th>
<th>对象</th>
</tr>
</thead>
<tbody>
<tr>
<td>REDIS_STRING</td>
<td>REDIS_ENCODING_INT</td>
<td>使用整数值实现的字符串对象。</td>
</tr>
<tr>
<td>REDIS_STRING</td>
<td>REDIS_ENCODING_EMBSTR</td>
<td>使用 embstr 编码的简单动态字符串实现的字符串对象。</td>
</tr>
<tr>
<td>REDIS_STRING</td>
<td>REDIS_ENCODING_RAW</td>
<td>使用简单动态字符串实现的字符串对象。</td>
</tr>
<tr>
<td>REDIS_LIST</td>
<td>REDIS_ENCODING_ZIPLIST</td>
<td>使用压缩列表实现的列表对象。</td>
</tr>
<tr>
<td>REDIS_LIST</td>
<td>REDIS_ENCODING_LINKEDLIST</td>
<td>使用双端链表实现的列表对象。</td>
</tr>
<tr>
<td>REDIS_HASH</td>
<td>REDIS_ENCODING_ZIPLIST</td>
<td>使用压缩列表实现的哈希对象。</td>
</tr>
<tr>
<td>REDIS_HASH</td>
<td>REDIS_ENCODING_HT</td>
<td>使用字典实现的哈希对象。</td>
</tr>
<tr>
<td>REDIS_SET</td>
<td>REDIS_ENCODING_INTSET</td>
<td>使用整数集合实现的集合对象。</td>
</tr>
<tr>
<td>REDIS_SET</td>
<td>REDIS_ENCODING_HT</td>
<td>使用字典实现的集合对象。</td>
</tr>
<tr>
<td>REDIS_ZSET</td>
<td>REDIS_ENCODING_ZIPLIST</td>
<td>使用压缩列表实现的有序集合对象。</td>
</tr>
<tr>
<td>REDIS_ZSET</td>
<td>REDIS_ENCODING_SKIPLIST</td>
<td>使用跳跃表和字典实现的有序集合对象。</td>
</tr>
</tbody>
</table>
<p>通过encoding参数来区分底层的实现，这样既灵活，也能节省内存。比如hash表的实现的时候，当元素比较少的时候，可以用压缩列表来实现；当元素不断增长，压缩列表失去优势的时候，就将其转化成hash table来实现。</p>
<p>之后几篇分别介绍 Redis 中的五种不同类型的对象， 说明这些对象底层所使用的编码方式。 由于每种对象类型都有不止一种底层结构，所以同时列出对象从一种编码转换成另一种编码所需的条件， 以及同一个命令在多种不同编码上的实现方法。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://harleylau.github.io/2017/09/07/Redis源码剖析-对象Object/" data-id="cjhr1rzc1000dv368dh1fqjn3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/">redis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码/">源码</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-tornado-打印block日志" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/09/07/tornado-打印block日志/" class="article-date">
  <time datetime="2017-09-07T03:21:02.000Z" itemprop="datePublished">2017-09-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/07/tornado-打印block日志/">tornado--打印block日志</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Tornado在使用过程，碰到过性能瓶颈。 当碰到Tornado中有比较耗时的任务的时候，请求一多就会阻塞整个服务。这个时候就需要查看到底是什么任务阻塞了服务，然后针对性的进行优化。</p>
<p>Tornado使用logging打印日志，我们可以指定当某个请求的处理时间超过设定时间的时候，打印这个请求的stack trace。</p>
<p>源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">def set_blocking_log_threshold(self, seconds):</div><div class="line">       &quot;&quot;&quot;Logs a stack trace if the `IOLoop` is blocked for more than</div><div class="line">       ``s`` seconds.</div><div class="line"></div><div class="line">       Equivalent to ``set_blocking_signal_threshold(seconds,</div><div class="line">       self.log_stack)``</div><div class="line">       &quot;&quot;&quot;</div><div class="line">       self.set_blocking_signal_threshold(seconds, self.log_stack)</div></pre></td></tr></table></figure>
<p>如何使用呢，只需要在启动服务的时候设置block的时间即可，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line"></div><div class="line">    app = create_app()</div><div class="line"></div><div class="line">    server = tornado.httpserver.HTTPServer(app)</div><div class="line">    server.listen(options.port)</div><div class="line">    io_loop = tornado.ioloop.IOLoop.instance()</div><div class="line">    io_loop.set_blocking_log_threshold(0.5)</div><div class="line">    io_loop.start()</div></pre></td></tr></table></figure>
<p>如果某个请求的处理时间超过0.5秒，就会打印该请求的栈。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://harleylau.github.io/2017/09/07/tornado-打印block日志/" data-id="cjhr1rzcx000xv368qvyze87g" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/tornado/">tornado</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Redis源码剖析-压缩列表" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/09/05/Redis源码剖析-压缩列表/" class="article-date">
  <time datetime="2017-09-05T01:51:55.000Z" itemprop="datePublished">2017-09-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/05/Redis源码剖析-压缩列表/">Redis源码剖析--压缩列表</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>压缩列表（ziplist）是列表键和哈希键的底层实现之一。<br>Redis的列表键，哈希键，有序集合的底层实现都用到了ziplist。</p>
<p>当列表键中包含比较少的元素，并且元素都是数字或者比较小的字符串的时候， redis会用压缩列表来作为列表键的底层实现。</p>
<p>当哈希键的键和值都是比较小的整数或者较短的字符的时候，也是用压缩列表来作为底层实现。 因为压缩列表也能够节省内存。</p>
<h2 id="压缩列表结构"><a href="#压缩列表结构" class="headerlink" title="压缩列表结构"></a>压缩列表结构</h2><p>压缩列表的结构如下：</p>
<p><img src="/2017/09/05/Redis源码剖析-压缩列表/ziplist.png" alt="压缩列表结构"></p>
<p>列表头包括三部分内容，分别是zlbytes，zltail，zllen</p>
<ul>
<li>zlbytes： 记录整个压缩列表占用的内存字节数：在对压缩列表进行内存重分配， 或者计算 zlend 的位置时使用。</li>
<li>zltail：记录压缩列表表尾节点距离压缩列表的起始地址有多少字节： 通过这个偏移量，程序无须遍历整个压缩列表就可以确定表尾节点的地址。</li>
<li>zllen：记录了压缩列表包含的节点数量： 当这个属性的值小于 UINT16_MAX （65535）时， 这个属性的值就是压缩列表包含节点的数量； 当这个值等于 UINT16_MAX 时， 节点的真实数量需要遍历整个压缩列表才能计算得出。</li>
</ul>
<p>压缩列表中间一次保存着各个列表项entry。</p>
<p>压缩列表尾部的zlend则表示压缩列表结束，其值固定为0xFF。</p>
<h3 id="压缩列表结点"><a href="#压缩列表结点" class="headerlink" title="压缩列表结点"></a>压缩列表结点</h3><p>先看结点的数据结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">typedef struct zlentry &#123;</div><div class="line">    unsigned int prevrawlensize, prevrawlen; // 前置节点长度和编码所需长度</div><div class="line">    unsigned int lensize, len; // 当前节点长度和编码所需长度</div><div class="line">    unsigned int headersize; // 头的大小</div><div class="line">    unsigned char encoding; // 编码类型</div><div class="line">    unsigned char *p; // 数据部分</div><div class="line">&#125; zlentry;</div></pre></td></tr></table></figure>
<p>每个压缩列表节点都由 previous_entry_length 、 encoding 、 content 三个部分组成。</p>
<h4 id="previous-entry-length"><a href="#previous-entry-length" class="headerlink" title="previous_entry_length"></a>previous_entry_length</h4><p>节点的 previous_entry_length 记录了压缩列表中前一个节点的长度。</p>
<p>previous_entry_length 属性的长度可以是 1 字节或者 5 字节：</p>
<ul>
<li>如果前一节点的长度小于 254 字节， 那么 previous_entry_length 属性的长度为 1 字节： 前一节点的长度就保存在这一个字节里面。</li>
<li>如果前一节点的长度大于等于 254 字节， 那么 previous_entry_length 属性的长度为 5 字节： 其中属性的第一字节会被设置为 0xFE （十进制值 254）， 而之后的四个字节则用于保存前一节点的长度。</li>
</ul>
<p>压缩列表zltail和previous_entry_length的存在，我们能够轻松得到一个列表的尾部，然后从尾部实现向前遍历整个压缩列表。</p>
<h4 id="encoding"><a href="#encoding" class="headerlink" title="encoding"></a>encoding</h4><p>压缩列表能够保存字节数组和整数，当读取压缩列表的时候，如何区分当前的结点存储的是字节数组还是整数呢，就需要靠encoding字段来判断。</p>
<h5 id="1、字节数组"><a href="#1、字节数组" class="headerlink" title="1、字节数组"></a>1、字节数组</h5><p>保存字节数组的时候，encoding字段可以是一字节、两字节或者五字节长， 值的最高位为 00 、 01 或者 10 ，数组的长度由编码除去最高两位之后的其他位记录。</p>
<table>
<thead>
<tr>
<th>编码</th>
<th>编码长度</th>
<th>content 属性保存的值</th>
</tr>
</thead>
<tbody>
<tr>
<td>00bbbbbb</td>
<td>1 字节</td>
<td>长度小于等于 63 字节的字节数组。</td>
</tr>
<tr>
<td>01bbbbbb xxxxxxxx</td>
<td>2 字节</td>
<td>长度小于等于 16383 字节的字节数组。</td>
</tr>
<tr>
<td>10<strong>__</strong> aaaaaaaa bbbbbbbb cccccccc dddddddd</td>
<td>5 字节</td>
<td>长度小于等于 4294967295 的字节数组。</td>
</tr>
</tbody>
</table>
<p>如上表所示，三种长度的字节数组分别用不同长度的encoding字段来表示，用来节省空间。 而encoding的前两位用来标记encoding本身的类型。</p>
<h5 id="2、整数"><a href="#2、整数" class="headerlink" title="2、整数"></a>2、整数</h5><p>保存整数的时候，encoding字段为一字节长， 值的最高位以 11 开头。 整数值的类型和长度由编码除去最高两位之后的其他位记录。</p>
<table>
<thead>
<tr>
<th>编码</th>
<th>编码长度</th>
<th>content 属性保存的值</th>
</tr>
</thead>
<tbody>
<tr>
<td>11000000</td>
<td>1 字节</td>
<td>int16_t 类型的整数。</td>
</tr>
<tr>
<td>11010000</td>
<td>1 字节</td>
<td>int32_t 类型的整数。</td>
</tr>
<tr>
<td>11100000</td>
<td>1 字节</td>
<td>int64_t 类型的整数。</td>
</tr>
<tr>
<td>11110000</td>
<td>1 字节</td>
<td>24 位有符号整数。</td>
</tr>
<tr>
<td>11111110</td>
<td>1 字节</td>
<td>8 位有符号整数。</td>
</tr>
<tr>
<td>1111xxxx</td>
<td>1 字节</td>
<td>使用这一编码的节点没有相应的 content 属性， 因为编码本身的 xxxx 四个位已经保存了一个介于 0 和 12 之间的值， 所以它无须 content 属性。</td>
</tr>
</tbody>
</table>
<p>当encoding最前两位字段为11的时候，表示当前结点为整数。 同时encoding的后几位用来表示不同的整数类型。可以看到后几位中用000000表示int16_t 类型的整数， 用010000表示int32_t 类型的整数， 用100000表示int64_t 类型的整数。</p>
<p>可以注意到，为了进一步节省内存，当编码为1111xxxx时，表示没有内容部分，xxxx已经存放了当前的整数值，包括整数0~12，即xxxx可以表示0000~1101。这样就节省了content的内存空间。这边编码为11111111代表ziplist的结尾。</p>
<h3 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h3><p>由于每个压缩列表的结点保存了上一个结点的大小，所以当前结点的变化有可能引起下一个结点的变化。如果前一节点的长度小于 254 字节， 那么 previous_entry_length 属性需要用 1 字节长的空间来保存这个长度值； 如果超过了254字节，这个属性值就需要 5 个字节的长度来保存。</p>
<p>所以最坏的情况下，压缩列表中某一个结点的更新，会引起所有结点的一个更新操作，就是所谓的连锁更新。</p>
<p>此外，插入或者删除结点也有可能引起连锁更新的操作。不过虽然连锁更新带来的消耗很大，但是仍旧可以放心的使用压缩列表，因为连锁更新引起的条件比较苛刻，概率比较小。 首先， 压缩列表里要恰好有多个连续的、长度介于 250 字节至 253 字节之间的节点， 连锁更新才有可能被引发， 在实际中， 这种情况并不多见；<br>其次， 即使出现连锁更新， 但只要被更新的节点数量不多， 就不会对性能造成任何影响： 比如说， 对三五个节点进行连锁更新是绝对不会影响性能的。</p>
<h2 id="压缩列表基本操作"><a href="#压缩列表基本操作" class="headerlink" title="压缩列表基本操作"></a>压缩列表基本操作</h2><h3 id="创建新的压缩列表"><a href="#创建新的压缩列表" class="headerlink" title="创建新的压缩列表"></a>创建新的压缩列表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/* Create a new empty ziplist. */</div><div class="line">unsigned char *ziplistNew(void) &#123;</div><div class="line">    // 空ziplist的大小为11个字节，头部10字节，尾部1字节</div><div class="line">    unsigned int bytes = ZIPLIST_HEADER_SIZE+1;</div><div class="line">    // 开辟空间</div><div class="line">    unsigned char *zl = zmalloc(bytes);</div><div class="line">    // 设定压缩列表的大小</div><div class="line">    ZIPLIST_BYTES(zl) = intrev32ifbe(bytes);</div><div class="line">    // 设置尾结点相对头部的偏移量</div><div class="line">    ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(ZIPLIST_HEADER_SIZE);</div><div class="line">    // 压缩列表结点数为0</div><div class="line">    ZIPLIST_LENGTH(zl) = 0;</div><div class="line">    // 设定尾部一个字节位0xFF</div><div class="line">    zl[bytes-1] = ZIP_END;</div><div class="line">    return zl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="插入结点"><a href="#插入结点" class="headerlink" title="插入结点"></a>插入结点</h3><p>由于连锁更新的存在，插入结点的复杂度平均 O(N) ，最坏 O(N^2)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div></pre></td><td class="code"><pre><div class="line">// ziplist插入节点只能往头或者尾部插入</div><div class="line">// zl: 待插入的ziplist</div><div class="line">// s，slen: 待插入节点和其长度</div><div class="line">// where: 带插入的位置，0代表头部插入，1代表尾部插入</div><div class="line">unsigned char *ziplistPush(unsigned char *zl, unsigned char *s, unsigned int slen, int where) &#123;</div><div class="line">    unsigned char *p;</div><div class="line">    // 获取插入的位置</div><div class="line">    p = (where == ZIPLIST_HEAD) ? ZIPLIST_ENTRY_HEAD(zl) : ZIPLIST_ENTRY_END(zl);</div><div class="line">    // 执行具体的插入过程</div><div class="line">    return __ziplistInsert(zl,p,s,slen);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Insert item at &quot;p&quot;. */</div><div class="line">unsigned char *__ziplistInsert(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen) &#123;</div><div class="line">    size_t curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), reqlen;</div><div class="line">    unsigned int prevlensize, prevlen = 0; // 前置节点长度和编码该长度值所需的长度</div><div class="line">    size_t offset;</div><div class="line">    int nextdiff = 0;</div><div class="line">    unsigned char encoding = 0;</div><div class="line">    long long value = 123456789; /* 为了防止警告，进行初始化；用一个比较特殊的值以便能够方便的观察到不恰当的使用 */</div><div class="line">    zlentry tail;</div><div class="line"></div><div class="line">    /* Find out prevlen for the entry that is inserted. */</div><div class="line">    if (p[0] != ZIP_END) &#123;</div><div class="line">        // 如果不是压缩列表的结束标志，说明p指向了一个已存在的结点</div><div class="line">        // 解码得到p的前置结点和长度</div><div class="line">        ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);</div><div class="line">    &#125; else &#123;</div><div class="line">        // 如果p指向列表末端，表示列表为空</div><div class="line">        unsigned char *ptail = ZIPLIST_ENTRY_TAIL(zl);</div><div class="line">        if (ptail[0] != ZIP_END) &#123;</div><div class="line">            prevlen = zipRawEntryLength(ptail);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* See if the entry can be encoded */</div><div class="line">    // 判断是否能够编码为整数</div><div class="line">    if (zipTryEncoding(s,slen,&amp;value,&amp;encoding)) &#123;</div><div class="line">        /* &apos;encoding&apos; is set to the appropriate integer encoding */</div><div class="line">        reqlen = zipIntSize(encoding);</div><div class="line">    &#125; else &#123;</div><div class="line">        /* &apos;encoding&apos; is untouched, however zipStoreEntryEncoding will use the</div><div class="line">         * string length to figure out how to encode it. */</div><div class="line">        // 编码为字节数组</div><div class="line">        reqlen = slen;</div><div class="line">    &#125;</div><div class="line">    /* We need space for both the length of the previous entry and</div><div class="line">     * the length of the payload. */</div><div class="line">    // 加上前置结点的编码长度和当前结点的编码长度</div><div class="line">    reqlen += zipStorePrevEntryLength(NULL,prevlen);</div><div class="line">    reqlen += zipStoreEntryEncoding(NULL,encoding,slen);</div><div class="line"></div><div class="line">    /* When the insert position is not equal to the tail, we need to</div><div class="line">     * make sure that the next entry can hold this entry&apos;s length in</div><div class="line">     * its prevlen field. */</div><div class="line">    // 如果不是插入到列表的末端，都需要判断下一个结点是否能存放新节点的长度编码</div><div class="line">    // nextdiff保存新旧编码之间的字节大小差，如果这个值大于0</div><div class="line">    // 那就说明当前p指向的节点的header进行扩展</div><div class="line">    int forcelarge = 0;</div><div class="line">    nextdiff = (p[0] != ZIP_END) ? zipPrevLenByteDiff(p,reqlen) : 0;</div><div class="line">    if (nextdiff == -4 &amp;&amp; reqlen &lt; 4) &#123;</div><div class="line">        nextdiff = 0;</div><div class="line">        forcelarge = 1;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* Store offset because a realloc may change the address of zl. */</div><div class="line">    // 保存偏移量</div><div class="line">    offset = p-zl;</div><div class="line">    // 重新分配空间，curlen当前列表的长度</div><div class="line">    // reqlen 新节点的全部长度</div><div class="line">    // nextdiff 新节点的后继节点扩展header的长度</div><div class="line">    zl = ziplistResize(zl,curlen+reqlen+nextdiff);</div><div class="line">    // 根据新的压缩列表地址得到新的p的地址</div><div class="line">    p = zl+offset;</div><div class="line"></div><div class="line">    /* Apply memory move when necessary and update tail offset. */</div><div class="line">    if (p[0] != ZIP_END) &#123;</div><div class="line">        // 如果不是表尾插入，需要更新表尾的偏移地址</div><div class="line">        /* Subtract one because of the ZIP_END bytes */</div><div class="line">        memmove(p+reqlen,p-nextdiff,curlen-offset-1+nextdiff);</div><div class="line"></div><div class="line">        /* Encode this entry&apos;s raw length in the next entry. */</div><div class="line">        // 编码新结点的长度到下一个结点中</div><div class="line">        if (forcelarge)</div><div class="line">            zipStorePrevEntryLengthLarge(p+reqlen,reqlen);</div><div class="line">        else</div><div class="line">            zipStorePrevEntryLength(p+reqlen,reqlen);</div><div class="line"></div><div class="line">        /* Update offset for tail */</div><div class="line">        ZIPLIST_TAIL_OFFSET(zl) =</div><div class="line">            intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+reqlen);</div><div class="line"></div><div class="line">        /* When the tail contains more than one entry, we need to take</div><div class="line">         * &quot;nextdiff&quot; in account as well. Otherwise, a change in the</div><div class="line">         * size of prevlen doesn&apos;t have an effect on the *tail* offset. */</div><div class="line">        zipEntry(p+reqlen, &amp;tail);</div><div class="line">        if (p[reqlen+tail.headersize+tail.len] != ZIP_END) &#123;</div><div class="line">            ZIPLIST_TAIL_OFFSET(zl) =</div><div class="line">                intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+nextdiff);</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        /* This element will be the new tail. */</div><div class="line">        ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(p-zl);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 如果nextdiff不等于0， 下一个结点的头部需要进行扩展</div><div class="line">    if (nextdiff != 0) &#123;</div><div class="line">        offset = p-zl;</div><div class="line">        zl = __ziplistCascadeUpdate(zl,p+reqlen);</div><div class="line">        p = zl+offset;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* Write the entry */</div><div class="line">    // 将新节点前置节点的长度写入新节点的header</div><div class="line">    p += zipStorePrevEntryLength(p,prevlen);</div><div class="line">    // 编码新结点</div><div class="line">    p += zipStoreEntryEncoding(p,encoding,slen);</div><div class="line">    if (ZIP_IS_STR(encoding)) &#123;</div><div class="line">        memcpy(p,s,slen);</div><div class="line">    &#125; else &#123;</div><div class="line">        zipSaveInteger(p,value,encoding);</div><div class="line">    &#125;</div><div class="line">    ZIPLIST_INCR_LENGTH(zl,1);</div><div class="line">    return zl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="查找结点"><a href="#查找结点" class="headerlink" title="查找结点"></a>查找结点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">/* 寻找节点值和 vstr 相等的列表节点，并返回该节点的指针。</div><div class="line"> * 每次比对之前都跳过 skip 个节点。</div><div class="line"> * 如果找不到相应的节点，则返回 NULL 。 */</div><div class="line">unsigned char *ziplistFind(unsigned char *p, unsigned char *vstr, unsigned int vlen, unsigned int skip) &#123;</div><div class="line">    int skipcnt = 0;</div><div class="line">    unsigned char vencoding = 0;</div><div class="line">    long long vll = 0;</div><div class="line"></div><div class="line">    // 循环直到碰到结束标志</div><div class="line">    while (p[0] != ZIP_END) &#123;</div><div class="line">        unsigned int prevlensize, encoding, lensize, len;</div><div class="line">        unsigned char *q;</div><div class="line"></div><div class="line">        // 解码得到前置结点的长度</div><div class="line">        ZIP_DECODE_PREVLENSIZE(p, prevlensize);</div><div class="line">        // 当前结点的长度</div><div class="line">        ZIP_DECODE_LENGTH(p + prevlensize, encoding, lensize, len);</div><div class="line">        q = p + prevlensize + lensize;</div><div class="line"></div><div class="line">        if (skipcnt == 0) &#123;</div><div class="line">            /* Compare current entry with specified entry */</div><div class="line">            // 如果是字节数组，直接比较</div><div class="line">            if (ZIP_IS_STR(encoding)) &#123;</div><div class="line">                if (len == vlen &amp;&amp; memcmp(q, vstr, vlen) == 0) &#123;</div><div class="line">                    return p;</div><div class="line">                &#125;</div><div class="line">            &#125; else &#123;</div><div class="line">                /* 查看目标值是否能被编码，只会在第一次循环的时候检查；</div><div class="line">                 * 检查一次之后vencoding会被置为非0 */</div><div class="line">                if (vencoding == 0) &#123;</div><div class="line">                    if (!zipTryEncoding(vstr, vlen, &amp;vll, &amp;vencoding)) &#123;</div><div class="line">                        /* 如果不能被编码，设置格式为UCHAR_MAX ， 下次不会再检查*/</div><div class="line">                        vencoding = UCHAR_MAX;</div><div class="line">                    &#125;</div><div class="line">                    /* Must be non-zero by now */</div><div class="line">                    assert(vencoding);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                /* Compare current entry with specified entry, do it only</div><div class="line">                 * if vencoding != UCHAR_MAX because if there is no encoding</div><div class="line">                 * possible for the field it can&apos;t be a valid integer. */</div><div class="line">                if (vencoding != UCHAR_MAX) &#123;</div><div class="line">                    long long ll = zipLoadInteger(q, encoding);</div><div class="line">                    if (ll == vll) &#123;</div><div class="line">                        return p;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            /* Reset skip count */</div><div class="line">            skipcnt = skip;</div><div class="line">        &#125; else &#123;</div><div class="line">            /* Skip entry */</div><div class="line">            skipcnt--;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        /* Move to next entry */</div><div class="line">        // 后移指针，指向后置节点</div><div class="line">        p = q + len;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return NULL;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="删除结点"><a href="#删除结点" class="headerlink" title="删除结点"></a>删除结点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line">// 删除给定节点，输入压缩列表zl和指向删除节点的指针p</div><div class="line">unsigned char *ziplistDelete(unsigned char *zl, unsigned char **p) &#123;</div><div class="line">    size_t offset = *p-zl;</div><div class="line">    // 调用底层函数__ziplistDelete进行删除操作</div><div class="line">    zl = __ziplistDelete(zl,*p,1);</div><div class="line">    // 删除操作可能会改变zl，因为会重新分配内存</div><div class="line">    *p = zl+offset;</div><div class="line">    return zl;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* 从位置 p 开始，连续删除 num 个节点。</div><div class="line"> * 函数的返回值为处理删除操作之后的 ziplist */</div><div class="line">unsigned char *__ziplistDelete(unsigned char *zl, unsigned char *p, unsigned int num) &#123;</div><div class="line">    unsigned int i, totlen, deleted = 0;</div><div class="line">    size_t offset;</div><div class="line">    int nextdiff = 0;</div><div class="line">    zlentry first, tail;</div><div class="line"></div><div class="line">    zipEntry(p, &amp;first);</div><div class="line">    // 计算被删除节点的总个数</div><div class="line">    for (i = 0; p[0] != ZIP_END &amp;&amp; i &lt; num; i++) &#123;</div><div class="line">        p += zipRawEntryLength(p);</div><div class="line">        deleted++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // totlen 是所有被删除节点总共占用的内存字节数</div><div class="line">    totlen = p-first.p; /* Bytes taken by the element(s) to delete. */</div><div class="line">    if (totlen &gt; 0) &#123;</div><div class="line">        if (p[0] != ZIP_END) &#123;</div><div class="line">            // 不是尾结点，表示被删除节点之后仍然有节点存在</div><div class="line">            </div><div class="line">            // 因为位于被删除范围之后的第一个节点的 header 部分的大小</div><div class="line">            // 可能容纳不了新的前置节点，所以需要计算新旧前置节点之间的字节数差</div><div class="line">            nextdiff = zipPrevLenByteDiff(p,first.prevrawlen);</div><div class="line"></div><div class="line">            /* Note that there is always space when p jumps backward: if</div><div class="line">             * the new previous entry is large, one of the deleted elements</div><div class="line">             * had a 5 bytes prevlen header, so there is for sure at least</div><div class="line">             * 5 bytes free and we need just 4. */</div><div class="line">            // 如果有需要的话，将指针 p 后退 nextdiff 字节，为新 header 空出空间</div><div class="line">            // 由于会删除之前的结点，所以肯定会有足够的空间用来扩展</div><div class="line">            p -= nextdiff;</div><div class="line">            // 将 first 的前置节点的长度编码至 p 中</div><div class="line">            zipStorePrevEntryLength(p,first.prevrawlen);</div><div class="line"></div><div class="line">            /* Update offset for tail */</div><div class="line">            ZIPLIST_TAIL_OFFSET(zl) =</div><div class="line">                intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))-totlen);</div><div class="line"></div><div class="line">            /* When the tail contains more than one entry, we need to take</div><div class="line">             * &quot;nextdiff&quot; in account as well. Otherwise, a change in the</div><div class="line">             * size of prevlen doesn&apos;t have an effect on the *tail* offset. */</div><div class="line">            // 如果被删除节点之后，有多于一个节点</div><div class="line">            // 那么程序需要将 nextdiff 记录的字节数也计算到表尾偏移量中</div><div class="line">            // 这样才能让表尾偏移量正确对齐表尾节点</div><div class="line">            zipEntry(p, &amp;tail);</div><div class="line">            if (p[tail.headersize+tail.len] != ZIP_END) &#123;</div><div class="line">                ZIPLIST_TAIL_OFFSET(zl) =</div><div class="line">                   intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+nextdiff);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            /* Move tail to the front of the ziplist */</div><div class="line">            // 从表尾向表头移动数据，覆盖被删除节点的数据</div><div class="line">            memmove(first.p,p,</div><div class="line">                intrev32ifbe(ZIPLIST_BYTES(zl))-(p-zl)-1);</div><div class="line">        &#125; else &#123;</div><div class="line">            /* The entire tail was deleted. No need to move memory. */</div><div class="line">            // 执行这里，表示被删除节点之后已经没有其他节点了， 不需要移动结点</div><div class="line">            ZIPLIST_TAIL_OFFSET(zl) =</div><div class="line">                intrev32ifbe((first.p-zl)-first.prevrawlen);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        /* Resize and update length */</div><div class="line">        // 缩小并更新 ziplist 的长度</div><div class="line">        offset = first.p-zl;</div><div class="line">        zl = ziplistResize(zl, intrev32ifbe(ZIPLIST_BYTES(zl))-totlen+nextdiff);</div><div class="line">        ZIPLIST_INCR_LENGTH(zl,-deleted);</div><div class="line">        p = zl+offset;</div><div class="line"></div><div class="line">        /* When nextdiff != 0, the raw length of the next entry has changed, so</div><div class="line">         * we need to cascade the update throughout the ziplist */</div><div class="line">        // 如果 p 所指向的节点的大小已经变更，那么进行级联更新</div><div class="line">        // 检查 p 之后的所有节点是否符合 ziplist 的编码要求</div><div class="line">        if (nextdiff != 0)</div><div class="line">            zl = __ziplistCascadeUpdate(zl,p);</div><div class="line">    &#125;</div><div class="line">    return zl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://harleylau.github.io/2017/09/05/Redis源码剖析-压缩列表/" data-id="cjhr1rzbp0005v368p5xpljrj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/">redis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码/">源码</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Redis源码剖析-整数集合" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/29/Redis源码剖析-整数集合/" class="article-date">
  <time datetime="2017-08-29T09:44:28.000Z" itemprop="datePublished">2017-08-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/29/Redis源码剖析-整数集合/">Redis源码剖析--整数集合</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>整数集合（intset）是集合键的底层实现之一： 当一个集合只包含整数值元素， 并且这个集合的元素数量不多时， Redis 就会使用整数集合作为集合键的底层实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; sadd numbers 1 2 3 4 5</div><div class="line">(integer) 5</div><div class="line">127.0.0.1:6379&gt; object encoding numbers</div><div class="line">&quot;intset&quot;</div></pre></td></tr></table></figure>
<p>这么做的好处是当集合中只有少量的整数元素的时候，采用之前介绍的其他数据结构，比如sds，都会占用比较大的内存，但如果仅保存为整数集合的话，则会更加经济。</p>
<h2 id="整数数组数据结构"><a href="#整数数组数据结构" class="headerlink" title="整数数组数据结构"></a>整数数组数据结构</h2><p>整数数组的定义位于intset.h中，具体如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">typedef struct intset &#123;</div><div class="line">    uint32_t encoding;  // 编码方式</div><div class="line">    uint32_t length;   // 保存的元素个数</div><div class="line">    int8_t contents[];  // 保存元素的数组</div><div class="line">&#125; intset;</div></pre></td></tr></table></figure>
<p>虽然 intset 结构将 contents 属性声明为 int8_t 类型的数组， 但实际上 contents 数组并不保存任何 int8_t 类型的值 —— contents 数组的真正类型取决于 encoding 属性的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">#define INTSET_ENC_INT16 (sizeof(int16_t))</div><div class="line">#define INTSET_ENC_INT32 (sizeof(int32_t))</div><div class="line">#define INTSET_ENC_INT64 (sizeof(int64_t))</div><div class="line"></div><div class="line">/* Return the required encoding for the provided value. */</div><div class="line">static uint8_t _intsetValueEncoding(int64_t v) &#123;</div><div class="line">    if (v &lt; INT32_MIN || v &gt; INT32_MAX)</div><div class="line">        return INTSET_ENC_INT64;</div><div class="line">    else if (v &lt; INT16_MIN || v &gt; INT16_MAX)</div><div class="line">        return INTSET_ENC_INT32;</div><div class="line">    else</div><div class="line">        return INTSET_ENC_INT16;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到一共会有三种类型，分别对应int_16, int_32, int_64。</p>
<p>整数数组中所有的元素在数组中按值的大小从小到大有序地排列， 并且数组中不包含任何重复项。</p>
<h2 id="整数集合操作"><a href="#整数集合操作" class="headerlink" title="整数集合操作"></a>整数集合操作</h2><h3 id="创建整数集合"><a href="#创建整数集合" class="headerlink" title="创建整数集合"></a>创建整数集合</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 初始化空的整数集合</div><div class="line">intset *intsetNew(void) &#123;</div><div class="line">    intset *is = zmalloc(sizeof(intset));</div><div class="line">    is-&gt;encoding = intrev32ifbe(INTSET_ENC_INT16); // 默认创建int_16的编码格式</div><div class="line">    is-&gt;length = 0;</div><div class="line">    return is;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="插入一个元素"><a href="#插入一个元素" class="headerlink" title="插入一个元素"></a>插入一个元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">/* Insert an integer in the intset */</div><div class="line">intset *intsetAdd(intset *is, int64_t value, uint8_t *success) &#123;</div><div class="line">    uint8_t valenc = _intsetValueEncoding(value);</div><div class="line">    uint32_t pos;</div><div class="line">    if (success) *success = 1;</div><div class="line"></div><div class="line">    // 如果超出了当前编码格式所能表示的范围，则升级整数集合并添加元素</div><div class="line">    if (valenc &gt; intrev32ifbe(is-&gt;encoding)) &#123;</div><div class="line">        /* This always succeeds, so we don&apos;t need to curry *success. */</div><div class="line">        return intsetUpgradeAndAdd(is,value);</div><div class="line">    &#125; else &#123;</div><div class="line">        // 如果元素已经存在于集合，success返回0</div><div class="line">        // 如果不存在的话， 这个函数会返回元素应该插入的位置pos</div><div class="line">        if (intsetSearch(is,value,&amp;pos)) &#123;</div><div class="line">            if (success) *success = 0;</div><div class="line">            return is;</div><div class="line">        &#125;</div><div class="line">        // 否则，需要重新调整集合的大小</div><div class="line">        is = intsetResize(is,intrev32ifbe(is-&gt;length)+1);</div><div class="line">        // 将pos之后的数据全都向后挪动一个位子</div><div class="line">        if (pos &lt; intrev32ifbe(is-&gt;length)) intsetMoveTail(is,pos,pos+1);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    _intsetSet(is,pos,value); // 添加数据到第pos位</div><div class="line">    is-&gt;length = intrev32ifbe(intrev32ifbe(is-&gt;length)+1); // 调整元素个数</div><div class="line">    return is;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在插入元素的时候，需要根据新元素的大小来重新确定所采用的编码。如果新元素超出了原有编码的表示范围，就需要调整编码，同时调整集合中所有其他元素的编码格式。调整编码是一个不可逆的过程，就是说只能从小的编码调整到大的编码，只能升级不能降级。</p>
<h3 id="升级过程"><a href="#升级过程" class="headerlink" title="升级过程"></a>升级过程</h3><p>升级整数集合并添加新元素调用的是intsetUpgradeAndAdd函数，共分为三步进行：</p>
<ul>
<li>根据新元素的类型， 扩展整数集合底层数组的空间大小， 并为新元素分配空间。</li>
<li>将底层数组现有的所有元素都转换成与新元素相同的类型， 并将类型转换后的元素放置到正确的位上， 而且在放置元素的过程中， 需要继续维持底层数组的有序性质不变。</li>
<li>将新元素添加到底层数组里面。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">/* Upgrades the intset to a larger encoding and inserts the given integer. */</div><div class="line">static intset *intsetUpgradeAndAdd(intset *is, int64_t value) &#123;</div><div class="line">    // 当前的编码</div><div class="line">    uint8_t curenc = intrev32ifbe(is-&gt;encoding);</div><div class="line">    // 根据新元素的值获得新的编码</div><div class="line">    uint8_t newenc = _intsetValueEncoding(value);</div><div class="line">    int length = intrev32ifbe(is-&gt;length);</div><div class="line">    // 由于整数集合是一个有序集合，所以新的这个超出范围的元素，要不插入头部，要不插入尾部</div><div class="line">    // 当value大于0的时候，就是插入到尾部，否则插入到头部，用参数prepend来标记</div><div class="line">    int prepend = value &lt; 0 ? 1 : 0;</div><div class="line"></div><div class="line">    /* First set new encoding and resize */</div><div class="line">    // 重新设置整数集合的编码</div><div class="line">    is-&gt;encoding = intrev32ifbe(newenc);</div><div class="line">    // 根据新编码调整整数集合的大小</div><div class="line">    is = intsetResize(is,intrev32ifbe(is-&gt;length)+1);</div><div class="line"></div><div class="line"></div><div class="line">    // 从尾部向头部进行升级，这样在挪动其中的元素的时候，不会覆盖原来的值</div><div class="line">    while(length--)</div><div class="line">        // 如果新元素是插入到尾部，prepend==0， 所以原来最后的元素是挪动到length位置</div><div class="line">        // 如果新元素是插入到头部，prepend==1，所有的元素都要向后挪动一个位置，将头部空出来</div><div class="line">        _intsetSet(is,length+prepend,_intsetGetEncoded(is,length,curenc));</div><div class="line"></div><div class="line">    /* Set the value at the beginning or the end. */</div><div class="line">    if (prepend)</div><div class="line">        // 如果prepend==1， 插入到头部</div><div class="line">        _intsetSet(is,0,value);</div><div class="line">    else</div><div class="line">        // 否则，设置最后一个位置的元素为value</div><div class="line">        _intsetSet(is,intrev32ifbe(is-&gt;length),value);</div><div class="line">    // 元素个数加1</div><div class="line">    is-&gt;length = intrev32ifbe(intrev32ifbe(is-&gt;length)+1);</div><div class="line">    return is;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而整数集合现在的做法既可以让集合能同时保存三种不同类型的值， 又可以确保升级操作只会在有需要的时候进行， 这可以尽量节省内存。</p>
<h3 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h3><p>查找的时候，需要先判断要查找的元素是否在当前编码的有效范围内，如果不在当前范围内，可以直接返回。</p>
<p>另外因为整数集合是一个有序集合，可以采用二分查找的办法，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">uint8_t intsetFind(intset *is, int64_t value) &#123;</div><div class="line">    // 获得目标值的编码</div><div class="line">    uint8_t valenc = _intsetValueEncoding(value);</div><div class="line">    // 只有目标值的编码比当前编码小，才继续执行查找过程</div><div class="line">    return valenc &lt;= intrev32ifbe(is-&gt;encoding) &amp;&amp; intsetSearch(is,value,NULL);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 如果找到这个元素，返回1，同时pos表示这个值在整数集合里边的位置</div><div class="line">// 如果没有找到这个元素，返回0， 同时pos表示这个值可以插入的位置</div><div class="line">static uint8_t intsetSearch(intset *is, int64_t value, uint32_t *pos) &#123;</div><div class="line">    int min = 0, max = intrev32ifbe(is-&gt;length)-1, mid = -1;</div><div class="line">    int64_t cur = -1;</div><div class="line"></div><div class="line">    /* The value can never be found when the set is empty */</div><div class="line">    // 如果集合的长度为0， 直接返回0</div><div class="line">    if (intrev32ifbe(is-&gt;length) == 0) &#123;</div><div class="line">        if (pos) *pos = 0;</div><div class="line">        return 0;</div><div class="line">    &#125; else &#123;</div><div class="line">        /* Check for the case where we know we cannot find the value,</div><div class="line">         * but do know the insert position. */</div><div class="line">        // 如果目标值大于当前最大值，肯定找不到，返回0， 同时待插入的位置pos为length</div><div class="line">        if (value &gt; _intsetGet(is,intrev32ifbe(is-&gt;length)-1)) &#123;</div><div class="line">            if (pos) *pos = intrev32ifbe(is-&gt;length);</div><div class="line">            return 0;</div><div class="line">        &#125; else if (value &lt; _intsetGet(is,0)) &#123;</div><div class="line">            // 如果目标址小于当前最小值，返回0， 同时待插入的位置pos为0</div><div class="line">            if (pos) *pos = 0;</div><div class="line">            return 0;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 二分查找</div><div class="line">    while(max &gt;= min) &#123;</div><div class="line">        // 得到中间位置</div><div class="line">        mid = ((unsigned int)min + (unsigned int)max) &gt;&gt; 1;</div><div class="line">        // 得到中间位置的值</div><div class="line">        cur = _intsetGet(is,mid);</div><div class="line">        if (value &gt; cur) &#123;</div><div class="line">            min = mid+1;</div><div class="line">        &#125; else if (value &lt; cur) &#123;</div><div class="line">            max = mid-1;</div><div class="line">        &#125; else &#123;</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (value == cur) &#123;</div><div class="line">        if (pos) *pos = mid;</div><div class="line">        return 1;</div><div class="line">    &#125; else &#123;</div><div class="line">        if (pos) *pos = min;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://harleylau.github.io/2017/08/29/Redis源码剖析-整数集合/" data-id="cjhr1rzc6000gv368ah3nx0kp" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/">redis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码/">源码</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Redis源码剖析-跳跃表" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/24/Redis源码剖析-跳跃表/" class="article-date">
  <time datetime="2017-08-24T02:46:04.000Z" itemprop="datePublished">2017-08-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/24/Redis源码剖析-跳跃表/">Redis源码剖析--跳跃表</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>跳跃表（skiplist）是一种有序数据结构， 它通过在每个节点中维持多个指向其他节点的指针， 从而达到快速访问节点的目的。</p>
<p>跳跃表支持平均 O(\log N) 最坏 O(N) 复杂度的节点查找， 还可以通过顺序性操作来批量处理节点。</p>
<p>在大部分情况下， 跳跃表的效率可以和平衡树相媲美， 并且因为跳跃表的实现比平衡树要来得更为简单， 所以有不少程序都使用跳跃表来代替平衡树。</p>
<p>Redis 使用跳跃表作为有序集合键的底层实现之一： 如果一个有序集合包含的元素数量比较多， 又或者有序集合中元素的成员（member）是比较长的字符串时， Redis 就会使用跳跃表来作为有序集合键的底层实现。</p>
<p>和链表、字典等数据结构被广泛地应用在 Redis 内部不同， Redis 只在两个地方用到了跳跃表， 一个是实现有序集合键， 另一个是在集群节点中用作内部数据结构， 除此之外， 跳跃表在 Redis 里面没有其他用途。</p>
<p>先看一下维基百科对跳跃表的图示：<br><img src="/2017/08/24/Redis源码剖析-跳跃表/Skip_list.svg" alt="logo"></p>
<p>从图中可以看到， 跳跃表主要由以下部分构成：</p>
<ul>
<li>表头（head）：负责维护跳跃表的节点指针。</li>
<li>跳跃表节点：保存着元素值，以及多个层。</li>
<li>层：保存着指向其他元素的指针。高层的指针越过的元素数量大于等于低层的指针，为了提高查找的效率，程序总是从高层先开始访问，然后随着元素值范围的缩小，慢慢降低层次。</li>
<li>表尾：全部由 NULL 组成，表示跳跃表的末尾。</li>
</ul>
<h2 id="跳跃表结构定义"><a href="#跳跃表结构定义" class="headerlink" title="跳跃表结构定义"></a>跳跃表结构定义</h2><p>跳跃表的结构体定义在server.h文件中。其中包括跳跃表节点zskiplistNode和跳跃表zskiplist两个结构体。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/* ZSETs use a specialized version of Skiplists */</div><div class="line">typedef struct zskiplistNode &#123;</div><div class="line">    sds ele;   // 具体成员对象</div><div class="line">    double score;   // 成员分值</div><div class="line">    struct zskiplistNode *backward;  // 向后索引指针</div><div class="line">    struct zskiplistLevel &#123;    // 跳跃表层</div><div class="line">        struct zskiplistNode *forward;  // 前向索引指针</div><div class="line">        unsigned int span;    // 这一层的跨度</div><div class="line">    &#125; level[];</div><div class="line">&#125; zskiplistNode;</div><div class="line"></div><div class="line">typedef struct zskiplist &#123;</div><div class="line">    struct zskiplistNode *header, *tail;   // 头尾结点</div><div class="line">    unsigned long length;    // 总的结点数</div><div class="line">    int level;    // 总的层数</div><div class="line">&#125; zskiplist;</div></pre></td></tr></table></figure>
<p>每次创建一个新跳跃表节点的时候， 程序都根据幂次定律 （power law，越大的数出现的概率越小） 随机生成一个介于 1 和 32 之间的值作为 level 数组的大小， 这个大小就是层的“高度”。</p>
<p>总的层数保存在zskiplist的level参数中， 另外每个节点保存了各自层中的指针以及这一层的跨度。</p>
<h2 id="跳跃表操作"><a href="#跳跃表操作" class="headerlink" title="跳跃表操作"></a>跳跃表操作</h2><h3 id="创建跳跃表"><a href="#创建跳跃表" class="headerlink" title="创建跳跃表"></a>创建跳跃表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">/* Create a skiplist node with the specified number of levels.</div><div class="line"> * The SDS string &apos;ele&apos; is referenced by the node after the call. */</div><div class="line"> // 创建跳跃表结点</div><div class="line">zskiplistNode *zslCreateNode(int level, double score, sds ele) &#123;</div><div class="line">    // 开辟内存，根据传入的层数设置大小</div><div class="line">    zskiplistNode *zn =</div><div class="line">        zmalloc(sizeof(*zn)+level*sizeof(struct zskiplistLevel));</div><div class="line">    // 赋值跳跃表结点分值</div><div class="line">    zn-&gt;score = score;</div><div class="line">    // 赋值跳跃表结点对象</div><div class="line">    zn-&gt;ele = ele;</div><div class="line">    return zn;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* 创建跳跃表 */</div><div class="line">zskiplist *zslCreate(void) &#123;</div><div class="line">    int j;</div><div class="line">    zskiplist *zsl;</div><div class="line">    // 申请内存</div><div class="line">    zsl = zmalloc(sizeof(*zsl));</div><div class="line">    // 设置层数为1</div><div class="line">    zsl-&gt;level = 1;</div><div class="line">    // 总的结点数为0</div><div class="line">    zsl-&gt;length = 0;</div><div class="line">    // ZSKIPLIST_MAXLEVEL=32, 头结点，设置最大层数，分值为0， 具体对象为NULL</div><div class="line">    zsl-&gt;header = zslCreateNode(ZSKIPLIST_MAXLEVEL,0,NULL);</div><div class="line">    // 循环设置头结点的每一层的前向指针为NULL，跨度为0</div><div class="line">    for (j = 0; j &lt; ZSKIPLIST_MAXLEVEL; j++) &#123;</div><div class="line">        zsl-&gt;header-&gt;level[j].forward = NULL;</div><div class="line">        zsl-&gt;header-&gt;level[j].span = 0;</div><div class="line">    &#125;</div><div class="line">    // 头结点的后向指针为NULL</div><div class="line">    zsl-&gt;header-&gt;backward = NULL;</div><div class="line">    zsl-&gt;tail = NULL;</div><div class="line">    return zsl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>创建跳跃表的时候设置层数为1， 只有一个头结点，头结点保存了最大的层数，同时所有的前向指针都为NULL。</p>
<h3 id="释放整个跳跃表"><a href="#释放整个跳跃表" class="headerlink" title="释放整个跳跃表"></a>释放整个跳跃表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">/* Free the specified skiplist node. The referenced SDS string representation</div><div class="line"> * of the element is freed too, unless node-&gt;ele is set to NULL before calling</div><div class="line"> * this function. */</div><div class="line">void zslFreeNode(zskiplistNode *node) &#123;</div><div class="line">    sdsfree(node-&gt;ele);</div><div class="line">    zfree(node);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* 释放整个跳跃表. */</div><div class="line">void zslFree(zskiplist *zsl) &#123;</div><div class="line">    // 从最底层的level[0]依次遍历，释放</div><div class="line">    zskiplistNode *node = zsl-&gt;header-&gt;level[0].forward, *next;</div><div class="line"></div><div class="line">    zfree(zsl-&gt;header);</div><div class="line">    // 如果存在后续结点</div><div class="line">    while(node) &#123;</div><div class="line">        next = node-&gt;level[0].forward;</div><div class="line">        // 释放结点</div><div class="line">        zslFreeNode(node);</div><div class="line">        node = next;</div><div class="line">    &#125;</div><div class="line">    zfree(zsl);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="跳跃表插入元素"><a href="#跳跃表插入元素" class="headerlink" title="跳跃表插入元素"></a>跳跃表插入元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line">/* Insert a new node in the skiplist. Assumes the element does not already</div><div class="line"> * exist (up to the caller to enforce that). The skiplist takes ownership</div><div class="line"> * of the passed SDS string &apos;ele&apos;. */</div><div class="line"> // 跳跃表插入元素</div><div class="line">zskiplistNode *zslInsert(zskiplist *zsl, double score, sds ele) &#123;</div><div class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</div><div class="line">    unsigned int rank[ZSKIPLIST_MAXLEVEL];</div><div class="line">    int i, level;</div><div class="line"></div><div class="line">    serverAssert(!isnan(score));   　// 判断是否为数字</div><div class="line">    x = zsl-&gt;header;</div><div class="line">    // 从最高的level， 也即跨度最大的level开始查找结点</div><div class="line">    for (i = zsl-&gt;level-1; i &gt;= 0; i--) &#123;</div><div class="line">        /* store rank that is crossed to reach the insert position */</div><div class="line">        // 当前是否是最高层， 如果是最高层，rank[i]=0，否则，复制上一层的数值</div><div class="line">        rank[i] = i == (zsl-&gt;level-1) ? 0 : rank[i+1];</div><div class="line">        // 如果当前结点的score值小于传入的score 或者 当前score相等，但是结点的对象不相等</div><div class="line">        while (x-&gt;level[i].forward &amp;&amp;</div><div class="line">                (x-&gt;level[i].forward-&gt;score &lt; score ||</div><div class="line">                    (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</div><div class="line">                    sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt; 0)))</div><div class="line">        &#123;</div><div class="line">            // 将当前一层的跨度加到rank[i]</div><div class="line">            rank[i] += x-&gt;level[i].span;</div><div class="line">            // 在当前层中向前查找</div><div class="line">            x = x-&gt;level[i].forward;</div><div class="line">        &#125;</div><div class="line">        // 当前层位于插入位置前的结点x放入update数组</div><div class="line">        update[i] = x;</div><div class="line">    &#125;</div><div class="line">    /* we assume the element is not already inside, since we allow duplicated</div><div class="line">     * scores, reinserting the same element should never happen since the</div><div class="line">     * caller of zslInsert() should test in the hash table if the element is</div><div class="line">     * already inside or not. */</div><div class="line">    // 随机生成小于32的层数</div><div class="line">    level = zslRandomLevel();</div><div class="line">    // 如果生成的层数大于当前的层数</div><div class="line">    if (level &gt; zsl-&gt;level) &#123;</div><div class="line">        for (i = zsl-&gt;level; i &lt; level; i++) &#123;</div><div class="line">            // 设定rank数组中大于原level层以上的值为0</div><div class="line">            // 同时设定update数组大于原level层以上的数据</div><div class="line">            rank[i] = 0;</div><div class="line">            update[i] = zsl-&gt;header;</div><div class="line">            update[i]-&gt;level[i].span = zsl-&gt;length;</div><div class="line">        &#125;</div><div class="line">        zsl-&gt;level = level;</div><div class="line">    &#125;</div><div class="line">    // 创建层数为level的新结点</div><div class="line">    x = zslCreateNode(level,score,ele);</div><div class="line">    for (i = 0; i &lt; level; i++) &#123;</div><div class="line">        // 将每一层的前置结点的后续结点指向新结点， 同时设置新结点的后续结点</div><div class="line">        x-&gt;level[i].forward = update[i]-&gt;level[i].forward;</div><div class="line">        update[i]-&gt;level[i].forward = x;</div><div class="line"></div><div class="line">        /* update span covered by update[i] as x is inserted here */</div><div class="line">        // 更新每一层的前置结点和新结点的跨度</div><div class="line">        x-&gt;level[i].span = update[i]-&gt;level[i].span - (rank[0] - rank[i]);</div><div class="line">        update[i]-&gt;level[i].span = (rank[0] - rank[i]) + 1;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* increment span for untouched levels */</div><div class="line">    for (i = level; i &lt; zsl-&gt;level; i++) &#123;</div><div class="line">        update[i]-&gt;level[i].span++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 根据最低层的前序结点是否是header结点来设置当前新结点的向后指针</div><div class="line">    x-&gt;backward = (update[0] == zsl-&gt;header) ? NULL : update[0];</div><div class="line">    if (x-&gt;level[0].forward)</div><div class="line">        x-&gt;level[0].forward-&gt;backward = x;</div><div class="line">    else</div><div class="line">        zsl-&gt;tail = x;</div><div class="line">    zsl-&gt;length++;</div><div class="line">    return x;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先看图示，如果想要插入score=5的结点（redis中允许score值重复），那么首选需要找到score=5的结点，查找的顺序为：</p>
<p><img src="/2017/08/24/Redis源码剖析-跳跃表/WX20170824-181328.png" alt="logo"></p>
<p>从最大的层向后查找，如果当前层后边没有值了，并且当前结点的值小于要找的值，就查找下一层结点；如果下一个结点的值大于要找的值，也会到下一层结点继续查找。</p>
<p>找到对应的位置执行插入操作后，需要为新结点设置层数，那么设置多少层合适呢，这边直接采用了一个随机数。随机数生成了多少层，当前新结点的层数就设置多少层。</p>
<p>如果新层数小于原来的层数，只需要重新设置前序后置结点的指针和跨度就行；如果新层数大于原来的层数，就需要额外设置新的更高的层。</p>
<p>那么插入结点之后，如何修改前序和后置结点的指针和跨度呢。这边用了两个数组来记录，分别是update和rank。update用来记录每一层中插入位置的前序结点，到时候根据这个前序结点设置每一层的指针调整。 rank用来记录每一层到新结点的跨度，插入新结点之后，根据rank数组中记录跨度更新前置结点的跨度值。</p>
<h3 id="删除跳跃表结点"><a href="#删除跳跃表结点" class="headerlink" title="删除跳跃表结点"></a>删除跳跃表结点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"> /* 删除结点，如果结点存在并删除，返回1， 否则返回0</div><div class="line">    参数中node如果是空的，则结点确实被删除； 如果非空，只是把结点从链表上摘下来，返回指针给node*/</div><div class="line">int zslDelete(zskiplist *zsl, double score, sds ele, zskiplistNode **node) &#123;</div><div class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</div><div class="line">    int i;</div><div class="line"></div><div class="line">    x = zsl-&gt;header;</div><div class="line">    // 查找对应结点</div><div class="line">    for (i = zsl-&gt;level-1; i &gt;= 0; i--) &#123;</div><div class="line">        while (x-&gt;level[i].forward &amp;&amp;</div><div class="line">                (x-&gt;level[i].forward-&gt;score &lt; score ||</div><div class="line">                    (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</div><div class="line">                     sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt; 0)))</div><div class="line">        &#123;</div><div class="line">            x = x-&gt;level[i].forward;</div><div class="line">        &#125;</div><div class="line">        update[i] = x;</div><div class="line">    &#125;</div><div class="line">    /* We may have multiple elements with the same score, what we need</div><div class="line">     * is to find the element with both the right score and object. */</div><div class="line">    // 由于允许存在相同的score，需要在score和ele都满足的条件下才能删除</div><div class="line">    x = x-&gt;level[0].forward;</div><div class="line">    if (x &amp;&amp; score == x-&gt;score &amp;&amp; sdscmp(x-&gt;ele,ele) == 0) &#123;</div><div class="line">        zslDeleteNode(zsl, x, update);</div><div class="line">        if (!node)</div><div class="line">            zslFreeNode(x);</div><div class="line">        else</div><div class="line">            *node = x;</div><div class="line">        return 1;</div><div class="line">    &#125;</div><div class="line">    return 0; /* not found */</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>具体的结点删除操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">/* Internal function used by zslDelete, zslDeleteByScore and zslDeleteByRank */</div><div class="line">// update数组保存了所有层上要删除结点的前置结点</div><div class="line">void zslDeleteNode(zskiplist *zsl, zskiplistNode *x, zskiplistNode **update) &#123;</div><div class="line">    int i;</div><div class="line">    for (i = 0; i &lt; zsl-&gt;level; i++) &#123;</div><div class="line">        if (update[i]-&gt;level[i].forward == x) &#123;</div><div class="line">            // 如果当前层有指针指向要删除的结点，前置结点的跨度需要加上当前结点的跨度，同时更新指针</div><div class="line">            update[i]-&gt;level[i].span += x-&gt;level[i].span - 1;</div><div class="line">            update[i]-&gt;level[i].forward = x-&gt;level[i].forward;</div><div class="line">        &#125; else &#123;</div><div class="line">            // 否则，只需要将前置结点的跨度减1即可，因为少了一个结点啊</div><div class="line">            update[i]-&gt;level[i].span -= 1;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    // 修改backward指针，需要考虑x是否为尾节点</div><div class="line">    if (x-&gt;level[0].forward) &#123;</div><div class="line">        x-&gt;level[0].forward-&gt;backward = x-&gt;backward;</div><div class="line">    &#125; else &#123;</div><div class="line">        zsl-&gt;tail = x-&gt;backward;</div><div class="line">    &#125;</div><div class="line">    while(zsl-&gt;level &gt; 1 &amp;&amp; zsl-&gt;header-&gt;level[zsl-&gt;level-1].forward == NULL)</div><div class="line">        zsl-&gt;level--;</div><div class="line">    zsl-&gt;length--;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://harleylau.github.io/2017/08/24/Redis源码剖析-跳跃表/" data-id="cjhr1rzc8000iv368baxrjyvb" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/">redis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码/">源码</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JWT/">JWT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tornado/">Tornado</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tornado/">tornado</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/websocket/">websocket</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/二维码/">二维码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/源码/">源码</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/JWT/" style="font-size: 10px;">JWT</a> <a href="/tags/Python/" style="font-size: 10px;">Python</a> <a href="/tags/Tornado/" style="font-size: 10px;">Tornado</a> <a href="/tags/redis/" style="font-size: 20px;">redis</a> <a href="/tags/tornado/" style="font-size: 15px;">tornado</a> <a href="/tags/websocket/" style="font-size: 10px;">websocket</a> <a href="/tags/二维码/" style="font-size: 10px;">二维码</a> <a href="/tags/源码/" style="font-size: 20px;">源码</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/05/10/Redis源码剖析-列表t-list实现/">Redis源码剖析--列表t_list实现</a>
          </li>
        
          <li>
            <a href="/2018/05/09/Redis源码剖析-字符串t-string实现/">Redis源码剖析--字符串t_string实现</a>
          </li>
        
          <li>
            <a href="/2018/02/12/tornado-websocket实现二维码扫描/">tornado websocket实现二维码扫描</a>
          </li>
        
          <li>
            <a href="/2018/02/12/tornado之WebSocket/">tornado之WebSocket</a>
          </li>
        
          <li>
            <a href="/2017/09/12/Redis源码剖析-字符串对象/">Redis源码剖析--字符串对象</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 Harley Liu<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>