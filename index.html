<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Harley_Lau</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Harley_Lau">
<meta property="og:url" content="https://harleylau.github.io/index.html">
<meta property="og:site_name" content="Harley_Lau">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Harley_Lau">
  
    <link rel="alternate" href="/atom.xml" title="Harley_Lau" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Harley_Lau</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://harleylau.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Redis源码剖析-字符串t-string实现" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/09/Redis源码剖析-字符串t-string实现/" class="article-date">
  <time datetime="2018-05-09T02:12:07.000Z" itemprop="datePublished">2018-05-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/09/Redis源码剖析-字符串t-string实现/">Redis源码剖析--字符串t_string实现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>介绍完Redis的底层数据结构之后， 介绍我们平时使用Redis的时候可以直接看到五种数据结构：字符串、哈希、链表、集合和有序集合。</p>
<p>首先介绍字符串t_string的实现。</p>
<h2 id="字符串的结构"><a href="#字符串的结构" class="headerlink" title="字符串的结构"></a>字符串的结构</h2><p>上一篇文章讲到过字符串的底层实现其实有三种编码：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>编码</th>
<th>对象</th>
</tr>
</thead>
<tbody>
<tr>
<td>REDIS_STRING</td>
<td>REDIS_ENCODING_INT</td>
<td>使用整数值实现的字符串对象。</td>
</tr>
<tr>
<td>REDIS_STRING</td>
<td>REDIS_ENCODING_EMBSTR</td>
<td>使用 embstr 编码的简单动态字符串实现的字符串对象。</td>
</tr>
<tr>
<td>REDIS_STRING</td>
<td>REDIS_ENCODING_RAW</td>
<td>使用简单动态字符串实现的字符串对象。</td>
</tr>
</tbody>
</table>
<p>这三种类型分别对应的底层数据结构为int，embstr, sds。</p>
<p>字符串的定义代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">typedef struct redisObject &#123;</div><div class="line">    //对象的数据类型，字符串对象应该为 OBJ_STRING</div><div class="line">    unsigned type:4;        </div><div class="line">    //对象的编码类型，分别为OBJ_STRING、OBJ_ENCODING_INT或OBJ_ENCODING_EMBSTR</div><div class="line">    unsigned encoding:4;</div><div class="line">    //LRU_BITS为24位，最近一次的访问时间</div><div class="line">    unsigned lru:LRU_BITS; /* lru time (relative to server.lruclock) */</div><div class="line">    //引用计数</div><div class="line">    int refcount;</div><div class="line">    //指向底层数据实现的指针</div><div class="line">    void *ptr;</div><div class="line">&#125; robj;</div></pre></td></tr></table></figure>
<p>那么字符串具体用哪种编码实现呢？</p>
<p>如果一个字符串对象保存的是整数值， 并且这个整数值可以用 long 类型来表示， 那么字符串对象会将整数值保存在字符串对象结构的 ptr 属性里面（将 void* 转换成 long ）， 并将字符串对象的编码设置为 int 。</p>
<p>如果字符串对象保存的是一个字符串值， 并且这个字符串值的长度大于 39 字节， 那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值， 并将对象的编码设置为 raw 。</p>
<p>如果字符串对象保存的是一个字符串值， 并且这个字符串值的长度小于等于 39 字节， 那么字符串对象将使用 embstr 编码的方式来保存这个字符串值。</p>
<p>embstr 编码是专门用于保存短字符串的一种优化编码方式， 这种编码和 raw 编码一样， 都使用 redisObject 结构和 sdshdr 结构来表示字符串对象， 但 raw 编码会调用两次内存分配函数来分别创建 redisObject 结构和 sdshdr 结构， 而 embstr 编码则通过调用一次内存分配函数来分配一块连续的空间， 空间中依次包含 redisObject 和 sdshdr 两个结构</p>
<p>这边采用int和embstr编码的原因是：相较于raw格式的2次分配内存， 这两种格式只需要一次分配内存空间就可以；并且在回收的时候，也只需要调用一次内存释放函数。在存储小的字符串的时候更有速度优势。</p>
<h2 id="字符串命令"><a href="#字符串命令" class="headerlink" title="字符串命令"></a>字符串命令</h2><p>字符串支持的命令如下：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>命令描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>SET key value [ex 秒数][px 毫秒数][nx/xx]</td>
<td>设置指定key的值</td>
</tr>
<tr>
<td>GET key</td>
<td>获取指定key的值</td>
</tr>
<tr>
<td>APPEND key value</td>
<td>将value追加到指定key的值末尾</td>
</tr>
<tr>
<td>INCRBY key increment</td>
<td>将指定key的值加上增量increment</td>
</tr>
<tr>
<td>DECRBY key decrement</td>
<td>将指定key的值减去增量decrement</td>
</tr>
<tr>
<td>STRLEN key</td>
<td>返回指定key的值长度</td>
</tr>
<tr>
<td>SETRANGE key offset value</td>
<td>将value覆写到指定key的值上，从offset位开始</td>
</tr>
<tr>
<td>GETRANGE key start end</td>
<td>获取指定key中字符串的子串[start,end]</td>
</tr>
<tr>
<td>MSET key value [key value …]</td>
<td>一次设定多个key的值</td>
</tr>
<tr>
<td>MGET key1 [key2..]</td>
<td>一次获取多个key的值</td>
</tr>
</tbody>
</table>
<h2 id="字符串命令实现"><a href="#字符串命令实现" class="headerlink" title="字符串命令实现"></a>字符串命令实现</h2><h3 id="set命令的实现"><a href="#set命令的实现" class="headerlink" title="set命令的实现"></a>set命令的实现</h3><p>set命令用于设置指定的值，其具体命令格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">set key value [ex 秒数] [px 毫秒数] [nx/xx]</div></pre></td></tr></table></figure>
<p>其中，各个选项的含义如下：</p>
<ul>
<li>ex 设置指定的到期时间，单位为秒</li>
<li>px 设置指定的到期时间，单位为毫秒</li>
<li>nx 只有在key不存在的时候，才设置key的值</li>
<li>xx 只有key存在时，才对key进行设置操作</li>
</ul>
<p>set命令是调用setCommand实现的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">// 关于set命令的操作有三种宏定义</div><div class="line">#define OBJ_SET_NO_FLAGS 0    // 没有设定参数</div><div class="line">#define OBJ_SET_NX (1&lt;&lt;0)     // 只有键不存在时才设定其值</div><div class="line">#define OBJ_SET_XX (1&lt;&lt;1)      // 只有键存在时才设定其值</div><div class="line">#define OBJ_SET_EX (1&lt;&lt;2)       // ex属性，到期时间单位为秒</div><div class="line">#define OBJ_SET_PX (1&lt;&lt;3)     	// px属性，到期时间单位为毫秒</div><div class="line"></div><div class="line">/* set命令实现函数 */</div><div class="line">void setCommand(client *c) &#123;</div><div class="line">    int j;</div><div class="line">    robj *expire = NULL;</div><div class="line">    int unit = UNIT_SECONDS;</div><div class="line">  	// 用于标记ex/px和nx/xx命令参数</div><div class="line">    int flags = OBJ_SET_NO_FLAGS;</div><div class="line">	// 从命令串的第四个参数开始，查看其是否设定了ex/px和nx/xx</div><div class="line">    for (j = 3; j &lt; c-&gt;argc; j++) &#123;</div><div class="line">        char *a = c-&gt;argv[j]-&gt;ptr;</div><div class="line">        robj *next = (j == c-&gt;argc-1) ? NULL : c-&gt;argv[j+1];</div><div class="line">        if ((a[0] == &apos;n&apos; || a[0] == &apos;N&apos;) &amp;&amp;</div><div class="line">            (a[1] == &apos;x&apos; || a[1] == &apos;X&apos;) &amp;&amp; a[2] == &apos;\0&apos; &amp;&amp;</div><div class="line">            !(flags &amp; OBJ_SET_XX)) // 标记</div><div class="line">        &#123;</div><div class="line">            flags |= OBJ_SET_NX;</div><div class="line">        &#125; else if ((a[0] == &apos;x&apos; || a[0] == &apos;X&apos;) &amp;&amp;</div><div class="line">                   (a[1] == &apos;x&apos; || a[1] == &apos;X&apos;) &amp;&amp; a[2] == &apos;\0&apos; &amp;&amp;</div><div class="line">                   !(flags &amp; OBJ_SET_NX))</div><div class="line">        &#123;</div><div class="line">            flags |= OBJ_SET_XX;</div><div class="line">        &#125; else if ((a[0] == &apos;e&apos; || a[0] == &apos;E&apos;) &amp;&amp;</div><div class="line">                   (a[1] == &apos;x&apos; || a[1] == &apos;X&apos;) &amp;&amp; a[2] == &apos;\0&apos; &amp;&amp;</div><div class="line">                   !(flags &amp; OBJ_SET_PX) &amp;&amp; next)</div><div class="line">        &#123;</div><div class="line">            flags |= OBJ_SET_EX;</div><div class="line">            unit = UNIT_SECONDS;</div><div class="line">            expire = next;</div><div class="line">            j++;</div><div class="line">        &#125; else if ((a[0] == &apos;p&apos; || a[0] == &apos;P&apos;) &amp;&amp;</div><div class="line">                   (a[1] == &apos;x&apos; || a[1] == &apos;X&apos;) &amp;&amp; a[2] == &apos;\0&apos; &amp;&amp;</div><div class="line">                   !(flags &amp; OBJ_SET_EX) &amp;&amp; next)</div><div class="line">        &#123;</div><div class="line">            flags |= OBJ_SET_PX;</div><div class="line">            unit = UNIT_MILLISECONDS;</div><div class="line">            expire = next;</div><div class="line">            j++;</div><div class="line">        &#125; else &#123;</div><div class="line">          	// 如果不是上述参数，则需要报错，命令错误</div><div class="line">            addReply(c,shared.syntaxerr);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    // 判断value是否可以编码成整数，如果能则编码；反之不做处理</div><div class="line">    c-&gt;argv[2] = tryObjectEncoding(c-&gt;argv[2]);</div><div class="line">    // 调用底层函数进行键值对设定</div><div class="line">    setGenericCommand(c,flags,c-&gt;argv[1],c-&gt;argv[2],expire,unit,NULL,NULL);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>函数的一开始先检查传入的参数，看是否设定了过期时间以及过期时间的精度等，然后设置对应的flag， 最后根据flag调用setGenericCommand实现具体的操作。</p>
<p>接下去看一下setGenericCommand函数的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">//setGenericCommand()函数是以下命令: SET, SETEX, PSETEX, SETNX.的最底层实现</div><div class="line">//flags 可以是NX或XX，由上面的宏提供</div><div class="line">//expire 定义key的过期时间，格式由unit指定</div><div class="line">//ok_reply和abort_reply保存着回复client的内容，NX和XX也会改变回复</div><div class="line">//如果ok_reply为空，则使用 &quot;+OK&quot;</div><div class="line">//如果abort_reply为空，则使用 &quot;$-1&quot;</div><div class="line">void setGenericCommand(client *c, int flags, robj *key, robj *val, robj *expire, int unit, robj *ok_reply, robj *abort_reply) &#123;</div><div class="line">    long long milliseconds = 0; /* initialized to avoid any harmness warning */ //初始化，避免错误</div><div class="line"></div><div class="line">    //如果定义了key的过期时间</div><div class="line">    if (expire) &#123;</div><div class="line">        //从expire对象中取出值，保存在milliseconds中，如果出错发送默认的信息给client</div><div class="line">        if (getLongLongFromObjectOrReply(c, expire, &amp;milliseconds, NULL) != C_OK)</div><div class="line">            return;</div><div class="line">        // 如果过期时间小于等于0，则发送错误信息给client</div><div class="line">        if (milliseconds &lt;= 0) &#123;</div><div class="line">            addReplyErrorFormat(c,&quot;invalid expire time in %s&quot;,c-&gt;cmd-&gt;name);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        //如果unit的单位是秒，则需要转换为毫秒保存</div><div class="line">        if (unit == UNIT_SECONDS) milliseconds *= 1000;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //lookupKeyWrite函数是为执行写操作而取出key的值对象</div><div class="line">    //如果设置了NX(不存在)，并且在数据库中 找到 该key，或者</div><div class="line">    //设置了XX(存在)，并且在数据库中 没有找到 该key</div><div class="line">    //回复abort_reply给client</div><div class="line">    if ((flags &amp; OBJ_SET_NX &amp;&amp; lookupKeyWrite(c-&gt;db,key) != NULL) ||</div><div class="line">        (flags &amp; OBJ_SET_XX &amp;&amp; lookupKeyWrite(c-&gt;db,key) == NULL))</div><div class="line">    &#123;</div><div class="line">        addReply(c, abort_reply ? abort_reply : shared.nullbulk);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    //在当前db设置键为key的值为val</div><div class="line">    setKey(c-&gt;db,key,val);</div><div class="line"></div><div class="line">    //设置数据库为脏(dirty)，服务器每次修改一个key后，都会对脏键(dirty)增1</div><div class="line">    server.dirty++;</div><div class="line"></div><div class="line">    //设置key的过期时间</div><div class="line">    //mstime()返回毫秒为单位的格林威治时间</div><div class="line">    if (expire) setExpire(c-&gt;db,key,mstime()+milliseconds);</div><div class="line"></div><div class="line">    //发送&quot;set&quot;事件的通知，用于发布订阅模式，通知客户端接受发生的事件</div><div class="line">    notifyKeyspaceEvent(NOTIFY_STRING,&quot;set&quot;,key,c-&gt;db-&gt;id);</div><div class="line"></div><div class="line">    //发送&quot;expire&quot;事件通知</div><div class="line">    if (expire) notifyKeyspaceEvent(NOTIFY_GENERIC,</div><div class="line">        &quot;expire&quot;,key,c-&gt;db-&gt;id);</div><div class="line"></div><div class="line">    //设置成功，则向客户端发送ok_reply</div><div class="line">    addReply(c, ok_reply ? ok_reply : shared.ok);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="get命令的实现"><a href="#get命令的实现" class="headerlink" title="get命令的实现"></a>get命令的实现</h3><p>类似于set命令，get命令也是最终调用一个getGenericcommand的函数实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">//GET 命令的底层实现</div><div class="line">int getGenericCommand(client *c) &#123;</div><div class="line">    robj *o;</div><div class="line"></div><div class="line">    //lookupKeyReadOrReply函数是为执行读操作而返回key的值对象，找到返回该对象，找不到会发送信息给client</div><div class="line">    //如果key不存在直接，返回0表示GET命令执行成功</div><div class="line">    if ((o = lookupKeyReadOrReply(c,c-&gt;argv[1],shared.nullbulk)) == NULL)</div><div class="line">        return C_OK;</div><div class="line"></div><div class="line">    //如果key的值的编码类型不是字符串对象</div><div class="line">    if (o-&gt;type != OBJ_STRING) &#123;</div><div class="line">        addReply(c,shared.wrongtypeerr);    //返回类型错误的信息给client，返回-1表示GET命令执行失败</div><div class="line">        return C_ERR;</div><div class="line">    &#125; else &#123;</div><div class="line">        addReplyBulk(c,o);  //返回之前找到的对象作为回复给client，返回0表示GET命令执行成功</div><div class="line">        return C_OK;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="编码的转换"><a href="#编码的转换" class="headerlink" title="编码的转换"></a>编码的转换</h2><p>上边说到字符串类型底层其实有三种数据类型，这三种数据类型在特定的情况下也会互相转换。</p>
<h3 id="int编码转换为raw编码"><a href="#int编码转换为raw编码" class="headerlink" title="int编码转换为raw编码"></a>int编码转换为raw编码</h3><p>对于 int 编码的字符串对象来说， 如果我们向对象执行了一些命令， 使得这个对象保存的不再是整数值， 而是一个字符串值， 比如在最开始的数字类型后边执行了一个append的操作，加上了一串字符串，那么字符串对象的编码将从 int 变为 raw 。</p>
<h3 id="embstr编码转换为raw编码"><a href="#embstr编码转换为raw编码" class="headerlink" title="embstr编码转换为raw编码"></a>embstr编码转换为raw编码</h3><p>因为 Redis 没有为 embstr 编码的字符串对象编写任何相应的修改程序 （只有 int 编码的字符串对象和 raw 编码的字符串对象有这些程序）， 所以 embstr 编码的字符串对象实际上是只读的： 当我们对 embstr 编码的字符串对象执行任何修改命令时， 程序会先将对象的编码从 embstr 转换成 raw ， 然后再执行修改命令； 因为这个原因， embstr 编码的字符串对象在执行修改命令之后， 总会变成一个 raw 编码的字符串对象。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://harleylau.github.io/2018/05/09/Redis源码剖析-字符串t-string实现/" data-id="cjgzvfysx0001ts68e3mxlttx" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/">redis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码/">源码</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-tornado-websocket实现二维码扫描" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/12/tornado-websocket实现二维码扫描/" class="article-date">
  <time datetime="2018-02-12T04:17:11.000Z" itemprop="datePublished">2018-02-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/12/tornado-websocket实现二维码扫描/">tornado websocket实现二维码扫描</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Websocket-实现扫码二维码登录"><a href="#Websocket-实现扫码二维码登录" class="headerlink" title="Websocket 实现扫码二维码登录"></a>Websocket 实现扫码二维码登录</h2><p>首先简单的讲一下二维码实现登录的步骤：<br>1、网页端向服务端请求二维码，服务端生成一个二维码提供给网页端； 这个二维码其实是一个地址<br>2、客户端通过扫描网页端的二维码，跳转到二维码指向的地址， 然后通过鉴权验证机制，通知服务端鉴权的结果<br>3、客户端端根据不同的鉴权结果通知网页端做出相应的动作</p>
<p>对于步骤有了简单的概念之后， 我们可以显而易见的看到整个流程中主要需要解决的主要是两个问题：</p>
<p>1、如果处理用户的授权机制，保证用户权限的安全性</p>
<p>2、如何让网页端根据用户在客户端上的选择及时的做出不同的响应</p>
<p>针对第一个问题， 一方面，我们在生成二维码的时候，会同时生成一个唯一的session_id的标志，然后将其加入到二维码的url中， 当客户端扫描二维码跳转到指定地址的时候，能够根据session_id保证这个二维码是我们自己生成的； 另一方面， 客户端跳转过来的时候，会同时带上用户的id和用户的token， 通过id和token的验证保证用户的有效性，同时也能讲对应的session_id和用户id绑定，通知网页端是哪个用户扫描了这个二维码。</p>
<p>另外，多讲一点， 客户端扫描的同时带上来的用户id和用户的token，在实际使用的时候，我们是用户在登录的时候通过OAuth2.0的鉴权逻辑获取的， 所以能直接通过token验证安全性。</p>
<p>那么第二个问题， 如何及时的通知网页端做出变化呢。 这边一开始有两个方案： 一个是网页端采用轮询的机制，间隔一小段时间来询问服务端， 是否有用户扫描了这个二维码，以及扫描的结果； 另一个方案就是网页端在请求二维码的时候发起的就是一个websocket请求，这样网页端和服务端就能一直保持连接， 在客户端扫描二维码之后， 服务端就能够及时的通知到网页端，做到实时化。</p>
<p>两者的优缺点相信也比较明显， 在实际的开发过程中，我们采用了websocket的方式。 这边其实还有一个问题， 用户在客户端扫描二维码并授权了之后，如果通知到对应的网页端呢。 在网页端请求二维码的同时，我们会将当前的请求以session_id为key的方式进行注册， 当客户端扫描或者授权的时候，会将这个session_id带上来， 根据这个session_id就可以取到对应的请求，然后发回操作结果给网页端。</p>
<h2 id="tornado-websocket实现二维码扫描登录"><a href="#tornado-websocket实现二维码扫描登录" class="headerlink" title="tornado websocket实现二维码扫描登录"></a>tornado websocket实现二维码扫描登录</h2><h3 id="网页端请求二维码"><a href="#网页端请求二维码" class="headerlink" title="网页端请求二维码"></a>网页端请求二维码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">@router.Route(&apos;qrcode&apos;, name=&apos;ConnectQRcode&apos;)</div><div class="line">class ConnectQRcode(tornado.websocket.WebSocketHandler):</div><div class="line">    @tornado.gen.coroutine</div><div class="line">    def open(self):</div><div class="line">    	 #生成唯一的id，并带在url中</div><div class="line">        req_id = id(self)</div><div class="line">        url = &quot;https://xxxxxxx?uid=&quot; + uid + &quot;&amp;req_id=&quot; + str(req_id)</div><div class="line">        # 根据URL生成对应的二维码</div><div class="line">        q = qrcode.main.QRCode()</div><div class="line">        q.add_data(url)</div><div class="line">        q.make()</div><div class="line">        m = q.make_image()</div><div class="line">        png_name = &quot;static/&quot; + uid + &quot;.png&quot;</div><div class="line">        m.save(png_name)</div><div class="line">        # 注册回调函数</div><div class="line">        self.application.cart.register(req_id, self.callback)</div><div class="line">        # 返回二维码</div><div class="line">        self.write_message(&quot;https://xxxx/&quot; + png_name)</div><div class="line"></div><div class="line"></div><div class="line">    def on_close(self):</div><div class="line">    	# 关闭的时候删除掉注册的回调函数</div><div class="line">        self.application.cart.unregister(id(self), self.callback)</div><div class="line">        logging.info(&quot;remove register&quot;)</div><div class="line">        logging.info(&apos;WebSocket closed&apos;)</div><div class="line"></div><div class="line">    def callback(self, event, extra_info):</div><div class="line">        # 回调函数具体的操作</div><div class="line">        self.write_message(xxxx)</div></pre></td></tr></table></figure>
<h3 id="客户端扫描二维码"><a href="#客户端扫描二维码" class="headerlink" title="客户端扫描二维码"></a>客户端扫描二维码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@router.Route(&apos;/qrscan&apos;, name=&apos;qrscan&apos;)</div><div class="line">class ConnectQRscan(tornado.web.RequestHandler):</div><div class="line">    @tornado.gen.coroutine</div><div class="line">    def get(self):</div><div class="line">        try:</div><div class="line">            # 得到本次请求的req_id， 然后根据req_id调用对应的回调函数</div><div class="line">            req_id = self.get_argument(&apos;req_id&apos;, strip=False)</div><div class="line">            self.application.cart.notify(req_id, &quot;scan&quot;, &#123;&apos;req_id&apos;: req_id&#125;)</div><div class="line">            ret = &#123;&#125;</div><div class="line">        except Exception as e:</div><div class="line">            logging.error(&quot;qrscan error: %s&quot; % e)</div><div class="line">            ret = &#123;&apos;errorno&apos;: -1, &apos;errormsg&apos;: &quot;Error&quot;, &apos;data&apos;: None&#125;</div><div class="line">        self.write(ret)</div></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://harleylau.github.io/2018/02/12/tornado-websocket实现二维码扫描/" data-id="cjgzvfyu3000pts68u2mmqpvh" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/tornado/">tornado</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/websocket/">websocket</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/二维码/">二维码</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-tornado之WebSocket" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/12/tornado之WebSocket/" class="article-date">
  <time datetime="2018-02-12T03:29:39.000Z" itemprop="datePublished">2018-02-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/12/tornado之WebSocket/">tornado之WebSocket</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><p>WebSocket是HTML5开始提供的一种浏览器与服务器间进行全双工通讯的网络技术。 WebSocket通信协议于2011年被IETF定为标准RFC 6455，WebSocketAPI被W3C定为标准。 在WebSocket API中，浏览器和服务器只需要要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。</p>
<p>WebSocket是建立在 TCP 协议之上，与 HTTP 协议有着良好的兼容性。那么既然已经有了HTTP协议，为什么还需要一个WebSocket协议呢。这是因为HTTP只允许由客户端向服务端发送数据， 而无法直接由服务端主动向客户端推送信息。</p>
<p>WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端直接向客户端推送数据而不需要客户端进行请求，两者之间可以创建持久性的连接，并允许数据进行双向传送。WebSocket协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。</p>
<h3 id="1-Tornado的WebSocket模块"><a href="#1-Tornado的WebSocket模块" class="headerlink" title="1. Tornado的WebSocket模块"></a>1. Tornado的WebSocket模块</h3><p>Tornado提供支持WebSocket的模块是tornado.websocket，其中提供了一个WebSocketHandler类用来处理通讯。</p>
<p>WebSocketHandler.open()<br>当一个WebSocket连接建立后被调用。</p>
<p>WebSocketHandler.on_message(message)<br>当客户端发送消息message过来时被调用，注意此方法必须被重写。</p>
<p>WebSocketHandler.on_close()<br>当WebSocket连接关闭后被调用。</p>
<p>WebSocketHandler.write_message(message, binary=False)<br>向客户端发送消息messagea，message可以是字符串或字典（字典会被转为json字符串）。若binary为False，则message以utf8编码发送；二进制模式（binary=True）时，可发送任何字节码。</p>
<p>WebSocketHandler.close()<br>关闭WebSocket连接。</p>
<p>WebSocketHandler.check_origin(origin)<br>判断源origin，对于符合条件（返回判断结果为True）的请求源origin允许其连接，否则返回403。可以重写此方法来解决WebSocket的跨域请求（如始终return True）。</p>
<h3 id="2-WebSocket使用示例"><a href="#2-WebSocket使用示例" class="headerlink" title="2. WebSocket使用示例"></a>2. WebSocket使用示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class WebSocketHandler(tornado.websocket.WebSocketHandler):</div><div class="line">    def open(self):</div><div class="line">        self.application.cart.register(self.callback)</div><div class="line"></div><div class="line">    def on_close(self):</div><div class="line">        self.application.cart.unregister(self.callback)</div><div class="line"></div><div class="line">    def on_message(self):</div><div class="line">        pass</div><div class="line"></div><div class="line">    def callback(self,count):</div><div class="line">        self.write_message(&apos;&#123;&quot;count&quot;:&quot;%s&quot;&#125;&apos;%count)</div></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://harleylau.github.io/2018/02/12/tornado之WebSocket/" data-id="cjgzvfyv2001its68uvt1nf08" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/tornado/">tornado</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Redis源码剖析-字符串对象" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/09/12/Redis源码剖析-字符串对象/" class="article-date">
  <time datetime="2017-09-12T01:58:09.000Z" itemprop="datePublished">2017-09-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/12/Redis源码剖析-字符串对象/">Redis源码剖析--字符串对象</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>上一篇文章里分析了，字符串对象在redis的底层结构上有三种存储格式，分别是： int 、 raw 或者 embstr</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>编码</th>
<th>对象</th>
</tr>
</thead>
<tbody>
<tr>
<td>REDIS_STRING</td>
<td>REDIS_ENCODING_INT</td>
<td>使用整数值实现的字符串对象。</td>
</tr>
<tr>
<td>REDIS_STRING</td>
<td>REDIS_ENCODING_EMBSTR</td>
<td>使用 embstr 编码的简单动态字符串实现的字符串对象。</td>
</tr>
<tr>
<td>REDIS_STRING</td>
<td>REDIS_ENCODING_RAW</td>
<td>使用简单动态字符串实现的字符串对象。</td>
</tr>
</tbody>
</table>
<p>那么这三种底层表示分别在什么情况下使用呢。</p>
<ul>
<li>如果一个字符串对象保存的是整数值， 并且这个整数值可以用 long 类型来表示， 那么字符串对象会将整数值保存在字符串对象结构的 ptr 属性里面， 并将字符串对象的编码设置为 REDIS_ENCODING_INT 。</li>
<li>如果字符串对象保存的是一个字符串值， 并且这个字符串值的长度大于 39 字节， 那么字符串对象将使用一个简单动态字符串（SDS，这个之前的文章也分析过）来保存这个字符串值， 并将对象的编码设置为 raw 。</li>
<li>如果字符串对象保存的是一个字符串值， 并且这个字符串值的长度小于等于 39 字节， 那么字符串对象将使用 embstr 编码的方式来保存这个字符串值。</li>
</ul>
<p>int的表示比较简单， raw的表示我们之前也分析过，这边多了一个embstr的方式，简单的分析一下。</p>
<p>正常的创建Redis的对象，一般都需要创建两次，一次创建RedisObject结构，另一次创建ptr指向的实际存储的内容。比如raw 编码， 使用 redisObject 结构和 sdshdr 结构来表示字符串对象， 但 raw 编码会调用两次内存分配函数来分别创建 redisObject 结构和 sdshdr 结构。但是在存储比较小的字符串的时候，这边用了个小技巧，embstr 编码通过调用一次内存分配函数来分配一块连续的空间， 空间中依次包含 redisObject 和 sdshdr 两个结构。</p>
<h2 id="编码的转换"><a href="#编码的转换" class="headerlink" title="编码的转换"></a>编码的转换</h2><p>int 和 embstr 在一定的条件下，会转化为 raw 格式的字符串。</p>
<p>此外， int 编码的字符串对象和 raw 编码的字符串对象都能够进行修改，但是 Redis 没有为 embstr 编码的字符串对象编写任何相应的修改程序 ， 所以 embstr 编码的字符串对象实际上是只读的。</p>
<p>当我们需要修改 embstr 编码的字符串， 程序会先将对象的编码从 embstr 转换成 raw ， 然后再执行修改命令； 所以 embstr 编码的字符串对象在执行修改命令之后， 总会变成一个 raw 编码的字符串对象。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>int 编码的实现方法</th>
<th>embstr 编码的实现方法</th>
<th>raw 编码的实现方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>SET</td>
<td>使用 int 编码保存值。</td>
<td>使用 embstr 编码保存值。</td>
<td>使用 raw 编码保存值。</td>
</tr>
<tr>
<td>GET</td>
<td>拷贝对象所保存的整数值， 将这个拷贝转换成字符串值， 然后向客户端返回这个字符串值。</td>
<td>直接向客户端返回字符串值。</td>
<td>直接向客户端返回字符串值。</td>
</tr>
<tr>
<td>APPEND</td>
<td>将对象转换成 raw 编码， 然后按 raw 编码的方式执行此操作。</td>
<td>将对象转换成 raw 编码， 然后按 raw 编码的方式执行此操作。</td>
<td>调用 sdscatlen 函数， 将给定字符串追加到现有字符串的末尾。</td>
</tr>
<tr>
<td>INCRBYFLOAT</td>
<td>取出整数值并将其转换成 long double 类型的浮点数， 对这个浮点数进行加法计算， 然后将得出的浮点数结果保存起来。</td>
<td>取出字符串值并尝试将其转换成 long double 类型的浮点数， 对这个浮点数进行加法计算， 然后将得出的浮点数结果保存起来。 如果字符串值不能被转换成浮点数， 那么向客户端返回一个错误。</td>
<td>取出字符串值并尝试将其转换成 long double 类型的浮点数， 对这个浮点数进行加法计算， 然后将得出的浮点数结果保存起来。 如果字符串值不能被转换成浮点数， 那么向客户端返回一个错误。</td>
</tr>
<tr>
<td>INCRBY</td>
<td>对整数值进行加法计算， 得出的计算结果会作为整数被保存起来。</td>
<td>embstr 编码不能执行此命令， 向客户端返回一个错误。</td>
<td>raw 编码不能执行此命令， 向客户端返回一个错误。</td>
</tr>
<tr>
<td>DECRBY</td>
<td>对整数值进行减法计算， 得出的计算结果会作为整数被保存起来。</td>
<td>embstr 编码不能执行此命令， 向客户端返回一个错误。</td>
<td>raw 编码不能执行此命令， 向客户端返回一个错误。</td>
</tr>
<tr>
<td>STRLEN</td>
<td>拷贝对象所保存的整数值， 将这个拷贝转换成字符串值， 计算并返回这个字符串值的长度。</td>
<td>调用 sdslen 函数， 返回字符串的长度。</td>
<td>调用 sdslen 函数， 返回字符串的长度。</td>
</tr>
<tr>
<td>SETRANGE</td>
<td>将对象转换成 raw 编码， 然后按 raw 编码的方式执行此命令。</td>
<td>将对象转换成 raw 编码， 然后按 raw 编码的方式执行此命令。</td>
<td>将字符串特定索引上的值设置为给定的字符。</td>
</tr>
<tr>
<td>GETRANGE</td>
<td>拷贝对象所保存的整数值， 将这个拷贝转换成字符串值， 然后取出并返回字符串指定索引上的字符。</td>
<td>直接取出并返回字符串指定索引上的字符。</td>
<td>直接取出并返回字符串指定索引上的字符。</td>
</tr>
</tbody>
</table>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://harleylau.github.io/2017/09/12/Redis源码剖析-字符串对象/" data-id="cjgzvfytc0008ts68177fvxbi" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Redis源码剖析-对象Object" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/09/07/Redis源码剖析-对象Object/" class="article-date">
  <time datetime="2017-09-07T10:20:21.000Z" itemprop="datePublished">2017-09-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/07/Redis源码剖析-对象Object/">Redis源码剖析--对象Object</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>之前介绍的都是Redis的基础数据结构，比如简单动态字符串（SDS）、双端链表、字典、压缩列表、整数集合， 等等，不过Redis并没有直接用这些结构来实现键值对的数据库，而是对其进行了封装， 所有的键和值都是用对象Object来表示的。</p>
<p>Redis构建的对象分为5类， 字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象， 分别对应Redis操作中的string、list、hash、set和zset。</p>
<h2 id="对象的结构"><a href="#对象的结构" class="headerlink" title="对象的结构"></a>对象的结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">typedef struct redisObject &#123;</div><div class="line">    unsigned type:4;</div><div class="line">    unsigned encoding:4;</div><div class="line">    unsigned lru:LRU_BITS; // LRU_BITS为24</div><div class="line">    int refcount;</div><div class="line">    void *ptr;</div><div class="line">&#125; robj;</div></pre></td></tr></table></figure>
<p>type表示类型， encoding表示编码，prt表示指向底层数据实现的指针。</p>
<p>refcount用来实现基于引用计数技术的内存回收机制：通过引用计数技术实现了对象共享机制， 这一机制可以在适当的条件下， 通过让多个数据库键共享同一个对象来节约内存。</p>
<h3 id="类型type"><a href="#类型type" class="headerlink" title="类型type"></a>类型type</h3><p>上面说到Redis中有5中对象类型，对应的定义如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#define OBJ_STRING 0</div><div class="line">#define OBJ_LIST 1</div><div class="line">#define OBJ_SET 2</div><div class="line">#define OBJ_ZSET 3</div><div class="line">#define OBJ_HASH 4</div></pre></td></tr></table></figure>
<p>对于 Redis 数据库保存的键值对来说， 键总是一个字符串对象， 而值则可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象的其中一种。</p>
<h3 id="编码和底层实现"><a href="#编码和底层实现" class="headerlink" title="编码和底层实现"></a>编码和底层实现</h3><p>Redis对象的编码方式由encoding参数指定，也就是表示ptr指向的数据以何种数据结构作为底层实现。该字段也占用4个bit位。其取值和对应类型对应如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#define OBJ_ENCODING_RAW 0     /* Raw representation */</div><div class="line">#define OBJ_ENCODING_INT 1     /* Encoded as integer */</div><div class="line">#define OBJ_ENCODING_HT 2      /* Encoded as hash table */</div><div class="line">#define OBJ_ENCODING_ZIPMAP 3  /* Encoded as zipmap */</div><div class="line">#define OBJ_ENCODING_LINKEDLIST 4 /* Encoded as regular linked list */</div><div class="line">#define OBJ_ENCODING_ZIPLIST 5 /* Encoded as ziplist */</div><div class="line">#define OBJ_ENCODING_INTSET 6  /* Encoded as intset */</div><div class="line">#define OBJ_ENCODING_SKIPLIST 7  /* Encoded as skiplist */</div><div class="line">#define OBJ_ENCODING_EMBSTR 8  /* Embedded sds string encoding */</div><div class="line">#define OBJ_ENCODING_QUICKLIST 9 /* Encoded as linked list of ziplists */</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>编码常量</th>
<th>编码所对应的底层数据结构</th>
</tr>
</thead>
<tbody>
<tr>
<td>REDIS_ENCODING_INT</td>
<td>long 类型的整数</td>
</tr>
<tr>
<td>REDIS_ENCODING_EMBSTR</td>
<td>embstr 编码的简单动态字符串</td>
</tr>
<tr>
<td>REDIS_ENCODING_RAW</td>
<td>简单动态字符串</td>
</tr>
<tr>
<td>REDIS_ENCODING_HT</td>
<td>字典</td>
</tr>
<tr>
<td>REDIS_ENCODING_LINKEDLIST</td>
<td>双端链表</td>
</tr>
<tr>
<td>REDIS_ENCODING_ZIPLIST</td>
<td>压缩列表</td>
</tr>
<tr>
<td>REDIS_ENCODING_INTSET</td>
<td>整数集合</td>
</tr>
<tr>
<td>REDIS_ENCODING_SKIPLIST</td>
<td>跳跃表和字典</td>
</tr>
</tbody>
</table>
<p>Redis中的5中类型的对象，都对应着不止一种的底层实现</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>编码</th>
<th>对象</th>
</tr>
</thead>
<tbody>
<tr>
<td>REDIS_STRING</td>
<td>REDIS_ENCODING_INT</td>
<td>使用整数值实现的字符串对象。</td>
</tr>
<tr>
<td>REDIS_STRING</td>
<td>REDIS_ENCODING_EMBSTR</td>
<td>使用 embstr 编码的简单动态字符串实现的字符串对象。</td>
</tr>
<tr>
<td>REDIS_STRING</td>
<td>REDIS_ENCODING_RAW</td>
<td>使用简单动态字符串实现的字符串对象。</td>
</tr>
<tr>
<td>REDIS_LIST</td>
<td>REDIS_ENCODING_ZIPLIST</td>
<td>使用压缩列表实现的列表对象。</td>
</tr>
<tr>
<td>REDIS_LIST</td>
<td>REDIS_ENCODING_LINKEDLIST</td>
<td>使用双端链表实现的列表对象。</td>
</tr>
<tr>
<td>REDIS_HASH</td>
<td>REDIS_ENCODING_ZIPLIST</td>
<td>使用压缩列表实现的哈希对象。</td>
</tr>
<tr>
<td>REDIS_HASH</td>
<td>REDIS_ENCODING_HT</td>
<td>使用字典实现的哈希对象。</td>
</tr>
<tr>
<td>REDIS_SET</td>
<td>REDIS_ENCODING_INTSET</td>
<td>使用整数集合实现的集合对象。</td>
</tr>
<tr>
<td>REDIS_SET</td>
<td>REDIS_ENCODING_HT</td>
<td>使用字典实现的集合对象。</td>
</tr>
<tr>
<td>REDIS_ZSET</td>
<td>REDIS_ENCODING_ZIPLIST</td>
<td>使用压缩列表实现的有序集合对象。</td>
</tr>
<tr>
<td>REDIS_ZSET</td>
<td>REDIS_ENCODING_SKIPLIST</td>
<td>使用跳跃表和字典实现的有序集合对象。</td>
</tr>
</tbody>
</table>
<p>通过encoding参数来区分底层的实现，这样既灵活，也能节省内存。比如hash表的实现的时候，当元素比较少的时候，可以用压缩列表来实现；当元素不断增长，压缩列表失去优势的时候，就将其转化成hash table来实现。</p>
<p>之后几篇分别介绍 Redis 中的五种不同类型的对象， 说明这些对象底层所使用的编码方式。 由于每种对象类型都有不止一种底层结构，所以同时列出对象从一种编码转换成另一种编码所需的条件， 以及同一个命令在多种不同编码上的实现方法。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://harleylau.github.io/2017/09/07/Redis源码剖析-对象Object/" data-id="cjgzvfyte0009ts68jb9fqwcr" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/">redis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码/">源码</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-tornado-打印block日志" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/09/07/tornado-打印block日志/" class="article-date">
  <time datetime="2017-09-07T03:21:02.000Z" itemprop="datePublished">2017-09-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/07/tornado-打印block日志/">tornado--打印block日志</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Tornado在使用过程，碰到过性能瓶颈。 当碰到Tornado中有比较耗时的任务的时候，请求一多就会阻塞整个服务。这个时候就需要查看到底是什么任务阻塞了服务，然后针对性的进行优化。</p>
<p>Tornado使用logging打印日志，我们可以指定当某个请求的处理时间超过设定时间的时候，打印这个请求的stack trace。</p>
<p>源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">def set_blocking_log_threshold(self, seconds):</div><div class="line">       &quot;&quot;&quot;Logs a stack trace if the `IOLoop` is blocked for more than</div><div class="line">       ``s`` seconds.</div><div class="line"></div><div class="line">       Equivalent to ``set_blocking_signal_threshold(seconds,</div><div class="line">       self.log_stack)``</div><div class="line">       &quot;&quot;&quot;</div><div class="line">       self.set_blocking_signal_threshold(seconds, self.log_stack)</div></pre></td></tr></table></figure>
<p>如何使用呢，只需要在启动服务的时候设置block的时间即可，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line"></div><div class="line">    app = create_app()</div><div class="line"></div><div class="line">    server = tornado.httpserver.HTTPServer(app)</div><div class="line">    server.listen(options.port)</div><div class="line">    io_loop = tornado.ioloop.IOLoop.instance()</div><div class="line">    io_loop.set_blocking_log_threshold(0.5)</div><div class="line">    io_loop.start()</div></pre></td></tr></table></figure>
<p>如果某个请求的处理时间超过0.5秒，就会打印该请求的栈。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://harleylau.github.io/2017/09/07/tornado-打印block日志/" data-id="cjgzvfyuz001hts68nklzi1ta" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/tornado/">tornado</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Redis源码剖析-压缩列表" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/09/05/Redis源码剖析-压缩列表/" class="article-date">
  <time datetime="2017-09-05T01:51:55.000Z" itemprop="datePublished">2017-09-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/05/Redis源码剖析-压缩列表/">Redis源码剖析--压缩列表</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>压缩列表（ziplist）是列表键和哈希键的底层实现之一。<br>Redis的列表键，哈希键，有序集合的底层实现都用到了ziplist。</p>
<p>当列表键中包含比较少的元素，并且元素都是数字或者比较小的字符串的时候， redis会用压缩列表来作为列表键的底层实现。</p>
<p>当哈希键的键和值都是比较小的整数或者较短的字符的时候，也是用压缩列表来作为底层实现。 因为压缩列表也能够节省内存。</p>
<h2 id="压缩列表结构"><a href="#压缩列表结构" class="headerlink" title="压缩列表结构"></a>压缩列表结构</h2><p>压缩列表的结构如下：</p>
<p><img src="/2017/09/05/Redis源码剖析-压缩列表/ziplist.png" alt="压缩列表结构"></p>
<p>列表头包括三部分内容，分别是zlbytes，zltail，zllen</p>
<ul>
<li>zlbytes： 记录整个压缩列表占用的内存字节数：在对压缩列表进行内存重分配， 或者计算 zlend 的位置时使用。</li>
<li>zltail：记录压缩列表表尾节点距离压缩列表的起始地址有多少字节： 通过这个偏移量，程序无须遍历整个压缩列表就可以确定表尾节点的地址。</li>
<li>zllen：记录了压缩列表包含的节点数量： 当这个属性的值小于 UINT16_MAX （65535）时， 这个属性的值就是压缩列表包含节点的数量； 当这个值等于 UINT16_MAX 时， 节点的真实数量需要遍历整个压缩列表才能计算得出。</li>
</ul>
<p>压缩列表中间一次保存着各个列表项entry。</p>
<p>压缩列表尾部的zlend则表示压缩列表结束，其值固定为0xFF。</p>
<h3 id="压缩列表结点"><a href="#压缩列表结点" class="headerlink" title="压缩列表结点"></a>压缩列表结点</h3><p>先看结点的数据结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">typedef struct zlentry &#123;</div><div class="line">    unsigned int prevrawlensize, prevrawlen; // 前置节点长度和编码所需长度</div><div class="line">    unsigned int lensize, len; // 当前节点长度和编码所需长度</div><div class="line">    unsigned int headersize; // 头的大小</div><div class="line">    unsigned char encoding; // 编码类型</div><div class="line">    unsigned char *p; // 数据部分</div><div class="line">&#125; zlentry;</div></pre></td></tr></table></figure>
<p>每个压缩列表节点都由 previous_entry_length 、 encoding 、 content 三个部分组成。</p>
<h4 id="previous-entry-length"><a href="#previous-entry-length" class="headerlink" title="previous_entry_length"></a>previous_entry_length</h4><p>节点的 previous_entry_length 记录了压缩列表中前一个节点的长度。</p>
<p>previous_entry_length 属性的长度可以是 1 字节或者 5 字节：</p>
<ul>
<li>如果前一节点的长度小于 254 字节， 那么 previous_entry_length 属性的长度为 1 字节： 前一节点的长度就保存在这一个字节里面。</li>
<li>如果前一节点的长度大于等于 254 字节， 那么 previous_entry_length 属性的长度为 5 字节： 其中属性的第一字节会被设置为 0xFE （十进制值 254）， 而之后的四个字节则用于保存前一节点的长度。</li>
</ul>
<p>压缩列表zltail和previous_entry_length的存在，我们能够轻松得到一个列表的尾部，然后从尾部实现向前遍历整个压缩列表。</p>
<h4 id="encoding"><a href="#encoding" class="headerlink" title="encoding"></a>encoding</h4><p>压缩列表能够保存字节数组和整数，当读取压缩列表的时候，如何区分当前的结点存储的是字节数组还是整数呢，就需要靠encoding字段来判断。</p>
<h5 id="1、字节数组"><a href="#1、字节数组" class="headerlink" title="1、字节数组"></a>1、字节数组</h5><p>保存字节数组的时候，encoding字段可以是一字节、两字节或者五字节长， 值的最高位为 00 、 01 或者 10 ，数组的长度由编码除去最高两位之后的其他位记录。</p>
<table>
<thead>
<tr>
<th>编码</th>
<th>编码长度</th>
<th>content 属性保存的值</th>
</tr>
</thead>
<tbody>
<tr>
<td>00bbbbbb</td>
<td>1 字节</td>
<td>长度小于等于 63 字节的字节数组。</td>
</tr>
<tr>
<td>01bbbbbb xxxxxxxx</td>
<td>2 字节</td>
<td>长度小于等于 16383 字节的字节数组。</td>
</tr>
<tr>
<td>10<strong>__</strong> aaaaaaaa bbbbbbbb cccccccc dddddddd</td>
<td>5 字节</td>
<td>长度小于等于 4294967295 的字节数组。</td>
</tr>
</tbody>
</table>
<p>如上表所示，三种长度的字节数组分别用不同长度的encoding字段来表示，用来节省空间。 而encoding的前两位用来标记encoding本身的类型。</p>
<h5 id="2、整数"><a href="#2、整数" class="headerlink" title="2、整数"></a>2、整数</h5><p>保存整数的时候，encoding字段为一字节长， 值的最高位以 11 开头。 整数值的类型和长度由编码除去最高两位之后的其他位记录。</p>
<table>
<thead>
<tr>
<th>编码</th>
<th>编码长度</th>
<th>content 属性保存的值</th>
</tr>
</thead>
<tbody>
<tr>
<td>11000000</td>
<td>1 字节</td>
<td>int16_t 类型的整数。</td>
</tr>
<tr>
<td>11010000</td>
<td>1 字节</td>
<td>int32_t 类型的整数。</td>
</tr>
<tr>
<td>11100000</td>
<td>1 字节</td>
<td>int64_t 类型的整数。</td>
</tr>
<tr>
<td>11110000</td>
<td>1 字节</td>
<td>24 位有符号整数。</td>
</tr>
<tr>
<td>11111110</td>
<td>1 字节</td>
<td>8 位有符号整数。</td>
</tr>
<tr>
<td>1111xxxx</td>
<td>1 字节</td>
<td>使用这一编码的节点没有相应的 content 属性， 因为编码本身的 xxxx 四个位已经保存了一个介于 0 和 12 之间的值， 所以它无须 content 属性。</td>
</tr>
</tbody>
</table>
<p>当encoding最前两位字段为11的时候，表示当前结点为整数。 同时encoding的后几位用来表示不同的整数类型。可以看到后几位中用000000表示int16_t 类型的整数， 用010000表示int32_t 类型的整数， 用100000表示int64_t 类型的整数。</p>
<p>可以注意到，为了进一步节省内存，当编码为1111xxxx时，表示没有内容部分，xxxx已经存放了当前的整数值，包括整数0~12，即xxxx可以表示0000~1101。这样就节省了content的内存空间。这边编码为11111111代表ziplist的结尾。</p>
<h3 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h3><p>由于每个压缩列表的结点保存了上一个结点的大小，所以当前结点的变化有可能引起下一个结点的变化。如果前一节点的长度小于 254 字节， 那么 previous_entry_length 属性需要用 1 字节长的空间来保存这个长度值； 如果超过了254字节，这个属性值就需要 5 个字节的长度来保存。</p>
<p>所以最坏的情况下，压缩列表中某一个结点的更新，会引起所有结点的一个更新操作，就是所谓的连锁更新。</p>
<p>此外，插入或者删除结点也有可能引起连锁更新的操作。不过虽然连锁更新带来的消耗很大，但是仍旧可以放心的使用压缩列表，因为连锁更新引起的条件比较苛刻，概率比较小。 首先， 压缩列表里要恰好有多个连续的、长度介于 250 字节至 253 字节之间的节点， 连锁更新才有可能被引发， 在实际中， 这种情况并不多见；<br>其次， 即使出现连锁更新， 但只要被更新的节点数量不多， 就不会对性能造成任何影响： 比如说， 对三五个节点进行连锁更新是绝对不会影响性能的。</p>
<h2 id="压缩列表基本操作"><a href="#压缩列表基本操作" class="headerlink" title="压缩列表基本操作"></a>压缩列表基本操作</h2><h3 id="创建新的压缩列表"><a href="#创建新的压缩列表" class="headerlink" title="创建新的压缩列表"></a>创建新的压缩列表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/* Create a new empty ziplist. */</div><div class="line">unsigned char *ziplistNew(void) &#123;</div><div class="line">    // 空ziplist的大小为11个字节，头部10字节，尾部1字节</div><div class="line">    unsigned int bytes = ZIPLIST_HEADER_SIZE+1;</div><div class="line">    // 开辟空间</div><div class="line">    unsigned char *zl = zmalloc(bytes);</div><div class="line">    // 设定压缩列表的大小</div><div class="line">    ZIPLIST_BYTES(zl) = intrev32ifbe(bytes);</div><div class="line">    // 设置尾结点相对头部的偏移量</div><div class="line">    ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(ZIPLIST_HEADER_SIZE);</div><div class="line">    // 压缩列表结点数为0</div><div class="line">    ZIPLIST_LENGTH(zl) = 0;</div><div class="line">    // 设定尾部一个字节位0xFF</div><div class="line">    zl[bytes-1] = ZIP_END;</div><div class="line">    return zl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="插入结点"><a href="#插入结点" class="headerlink" title="插入结点"></a>插入结点</h3><p>由于连锁更新的存在，插入结点的复杂度平均 O(N) ，最坏 O(N^2)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div></pre></td><td class="code"><pre><div class="line">// ziplist插入节点只能往头或者尾部插入</div><div class="line">// zl: 待插入的ziplist</div><div class="line">// s，slen: 待插入节点和其长度</div><div class="line">// where: 带插入的位置，0代表头部插入，1代表尾部插入</div><div class="line">unsigned char *ziplistPush(unsigned char *zl, unsigned char *s, unsigned int slen, int where) &#123;</div><div class="line">    unsigned char *p;</div><div class="line">    // 获取插入的位置</div><div class="line">    p = (where == ZIPLIST_HEAD) ? ZIPLIST_ENTRY_HEAD(zl) : ZIPLIST_ENTRY_END(zl);</div><div class="line">    // 执行具体的插入过程</div><div class="line">    return __ziplistInsert(zl,p,s,slen);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Insert item at &quot;p&quot;. */</div><div class="line">unsigned char *__ziplistInsert(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen) &#123;</div><div class="line">    size_t curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), reqlen;</div><div class="line">    unsigned int prevlensize, prevlen = 0; // 前置节点长度和编码该长度值所需的长度</div><div class="line">    size_t offset;</div><div class="line">    int nextdiff = 0;</div><div class="line">    unsigned char encoding = 0;</div><div class="line">    long long value = 123456789; /* 为了防止警告，进行初始化；用一个比较特殊的值以便能够方便的观察到不恰当的使用 */</div><div class="line">    zlentry tail;</div><div class="line"></div><div class="line">    /* Find out prevlen for the entry that is inserted. */</div><div class="line">    if (p[0] != ZIP_END) &#123;</div><div class="line">        // 如果不是压缩列表的结束标志，说明p指向了一个已存在的结点</div><div class="line">        // 解码得到p的前置结点和长度</div><div class="line">        ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);</div><div class="line">    &#125; else &#123;</div><div class="line">        // 如果p指向列表末端，表示列表为空</div><div class="line">        unsigned char *ptail = ZIPLIST_ENTRY_TAIL(zl);</div><div class="line">        if (ptail[0] != ZIP_END) &#123;</div><div class="line">            prevlen = zipRawEntryLength(ptail);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* See if the entry can be encoded */</div><div class="line">    // 判断是否能够编码为整数</div><div class="line">    if (zipTryEncoding(s,slen,&amp;value,&amp;encoding)) &#123;</div><div class="line">        /* &apos;encoding&apos; is set to the appropriate integer encoding */</div><div class="line">        reqlen = zipIntSize(encoding);</div><div class="line">    &#125; else &#123;</div><div class="line">        /* &apos;encoding&apos; is untouched, however zipStoreEntryEncoding will use the</div><div class="line">         * string length to figure out how to encode it. */</div><div class="line">        // 编码为字节数组</div><div class="line">        reqlen = slen;</div><div class="line">    &#125;</div><div class="line">    /* We need space for both the length of the previous entry and</div><div class="line">     * the length of the payload. */</div><div class="line">    // 加上前置结点的编码长度和当前结点的编码长度</div><div class="line">    reqlen += zipStorePrevEntryLength(NULL,prevlen);</div><div class="line">    reqlen += zipStoreEntryEncoding(NULL,encoding,slen);</div><div class="line"></div><div class="line">    /* When the insert position is not equal to the tail, we need to</div><div class="line">     * make sure that the next entry can hold this entry&apos;s length in</div><div class="line">     * its prevlen field. */</div><div class="line">    // 如果不是插入到列表的末端，都需要判断下一个结点是否能存放新节点的长度编码</div><div class="line">    // nextdiff保存新旧编码之间的字节大小差，如果这个值大于0</div><div class="line">    // 那就说明当前p指向的节点的header进行扩展</div><div class="line">    int forcelarge = 0;</div><div class="line">    nextdiff = (p[0] != ZIP_END) ? zipPrevLenByteDiff(p,reqlen) : 0;</div><div class="line">    if (nextdiff == -4 &amp;&amp; reqlen &lt; 4) &#123;</div><div class="line">        nextdiff = 0;</div><div class="line">        forcelarge = 1;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* Store offset because a realloc may change the address of zl. */</div><div class="line">    // 保存偏移量</div><div class="line">    offset = p-zl;</div><div class="line">    // 重新分配空间，curlen当前列表的长度</div><div class="line">    // reqlen 新节点的全部长度</div><div class="line">    // nextdiff 新节点的后继节点扩展header的长度</div><div class="line">    zl = ziplistResize(zl,curlen+reqlen+nextdiff);</div><div class="line">    // 根据新的压缩列表地址得到新的p的地址</div><div class="line">    p = zl+offset;</div><div class="line"></div><div class="line">    /* Apply memory move when necessary and update tail offset. */</div><div class="line">    if (p[0] != ZIP_END) &#123;</div><div class="line">        // 如果不是表尾插入，需要更新表尾的偏移地址</div><div class="line">        /* Subtract one because of the ZIP_END bytes */</div><div class="line">        memmove(p+reqlen,p-nextdiff,curlen-offset-1+nextdiff);</div><div class="line"></div><div class="line">        /* Encode this entry&apos;s raw length in the next entry. */</div><div class="line">        // 编码新结点的长度到下一个结点中</div><div class="line">        if (forcelarge)</div><div class="line">            zipStorePrevEntryLengthLarge(p+reqlen,reqlen);</div><div class="line">        else</div><div class="line">            zipStorePrevEntryLength(p+reqlen,reqlen);</div><div class="line"></div><div class="line">        /* Update offset for tail */</div><div class="line">        ZIPLIST_TAIL_OFFSET(zl) =</div><div class="line">            intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+reqlen);</div><div class="line"></div><div class="line">        /* When the tail contains more than one entry, we need to take</div><div class="line">         * &quot;nextdiff&quot; in account as well. Otherwise, a change in the</div><div class="line">         * size of prevlen doesn&apos;t have an effect on the *tail* offset. */</div><div class="line">        zipEntry(p+reqlen, &amp;tail);</div><div class="line">        if (p[reqlen+tail.headersize+tail.len] != ZIP_END) &#123;</div><div class="line">            ZIPLIST_TAIL_OFFSET(zl) =</div><div class="line">                intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+nextdiff);</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        /* This element will be the new tail. */</div><div class="line">        ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(p-zl);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 如果nextdiff不等于0， 下一个结点的头部需要进行扩展</div><div class="line">    if (nextdiff != 0) &#123;</div><div class="line">        offset = p-zl;</div><div class="line">        zl = __ziplistCascadeUpdate(zl,p+reqlen);</div><div class="line">        p = zl+offset;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* Write the entry */</div><div class="line">    // 将新节点前置节点的长度写入新节点的header</div><div class="line">    p += zipStorePrevEntryLength(p,prevlen);</div><div class="line">    // 编码新结点</div><div class="line">    p += zipStoreEntryEncoding(p,encoding,slen);</div><div class="line">    if (ZIP_IS_STR(encoding)) &#123;</div><div class="line">        memcpy(p,s,slen);</div><div class="line">    &#125; else &#123;</div><div class="line">        zipSaveInteger(p,value,encoding);</div><div class="line">    &#125;</div><div class="line">    ZIPLIST_INCR_LENGTH(zl,1);</div><div class="line">    return zl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="查找结点"><a href="#查找结点" class="headerlink" title="查找结点"></a>查找结点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">/* 寻找节点值和 vstr 相等的列表节点，并返回该节点的指针。</div><div class="line"> * 每次比对之前都跳过 skip 个节点。</div><div class="line"> * 如果找不到相应的节点，则返回 NULL 。 */</div><div class="line">unsigned char *ziplistFind(unsigned char *p, unsigned char *vstr, unsigned int vlen, unsigned int skip) &#123;</div><div class="line">    int skipcnt = 0;</div><div class="line">    unsigned char vencoding = 0;</div><div class="line">    long long vll = 0;</div><div class="line"></div><div class="line">    // 循环直到碰到结束标志</div><div class="line">    while (p[0] != ZIP_END) &#123;</div><div class="line">        unsigned int prevlensize, encoding, lensize, len;</div><div class="line">        unsigned char *q;</div><div class="line"></div><div class="line">        // 解码得到前置结点的长度</div><div class="line">        ZIP_DECODE_PREVLENSIZE(p, prevlensize);</div><div class="line">        // 当前结点的长度</div><div class="line">        ZIP_DECODE_LENGTH(p + prevlensize, encoding, lensize, len);</div><div class="line">        q = p + prevlensize + lensize;</div><div class="line"></div><div class="line">        if (skipcnt == 0) &#123;</div><div class="line">            /* Compare current entry with specified entry */</div><div class="line">            // 如果是字节数组，直接比较</div><div class="line">            if (ZIP_IS_STR(encoding)) &#123;</div><div class="line">                if (len == vlen &amp;&amp; memcmp(q, vstr, vlen) == 0) &#123;</div><div class="line">                    return p;</div><div class="line">                &#125;</div><div class="line">            &#125; else &#123;</div><div class="line">                /* 查看目标值是否能被编码，只会在第一次循环的时候检查；</div><div class="line">                 * 检查一次之后vencoding会被置为非0 */</div><div class="line">                if (vencoding == 0) &#123;</div><div class="line">                    if (!zipTryEncoding(vstr, vlen, &amp;vll, &amp;vencoding)) &#123;</div><div class="line">                        /* 如果不能被编码，设置格式为UCHAR_MAX ， 下次不会再检查*/</div><div class="line">                        vencoding = UCHAR_MAX;</div><div class="line">                    &#125;</div><div class="line">                    /* Must be non-zero by now */</div><div class="line">                    assert(vencoding);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                /* Compare current entry with specified entry, do it only</div><div class="line">                 * if vencoding != UCHAR_MAX because if there is no encoding</div><div class="line">                 * possible for the field it can&apos;t be a valid integer. */</div><div class="line">                if (vencoding != UCHAR_MAX) &#123;</div><div class="line">                    long long ll = zipLoadInteger(q, encoding);</div><div class="line">                    if (ll == vll) &#123;</div><div class="line">                        return p;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            /* Reset skip count */</div><div class="line">            skipcnt = skip;</div><div class="line">        &#125; else &#123;</div><div class="line">            /* Skip entry */</div><div class="line">            skipcnt--;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        /* Move to next entry */</div><div class="line">        // 后移指针，指向后置节点</div><div class="line">        p = q + len;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return NULL;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="删除结点"><a href="#删除结点" class="headerlink" title="删除结点"></a>删除结点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line">// 删除给定节点，输入压缩列表zl和指向删除节点的指针p</div><div class="line">unsigned char *ziplistDelete(unsigned char *zl, unsigned char **p) &#123;</div><div class="line">    size_t offset = *p-zl;</div><div class="line">    // 调用底层函数__ziplistDelete进行删除操作</div><div class="line">    zl = __ziplistDelete(zl,*p,1);</div><div class="line">    // 删除操作可能会改变zl，因为会重新分配内存</div><div class="line">    *p = zl+offset;</div><div class="line">    return zl;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* 从位置 p 开始，连续删除 num 个节点。</div><div class="line"> * 函数的返回值为处理删除操作之后的 ziplist */</div><div class="line">unsigned char *__ziplistDelete(unsigned char *zl, unsigned char *p, unsigned int num) &#123;</div><div class="line">    unsigned int i, totlen, deleted = 0;</div><div class="line">    size_t offset;</div><div class="line">    int nextdiff = 0;</div><div class="line">    zlentry first, tail;</div><div class="line"></div><div class="line">    zipEntry(p, &amp;first);</div><div class="line">    // 计算被删除节点的总个数</div><div class="line">    for (i = 0; p[0] != ZIP_END &amp;&amp; i &lt; num; i++) &#123;</div><div class="line">        p += zipRawEntryLength(p);</div><div class="line">        deleted++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // totlen 是所有被删除节点总共占用的内存字节数</div><div class="line">    totlen = p-first.p; /* Bytes taken by the element(s) to delete. */</div><div class="line">    if (totlen &gt; 0) &#123;</div><div class="line">        if (p[0] != ZIP_END) &#123;</div><div class="line">            // 不是尾结点，表示被删除节点之后仍然有节点存在</div><div class="line">            </div><div class="line">            // 因为位于被删除范围之后的第一个节点的 header 部分的大小</div><div class="line">            // 可能容纳不了新的前置节点，所以需要计算新旧前置节点之间的字节数差</div><div class="line">            nextdiff = zipPrevLenByteDiff(p,first.prevrawlen);</div><div class="line"></div><div class="line">            /* Note that there is always space when p jumps backward: if</div><div class="line">             * the new previous entry is large, one of the deleted elements</div><div class="line">             * had a 5 bytes prevlen header, so there is for sure at least</div><div class="line">             * 5 bytes free and we need just 4. */</div><div class="line">            // 如果有需要的话，将指针 p 后退 nextdiff 字节，为新 header 空出空间</div><div class="line">            // 由于会删除之前的结点，所以肯定会有足够的空间用来扩展</div><div class="line">            p -= nextdiff;</div><div class="line">            // 将 first 的前置节点的长度编码至 p 中</div><div class="line">            zipStorePrevEntryLength(p,first.prevrawlen);</div><div class="line"></div><div class="line">            /* Update offset for tail */</div><div class="line">            ZIPLIST_TAIL_OFFSET(zl) =</div><div class="line">                intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))-totlen);</div><div class="line"></div><div class="line">            /* When the tail contains more than one entry, we need to take</div><div class="line">             * &quot;nextdiff&quot; in account as well. Otherwise, a change in the</div><div class="line">             * size of prevlen doesn&apos;t have an effect on the *tail* offset. */</div><div class="line">            // 如果被删除节点之后，有多于一个节点</div><div class="line">            // 那么程序需要将 nextdiff 记录的字节数也计算到表尾偏移量中</div><div class="line">            // 这样才能让表尾偏移量正确对齐表尾节点</div><div class="line">            zipEntry(p, &amp;tail);</div><div class="line">            if (p[tail.headersize+tail.len] != ZIP_END) &#123;</div><div class="line">                ZIPLIST_TAIL_OFFSET(zl) =</div><div class="line">                   intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+nextdiff);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            /* Move tail to the front of the ziplist */</div><div class="line">            // 从表尾向表头移动数据，覆盖被删除节点的数据</div><div class="line">            memmove(first.p,p,</div><div class="line">                intrev32ifbe(ZIPLIST_BYTES(zl))-(p-zl)-1);</div><div class="line">        &#125; else &#123;</div><div class="line">            /* The entire tail was deleted. No need to move memory. */</div><div class="line">            // 执行这里，表示被删除节点之后已经没有其他节点了， 不需要移动结点</div><div class="line">            ZIPLIST_TAIL_OFFSET(zl) =</div><div class="line">                intrev32ifbe((first.p-zl)-first.prevrawlen);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        /* Resize and update length */</div><div class="line">        // 缩小并更新 ziplist 的长度</div><div class="line">        offset = first.p-zl;</div><div class="line">        zl = ziplistResize(zl, intrev32ifbe(ZIPLIST_BYTES(zl))-totlen+nextdiff);</div><div class="line">        ZIPLIST_INCR_LENGTH(zl,-deleted);</div><div class="line">        p = zl+offset;</div><div class="line"></div><div class="line">        /* When nextdiff != 0, the raw length of the next entry has changed, so</div><div class="line">         * we need to cascade the update throughout the ziplist */</div><div class="line">        // 如果 p 所指向的节点的大小已经变更，那么进行级联更新</div><div class="line">        // 检查 p 之后的所有节点是否符合 ziplist 的编码要求</div><div class="line">        if (nextdiff != 0)</div><div class="line">            zl = __ziplistCascadeUpdate(zl,p);</div><div class="line">    &#125;</div><div class="line">    return zl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://harleylau.github.io/2017/09/05/Redis源码剖析-压缩列表/" data-id="cjgzvfyt40004ts6868jki7xx" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/">redis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码/">源码</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Redis源码剖析-整数集合" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/29/Redis源码剖析-整数集合/" class="article-date">
  <time datetime="2017-08-29T09:44:28.000Z" itemprop="datePublished">2017-08-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/29/Redis源码剖析-整数集合/">Redis源码剖析--整数集合</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>整数集合（intset）是集合键的底层实现之一： 当一个集合只包含整数值元素， 并且这个集合的元素数量不多时， Redis 就会使用整数集合作为集合键的底层实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; sadd numbers 1 2 3 4 5</div><div class="line">(integer) 5</div><div class="line">127.0.0.1:6379&gt; object encoding numbers</div><div class="line">&quot;intset&quot;</div></pre></td></tr></table></figure>
<p>这么做的好处是当集合中只有少量的整数元素的时候，采用之前介绍的其他数据结构，比如sds，都会占用比较大的内存，但如果仅保存为整数集合的话，则会更加经济。</p>
<h2 id="整数数组数据结构"><a href="#整数数组数据结构" class="headerlink" title="整数数组数据结构"></a>整数数组数据结构</h2><p>整数数组的定义位于intset.h中，具体如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">typedef struct intset &#123;</div><div class="line">    uint32_t encoding;  // 编码方式</div><div class="line">    uint32_t length;   // 保存的元素个数</div><div class="line">    int8_t contents[];  // 保存元素的数组</div><div class="line">&#125; intset;</div></pre></td></tr></table></figure>
<p>虽然 intset 结构将 contents 属性声明为 int8_t 类型的数组， 但实际上 contents 数组并不保存任何 int8_t 类型的值 —— contents 数组的真正类型取决于 encoding 属性的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">#define INTSET_ENC_INT16 (sizeof(int16_t))</div><div class="line">#define INTSET_ENC_INT32 (sizeof(int32_t))</div><div class="line">#define INTSET_ENC_INT64 (sizeof(int64_t))</div><div class="line"></div><div class="line">/* Return the required encoding for the provided value. */</div><div class="line">static uint8_t _intsetValueEncoding(int64_t v) &#123;</div><div class="line">    if (v &lt; INT32_MIN || v &gt; INT32_MAX)</div><div class="line">        return INTSET_ENC_INT64;</div><div class="line">    else if (v &lt; INT16_MIN || v &gt; INT16_MAX)</div><div class="line">        return INTSET_ENC_INT32;</div><div class="line">    else</div><div class="line">        return INTSET_ENC_INT16;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到一共会有三种类型，分别对应int_16, int_32, int_64。</p>
<p>整数数组中所有的元素在数组中按值的大小从小到大有序地排列， 并且数组中不包含任何重复项。</p>
<h2 id="整数集合操作"><a href="#整数集合操作" class="headerlink" title="整数集合操作"></a>整数集合操作</h2><h3 id="创建整数集合"><a href="#创建整数集合" class="headerlink" title="创建整数集合"></a>创建整数集合</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 初始化空的整数集合</div><div class="line">intset *intsetNew(void) &#123;</div><div class="line">    intset *is = zmalloc(sizeof(intset));</div><div class="line">    is-&gt;encoding = intrev32ifbe(INTSET_ENC_INT16); // 默认创建int_16的编码格式</div><div class="line">    is-&gt;length = 0;</div><div class="line">    return is;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="插入一个元素"><a href="#插入一个元素" class="headerlink" title="插入一个元素"></a>插入一个元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">/* Insert an integer in the intset */</div><div class="line">intset *intsetAdd(intset *is, int64_t value, uint8_t *success) &#123;</div><div class="line">    uint8_t valenc = _intsetValueEncoding(value);</div><div class="line">    uint32_t pos;</div><div class="line">    if (success) *success = 1;</div><div class="line"></div><div class="line">    // 如果超出了当前编码格式所能表示的范围，则升级整数集合并添加元素</div><div class="line">    if (valenc &gt; intrev32ifbe(is-&gt;encoding)) &#123;</div><div class="line">        /* This always succeeds, so we don&apos;t need to curry *success. */</div><div class="line">        return intsetUpgradeAndAdd(is,value);</div><div class="line">    &#125; else &#123;</div><div class="line">        // 如果元素已经存在于集合，success返回0</div><div class="line">        // 如果不存在的话， 这个函数会返回元素应该插入的位置pos</div><div class="line">        if (intsetSearch(is,value,&amp;pos)) &#123;</div><div class="line">            if (success) *success = 0;</div><div class="line">            return is;</div><div class="line">        &#125;</div><div class="line">        // 否则，需要重新调整集合的大小</div><div class="line">        is = intsetResize(is,intrev32ifbe(is-&gt;length)+1);</div><div class="line">        // 将pos之后的数据全都向后挪动一个位子</div><div class="line">        if (pos &lt; intrev32ifbe(is-&gt;length)) intsetMoveTail(is,pos,pos+1);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    _intsetSet(is,pos,value); // 添加数据到第pos位</div><div class="line">    is-&gt;length = intrev32ifbe(intrev32ifbe(is-&gt;length)+1); // 调整元素个数</div><div class="line">    return is;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在插入元素的时候，需要根据新元素的大小来重新确定所采用的编码。如果新元素超出了原有编码的表示范围，就需要调整编码，同时调整集合中所有其他元素的编码格式。调整编码是一个不可逆的过程，就是说只能从小的编码调整到大的编码，只能升级不能降级。</p>
<h3 id="升级过程"><a href="#升级过程" class="headerlink" title="升级过程"></a>升级过程</h3><p>升级整数集合并添加新元素调用的是intsetUpgradeAndAdd函数，共分为三步进行：</p>
<ul>
<li>根据新元素的类型， 扩展整数集合底层数组的空间大小， 并为新元素分配空间。</li>
<li>将底层数组现有的所有元素都转换成与新元素相同的类型， 并将类型转换后的元素放置到正确的位上， 而且在放置元素的过程中， 需要继续维持底层数组的有序性质不变。</li>
<li>将新元素添加到底层数组里面。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">/* Upgrades the intset to a larger encoding and inserts the given integer. */</div><div class="line">static intset *intsetUpgradeAndAdd(intset *is, int64_t value) &#123;</div><div class="line">    // 当前的编码</div><div class="line">    uint8_t curenc = intrev32ifbe(is-&gt;encoding);</div><div class="line">    // 根据新元素的值获得新的编码</div><div class="line">    uint8_t newenc = _intsetValueEncoding(value);</div><div class="line">    int length = intrev32ifbe(is-&gt;length);</div><div class="line">    // 由于整数集合是一个有序集合，所以新的这个超出范围的元素，要不插入头部，要不插入尾部</div><div class="line">    // 当value大于0的时候，就是插入到尾部，否则插入到头部，用参数prepend来标记</div><div class="line">    int prepend = value &lt; 0 ? 1 : 0;</div><div class="line"></div><div class="line">    /* First set new encoding and resize */</div><div class="line">    // 重新设置整数集合的编码</div><div class="line">    is-&gt;encoding = intrev32ifbe(newenc);</div><div class="line">    // 根据新编码调整整数集合的大小</div><div class="line">    is = intsetResize(is,intrev32ifbe(is-&gt;length)+1);</div><div class="line"></div><div class="line"></div><div class="line">    // 从尾部向头部进行升级，这样在挪动其中的元素的时候，不会覆盖原来的值</div><div class="line">    while(length--)</div><div class="line">        // 如果新元素是插入到尾部，prepend==0， 所以原来最后的元素是挪动到length位置</div><div class="line">        // 如果新元素是插入到头部，prepend==1，所有的元素都要向后挪动一个位置，将头部空出来</div><div class="line">        _intsetSet(is,length+prepend,_intsetGetEncoded(is,length,curenc));</div><div class="line"></div><div class="line">    /* Set the value at the beginning or the end. */</div><div class="line">    if (prepend)</div><div class="line">        // 如果prepend==1， 插入到头部</div><div class="line">        _intsetSet(is,0,value);</div><div class="line">    else</div><div class="line">        // 否则，设置最后一个位置的元素为value</div><div class="line">        _intsetSet(is,intrev32ifbe(is-&gt;length),value);</div><div class="line">    // 元素个数加1</div><div class="line">    is-&gt;length = intrev32ifbe(intrev32ifbe(is-&gt;length)+1);</div><div class="line">    return is;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而整数集合现在的做法既可以让集合能同时保存三种不同类型的值， 又可以确保升级操作只会在有需要的时候进行， 这可以尽量节省内存。</p>
<h3 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h3><p>查找的时候，需要先判断要查找的元素是否在当前编码的有效范围内，如果不在当前范围内，可以直接返回。</p>
<p>另外因为整数集合是一个有序集合，可以采用二分查找的办法，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">uint8_t intsetFind(intset *is, int64_t value) &#123;</div><div class="line">    // 获得目标值的编码</div><div class="line">    uint8_t valenc = _intsetValueEncoding(value);</div><div class="line">    // 只有目标值的编码比当前编码小，才继续执行查找过程</div><div class="line">    return valenc &lt;= intrev32ifbe(is-&gt;encoding) &amp;&amp; intsetSearch(is,value,NULL);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 如果找到这个元素，返回1，同时pos表示这个值在整数集合里边的位置</div><div class="line">// 如果没有找到这个元素，返回0， 同时pos表示这个值可以插入的位置</div><div class="line">static uint8_t intsetSearch(intset *is, int64_t value, uint32_t *pos) &#123;</div><div class="line">    int min = 0, max = intrev32ifbe(is-&gt;length)-1, mid = -1;</div><div class="line">    int64_t cur = -1;</div><div class="line"></div><div class="line">    /* The value can never be found when the set is empty */</div><div class="line">    // 如果集合的长度为0， 直接返回0</div><div class="line">    if (intrev32ifbe(is-&gt;length) == 0) &#123;</div><div class="line">        if (pos) *pos = 0;</div><div class="line">        return 0;</div><div class="line">    &#125; else &#123;</div><div class="line">        /* Check for the case where we know we cannot find the value,</div><div class="line">         * but do know the insert position. */</div><div class="line">        // 如果目标值大于当前最大值，肯定找不到，返回0， 同时待插入的位置pos为length</div><div class="line">        if (value &gt; _intsetGet(is,intrev32ifbe(is-&gt;length)-1)) &#123;</div><div class="line">            if (pos) *pos = intrev32ifbe(is-&gt;length);</div><div class="line">            return 0;</div><div class="line">        &#125; else if (value &lt; _intsetGet(is,0)) &#123;</div><div class="line">            // 如果目标址小于当前最小值，返回0， 同时待插入的位置pos为0</div><div class="line">            if (pos) *pos = 0;</div><div class="line">            return 0;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 二分查找</div><div class="line">    while(max &gt;= min) &#123;</div><div class="line">        // 得到中间位置</div><div class="line">        mid = ((unsigned int)min + (unsigned int)max) &gt;&gt; 1;</div><div class="line">        // 得到中间位置的值</div><div class="line">        cur = _intsetGet(is,mid);</div><div class="line">        if (value &gt; cur) &#123;</div><div class="line">            min = mid+1;</div><div class="line">        &#125; else if (value &lt; cur) &#123;</div><div class="line">            max = mid-1;</div><div class="line">        &#125; else &#123;</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (value == cur) &#123;</div><div class="line">        if (pos) *pos = mid;</div><div class="line">        return 1;</div><div class="line">    &#125; else &#123;</div><div class="line">        if (pos) *pos = min;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://harleylau.github.io/2017/08/29/Redis源码剖析-整数集合/" data-id="cjgzvfytn000fts687r007z79" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/">redis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码/">源码</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Redis源码剖析-跳跃表" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/24/Redis源码剖析-跳跃表/" class="article-date">
  <time datetime="2017-08-24T02:46:04.000Z" itemprop="datePublished">2017-08-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/24/Redis源码剖析-跳跃表/">Redis源码剖析--跳跃表</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>跳跃表（skiplist）是一种有序数据结构， 它通过在每个节点中维持多个指向其他节点的指针， 从而达到快速访问节点的目的。</p>
<p>跳跃表支持平均 O(\log N) 最坏 O(N) 复杂度的节点查找， 还可以通过顺序性操作来批量处理节点。</p>
<p>在大部分情况下， 跳跃表的效率可以和平衡树相媲美， 并且因为跳跃表的实现比平衡树要来得更为简单， 所以有不少程序都使用跳跃表来代替平衡树。</p>
<p>Redis 使用跳跃表作为有序集合键的底层实现之一： 如果一个有序集合包含的元素数量比较多， 又或者有序集合中元素的成员（member）是比较长的字符串时， Redis 就会使用跳跃表来作为有序集合键的底层实现。</p>
<p>和链表、字典等数据结构被广泛地应用在 Redis 内部不同， Redis 只在两个地方用到了跳跃表， 一个是实现有序集合键， 另一个是在集群节点中用作内部数据结构， 除此之外， 跳跃表在 Redis 里面没有其他用途。</p>
<p>先看一下维基百科对跳跃表的图示：<br><img src="/2017/08/24/Redis源码剖析-跳跃表/Skip_list.svg" alt="logo"></p>
<p>从图中可以看到， 跳跃表主要由以下部分构成：</p>
<ul>
<li>表头（head）：负责维护跳跃表的节点指针。</li>
<li>跳跃表节点：保存着元素值，以及多个层。</li>
<li>层：保存着指向其他元素的指针。高层的指针越过的元素数量大于等于低层的指针，为了提高查找的效率，程序总是从高层先开始访问，然后随着元素值范围的缩小，慢慢降低层次。</li>
<li>表尾：全部由 NULL 组成，表示跳跃表的末尾。</li>
</ul>
<h2 id="跳跃表结构定义"><a href="#跳跃表结构定义" class="headerlink" title="跳跃表结构定义"></a>跳跃表结构定义</h2><p>跳跃表的结构体定义在server.h文件中。其中包括跳跃表节点zskiplistNode和跳跃表zskiplist两个结构体。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/* ZSETs use a specialized version of Skiplists */</div><div class="line">typedef struct zskiplistNode &#123;</div><div class="line">    sds ele;   // 具体成员对象</div><div class="line">    double score;   // 成员分值</div><div class="line">    struct zskiplistNode *backward;  // 向后索引指针</div><div class="line">    struct zskiplistLevel &#123;    // 跳跃表层</div><div class="line">        struct zskiplistNode *forward;  // 前向索引指针</div><div class="line">        unsigned int span;    // 这一层的跨度</div><div class="line">    &#125; level[];</div><div class="line">&#125; zskiplistNode;</div><div class="line"></div><div class="line">typedef struct zskiplist &#123;</div><div class="line">    struct zskiplistNode *header, *tail;   // 头尾结点</div><div class="line">    unsigned long length;    // 总的结点数</div><div class="line">    int level;    // 总的层数</div><div class="line">&#125; zskiplist;</div></pre></td></tr></table></figure>
<p>每次创建一个新跳跃表节点的时候， 程序都根据幂次定律 （power law，越大的数出现的概率越小） 随机生成一个介于 1 和 32 之间的值作为 level 数组的大小， 这个大小就是层的“高度”。</p>
<p>总的层数保存在zskiplist的level参数中， 另外每个节点保存了各自层中的指针以及这一层的跨度。</p>
<h2 id="跳跃表操作"><a href="#跳跃表操作" class="headerlink" title="跳跃表操作"></a>跳跃表操作</h2><h3 id="创建跳跃表"><a href="#创建跳跃表" class="headerlink" title="创建跳跃表"></a>创建跳跃表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">/* Create a skiplist node with the specified number of levels.</div><div class="line"> * The SDS string &apos;ele&apos; is referenced by the node after the call. */</div><div class="line"> // 创建跳跃表结点</div><div class="line">zskiplistNode *zslCreateNode(int level, double score, sds ele) &#123;</div><div class="line">    // 开辟内存，根据传入的层数设置大小</div><div class="line">    zskiplistNode *zn =</div><div class="line">        zmalloc(sizeof(*zn)+level*sizeof(struct zskiplistLevel));</div><div class="line">    // 赋值跳跃表结点分值</div><div class="line">    zn-&gt;score = score;</div><div class="line">    // 赋值跳跃表结点对象</div><div class="line">    zn-&gt;ele = ele;</div><div class="line">    return zn;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* 创建跳跃表 */</div><div class="line">zskiplist *zslCreate(void) &#123;</div><div class="line">    int j;</div><div class="line">    zskiplist *zsl;</div><div class="line">    // 申请内存</div><div class="line">    zsl = zmalloc(sizeof(*zsl));</div><div class="line">    // 设置层数为1</div><div class="line">    zsl-&gt;level = 1;</div><div class="line">    // 总的结点数为0</div><div class="line">    zsl-&gt;length = 0;</div><div class="line">    // ZSKIPLIST_MAXLEVEL=32, 头结点，设置最大层数，分值为0， 具体对象为NULL</div><div class="line">    zsl-&gt;header = zslCreateNode(ZSKIPLIST_MAXLEVEL,0,NULL);</div><div class="line">    // 循环设置头结点的每一层的前向指针为NULL，跨度为0</div><div class="line">    for (j = 0; j &lt; ZSKIPLIST_MAXLEVEL; j++) &#123;</div><div class="line">        zsl-&gt;header-&gt;level[j].forward = NULL;</div><div class="line">        zsl-&gt;header-&gt;level[j].span = 0;</div><div class="line">    &#125;</div><div class="line">    // 头结点的后向指针为NULL</div><div class="line">    zsl-&gt;header-&gt;backward = NULL;</div><div class="line">    zsl-&gt;tail = NULL;</div><div class="line">    return zsl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>创建跳跃表的时候设置层数为1， 只有一个头结点，头结点保存了最大的层数，同时所有的前向指针都为NULL。</p>
<h3 id="释放整个跳跃表"><a href="#释放整个跳跃表" class="headerlink" title="释放整个跳跃表"></a>释放整个跳跃表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">/* Free the specified skiplist node. The referenced SDS string representation</div><div class="line"> * of the element is freed too, unless node-&gt;ele is set to NULL before calling</div><div class="line"> * this function. */</div><div class="line">void zslFreeNode(zskiplistNode *node) &#123;</div><div class="line">    sdsfree(node-&gt;ele);</div><div class="line">    zfree(node);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* 释放整个跳跃表. */</div><div class="line">void zslFree(zskiplist *zsl) &#123;</div><div class="line">    // 从最底层的level[0]依次遍历，释放</div><div class="line">    zskiplistNode *node = zsl-&gt;header-&gt;level[0].forward, *next;</div><div class="line"></div><div class="line">    zfree(zsl-&gt;header);</div><div class="line">    // 如果存在后续结点</div><div class="line">    while(node) &#123;</div><div class="line">        next = node-&gt;level[0].forward;</div><div class="line">        // 释放结点</div><div class="line">        zslFreeNode(node);</div><div class="line">        node = next;</div><div class="line">    &#125;</div><div class="line">    zfree(zsl);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="跳跃表插入元素"><a href="#跳跃表插入元素" class="headerlink" title="跳跃表插入元素"></a>跳跃表插入元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line">/* Insert a new node in the skiplist. Assumes the element does not already</div><div class="line"> * exist (up to the caller to enforce that). The skiplist takes ownership</div><div class="line"> * of the passed SDS string &apos;ele&apos;. */</div><div class="line"> // 跳跃表插入元素</div><div class="line">zskiplistNode *zslInsert(zskiplist *zsl, double score, sds ele) &#123;</div><div class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</div><div class="line">    unsigned int rank[ZSKIPLIST_MAXLEVEL];</div><div class="line">    int i, level;</div><div class="line"></div><div class="line">    serverAssert(!isnan(score));   　// 判断是否为数字</div><div class="line">    x = zsl-&gt;header;</div><div class="line">    // 从最高的level， 也即跨度最大的level开始查找结点</div><div class="line">    for (i = zsl-&gt;level-1; i &gt;= 0; i--) &#123;</div><div class="line">        /* store rank that is crossed to reach the insert position */</div><div class="line">        // 当前是否是最高层， 如果是最高层，rank[i]=0，否则，复制上一层的数值</div><div class="line">        rank[i] = i == (zsl-&gt;level-1) ? 0 : rank[i+1];</div><div class="line">        // 如果当前结点的score值小于传入的score 或者 当前score相等，但是结点的对象不相等</div><div class="line">        while (x-&gt;level[i].forward &amp;&amp;</div><div class="line">                (x-&gt;level[i].forward-&gt;score &lt; score ||</div><div class="line">                    (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</div><div class="line">                    sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt; 0)))</div><div class="line">        &#123;</div><div class="line">            // 将当前一层的跨度加到rank[i]</div><div class="line">            rank[i] += x-&gt;level[i].span;</div><div class="line">            // 在当前层中向前查找</div><div class="line">            x = x-&gt;level[i].forward;</div><div class="line">        &#125;</div><div class="line">        // 当前层位于插入位置前的结点x放入update数组</div><div class="line">        update[i] = x;</div><div class="line">    &#125;</div><div class="line">    /* we assume the element is not already inside, since we allow duplicated</div><div class="line">     * scores, reinserting the same element should never happen since the</div><div class="line">     * caller of zslInsert() should test in the hash table if the element is</div><div class="line">     * already inside or not. */</div><div class="line">    // 随机生成小于32的层数</div><div class="line">    level = zslRandomLevel();</div><div class="line">    // 如果生成的层数大于当前的层数</div><div class="line">    if (level &gt; zsl-&gt;level) &#123;</div><div class="line">        for (i = zsl-&gt;level; i &lt; level; i++) &#123;</div><div class="line">            // 设定rank数组中大于原level层以上的值为0</div><div class="line">            // 同时设定update数组大于原level层以上的数据</div><div class="line">            rank[i] = 0;</div><div class="line">            update[i] = zsl-&gt;header;</div><div class="line">            update[i]-&gt;level[i].span = zsl-&gt;length;</div><div class="line">        &#125;</div><div class="line">        zsl-&gt;level = level;</div><div class="line">    &#125;</div><div class="line">    // 创建层数为level的新结点</div><div class="line">    x = zslCreateNode(level,score,ele);</div><div class="line">    for (i = 0; i &lt; level; i++) &#123;</div><div class="line">        // 将每一层的前置结点的后续结点指向新结点， 同时设置新结点的后续结点</div><div class="line">        x-&gt;level[i].forward = update[i]-&gt;level[i].forward;</div><div class="line">        update[i]-&gt;level[i].forward = x;</div><div class="line"></div><div class="line">        /* update span covered by update[i] as x is inserted here */</div><div class="line">        // 更新每一层的前置结点和新结点的跨度</div><div class="line">        x-&gt;level[i].span = update[i]-&gt;level[i].span - (rank[0] - rank[i]);</div><div class="line">        update[i]-&gt;level[i].span = (rank[0] - rank[i]) + 1;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* increment span for untouched levels */</div><div class="line">    for (i = level; i &lt; zsl-&gt;level; i++) &#123;</div><div class="line">        update[i]-&gt;level[i].span++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 根据最低层的前序结点是否是header结点来设置当前新结点的向后指针</div><div class="line">    x-&gt;backward = (update[0] == zsl-&gt;header) ? NULL : update[0];</div><div class="line">    if (x-&gt;level[0].forward)</div><div class="line">        x-&gt;level[0].forward-&gt;backward = x;</div><div class="line">    else</div><div class="line">        zsl-&gt;tail = x;</div><div class="line">    zsl-&gt;length++;</div><div class="line">    return x;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先看图示，如果想要插入score=5的结点（redis中允许score值重复），那么首选需要找到score=5的结点，查找的顺序为：</p>
<p><img src="/2017/08/24/Redis源码剖析-跳跃表/WX20170824-181328.png" alt="logo"></p>
<p>从最大的层向后查找，如果当前层后边没有值了，并且当前结点的值小于要找的值，就查找下一层结点；如果下一个结点的值大于要找的值，也会到下一层结点继续查找。</p>
<p>找到对应的位置执行插入操作后，需要为新结点设置层数，那么设置多少层合适呢，这边直接采用了一个随机数。随机数生成了多少层，当前新结点的层数就设置多少层。</p>
<p>如果新层数小于原来的层数，只需要重新设置前序后置结点的指针和跨度就行；如果新层数大于原来的层数，就需要额外设置新的更高的层。</p>
<p>那么插入结点之后，如何修改前序和后置结点的指针和跨度呢。这边用了两个数组来记录，分别是update和rank。update用来记录每一层中插入位置的前序结点，到时候根据这个前序结点设置每一层的指针调整。 rank用来记录每一层到新结点的跨度，插入新结点之后，根据rank数组中记录跨度更新前置结点的跨度值。</p>
<h3 id="删除跳跃表结点"><a href="#删除跳跃表结点" class="headerlink" title="删除跳跃表结点"></a>删除跳跃表结点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"> /* 删除结点，如果结点存在并删除，返回1， 否则返回0</div><div class="line">    参数中node如果是空的，则结点确实被删除； 如果非空，只是把结点从链表上摘下来，返回指针给node*/</div><div class="line">int zslDelete(zskiplist *zsl, double score, sds ele, zskiplistNode **node) &#123;</div><div class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</div><div class="line">    int i;</div><div class="line"></div><div class="line">    x = zsl-&gt;header;</div><div class="line">    // 查找对应结点</div><div class="line">    for (i = zsl-&gt;level-1; i &gt;= 0; i--) &#123;</div><div class="line">        while (x-&gt;level[i].forward &amp;&amp;</div><div class="line">                (x-&gt;level[i].forward-&gt;score &lt; score ||</div><div class="line">                    (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</div><div class="line">                     sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt; 0)))</div><div class="line">        &#123;</div><div class="line">            x = x-&gt;level[i].forward;</div><div class="line">        &#125;</div><div class="line">        update[i] = x;</div><div class="line">    &#125;</div><div class="line">    /* We may have multiple elements with the same score, what we need</div><div class="line">     * is to find the element with both the right score and object. */</div><div class="line">    // 由于允许存在相同的score，需要在score和ele都满足的条件下才能删除</div><div class="line">    x = x-&gt;level[0].forward;</div><div class="line">    if (x &amp;&amp; score == x-&gt;score &amp;&amp; sdscmp(x-&gt;ele,ele) == 0) &#123;</div><div class="line">        zslDeleteNode(zsl, x, update);</div><div class="line">        if (!node)</div><div class="line">            zslFreeNode(x);</div><div class="line">        else</div><div class="line">            *node = x;</div><div class="line">        return 1;</div><div class="line">    &#125;</div><div class="line">    return 0; /* not found */</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>具体的结点删除操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">/* Internal function used by zslDelete, zslDeleteByScore and zslDeleteByRank */</div><div class="line">// update数组保存了所有层上要删除结点的前置结点</div><div class="line">void zslDeleteNode(zskiplist *zsl, zskiplistNode *x, zskiplistNode **update) &#123;</div><div class="line">    int i;</div><div class="line">    for (i = 0; i &lt; zsl-&gt;level; i++) &#123;</div><div class="line">        if (update[i]-&gt;level[i].forward == x) &#123;</div><div class="line">            // 如果当前层有指针指向要删除的结点，前置结点的跨度需要加上当前结点的跨度，同时更新指针</div><div class="line">            update[i]-&gt;level[i].span += x-&gt;level[i].span - 1;</div><div class="line">            update[i]-&gt;level[i].forward = x-&gt;level[i].forward;</div><div class="line">        &#125; else &#123;</div><div class="line">            // 否则，只需要将前置结点的跨度减1即可，因为少了一个结点啊</div><div class="line">            update[i]-&gt;level[i].span -= 1;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    // 修改backward指针，需要考虑x是否为尾节点</div><div class="line">    if (x-&gt;level[0].forward) &#123;</div><div class="line">        x-&gt;level[0].forward-&gt;backward = x-&gt;backward;</div><div class="line">    &#125; else &#123;</div><div class="line">        zsl-&gt;tail = x-&gt;backward;</div><div class="line">    &#125;</div><div class="line">    while(zsl-&gt;level &gt; 1 &amp;&amp; zsl-&gt;header-&gt;level[zsl-&gt;level-1].forward == NULL)</div><div class="line">        zsl-&gt;level--;</div><div class="line">    zsl-&gt;length--;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://harleylau.github.io/2017/08/24/Redis源码剖析-跳跃表/" data-id="cjgzvfytk000cts68h1hxdk5k" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/">redis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码/">源码</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Redis源码剖析-dict遍历算法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/02/Redis源码剖析-dict遍历算法/" class="article-date">
  <time datetime="2017-08-02T08:08:16.000Z" itemprop="datePublished">2017-08-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/02/Redis源码剖析-dict遍历算法/">Redis源码剖析-dict遍历算法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>先贴一下整体的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line">unsigned long dictScan(dict *d,</div><div class="line">                       unsigned long v,</div><div class="line">                       dictScanFunction *fn,</div><div class="line">                       dictScanBucketFunction* bucketfn,</div><div class="line">                       void *privdata)</div><div class="line">&#123;</div><div class="line">    dictht *t0, *t1;</div><div class="line">    const dictEntry *de, *next;</div><div class="line">    unsigned long m0, m1;</div><div class="line"></div><div class="line">    // 跳过空字典</div><div class="line">    if (dictSize(d) == 0) return 0;</div><div class="line"></div><div class="line">    // 如果没有rehash，迭代一个哈希表的字典</div><div class="line">    if (!dictIsRehashing(d)) &#123;</div><div class="line">        t0 = &amp;(d-&gt;ht[0]);</div><div class="line">        m0 = t0-&gt;sizemask;</div><div class="line"></div><div class="line">        /* Emit entries at cursor */</div><div class="line">        if (bucketfn) bucketfn(privdata, &amp;t0-&gt;table[v &amp; m0]);</div><div class="line">        de = t0-&gt;table[v &amp; m0];</div><div class="line">        while (de) &#123;</div><div class="line">            next = de-&gt;next;</div><div class="line">            fn(privdata, de);</div><div class="line">            de = next;</div><div class="line">        &#125;</div><div class="line">    // 迭代有两个哈希表的字典</div><div class="line">    &#125; else &#123;</div><div class="line">        t0 = &amp;d-&gt;ht[0];</div><div class="line">        t1 = &amp;d-&gt;ht[1];</div><div class="line"></div><div class="line">        /* Make sure t0 is the smaller and t1 is the bigger table */</div><div class="line">        // 确保 t0 比 t1 要小</div><div class="line">        if (t0-&gt;size &gt; t1-&gt;size) &#123;</div><div class="line">            t0 = &amp;d-&gt;ht[1];</div><div class="line">            t1 = &amp;d-&gt;ht[0];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        m0 = t0-&gt;sizemask;</div><div class="line">        m1 = t1-&gt;sizemask;</div><div class="line"></div><div class="line">        /* Emit entries at cursor */</div><div class="line">        if (bucketfn) bucketfn(privdata, &amp;t0-&gt;table[v &amp; m0]);</div><div class="line">        de = t0-&gt;table[v &amp; m0];</div><div class="line">        while (de) &#123;</div><div class="line">            next = de-&gt;next;</div><div class="line">            fn(privdata, de);</div><div class="line">            de = next;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        /* Iterate over indices in larger table that are the expansion</div><div class="line">         * of the index pointed to by the cursor in the smaller table */</div><div class="line">        do &#123;</div><div class="line">            /* Emit entries at cursor */</div><div class="line">            if (bucketfn) bucketfn(privdata, &amp;t1-&gt;table[v &amp; m1]);</div><div class="line">            de = t1-&gt;table[v &amp; m1];</div><div class="line">            while (de) &#123;</div><div class="line">                next = de-&gt;next;</div><div class="line">                fn(privdata, de);</div><div class="line">                de = next;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            /* Increment bits not covered by the smaller mask */</div><div class="line">            v = (((v | m0) + 1) &amp; ~m0) | (v &amp; m0);</div><div class="line"></div><div class="line">            /* Continue while bits covered by mask difference is non-zero */</div><div class="line">        &#125; while (v &amp; (m0 ^ m1));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* Set unmasked bits so incrementing the reversed cursor</div><div class="line">     * operates on the masked bits of the smaller table */</div><div class="line">    v |= ~m0;</div><div class="line"></div><div class="line">    /* Increment the reverse cursor */</div><div class="line">    v = rev(v);</div><div class="line">    v++;</div><div class="line">    v = rev(v);</div><div class="line"></div><div class="line">    return v;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Redis的dict结构中，有一个遍历dict的函数，因为该遍历函数的算法比较特别，值得单独拿出来研究一下。</p>
<p>首先考虑最简单的情况， 如果一个dict是稳定，即没有扩大缩小，也没有正好处于rehash的过程中，那么这种情况下的遍历是最简单的， 只需要按照索引值顺序遍历第一个hash表ht[0]就行。 </p>
<p>但是如果本次索引的遍历的时候，跟上一个索引遍历的时候，dict已经经过了扩大或者缩小，或者dict正好处于rehash的过程中的时候，遍历过程就变复杂了。</p>
<p>如果仍旧采用顺序遍历索引的策略，考虑dict经过缩小的情况。如果hash表一共有8个slot，经过扩大变成了4个slot，在计算索引的时候，都是hash值同mask=size-1做与操作。所以如果某个key的hash值最后原来是7的话，在slot=8的时候，应该放到索引为7的slot，但是缩小到4个slot的时候，将被放在slot=3。可以想见，这种情况下，会有大量的key被漏掉。同样，如果经过了扩大，也会有大量的key被重复遍历。</p>
<h2 id="dict的反向二进制位遍历"><a href="#dict的反向二进制位遍历" class="headerlink" title="dict的反向二进制位遍历"></a>dict的反向二进制位遍历</h2><p>Redis的遍历方式采用了反向的二进制位遍历。那么什么是反向二进制位遍历呢。按照正常的遍历逻辑，遍历的顺序是按照0-&gt;1-&gt;2-&gt;3-&gt;4….</p>
<p>但是dictScan采用的顺序，以8个slot为例，是0-&gt;4-&gt;2-&gt;6-&gt;1-&gt;5-&gt;3-&gt;7。看着貌似没有规律，但是其实是从高位开始，向低位进位的一种遍历方式，用二进制更能直观的看出来</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">000 --&gt; 100 --&gt; 010 --&gt; 110 --&gt; 001 --&gt; 101 --&gt; 011 --&gt; 111 --&gt; 000</div></pre></td></tr></table></figure>
<p> 那么用这种方式遍历会有什么好处呢，可以按照dict不同状态的示例来说明</p>
<h3 id="1、当dict稳定的时候"><a href="#1、当dict稳定的时候" class="headerlink" title="1、当dict稳定的时候"></a>1、当dict稳定的时候</h3><p>这种情况下，从上面的说明能看出，反向二进制遍历同正向二进制遍历一样，能够遍历到所有的索引，并且不会有重复或遗漏</p>
<h3 id="2、当dict扩大的时候"><a href="#2、当dict扩大的时候" class="headerlink" title="2、当dict扩大的时候"></a>2、当dict扩大的时候</h3><p>假设dict的slot由8个扩大到16个，首先列出两种状态下的遍历顺序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">000 --&gt; 100 --&gt; 010 --&gt; 110 --&gt; 001 --&gt; 101 --&gt; 011 --&gt; 111 --&gt; 000     </div><div class="line">  </div><div class="line">0000 --&gt; 1000 --&gt; 0100 --&gt; 1100 --&gt; 0010 --&gt; 1010 --&gt; 0110 --&gt; 1110 --&gt; 0001 --&gt; 1001 --&gt; 0101 --&gt; 1101 --&gt; 0011 --&gt; 1011 --&gt; 0111 --&gt; 1111 --&gt; 0000</div></pre></td></tr></table></figure>
<p>假设在slot=8的时候已经遍历完了010的索引，下一次就需要遍历110的索引。此时dict发生了rehash操作，slot从8个扩展到了16个，</p>
<p>在slot=16的情况下，就需要遍历0110的索引。 此时，在slot=8的时候遍历过的所以值为000，100，010，对应到slot=16的情况下，分别是0000，1000， 0100，1100， 0010， 1010， 正好是所以址0110的前序所以， 这样的话，整个遍历流程，不会造成遍历的重复或者遗漏。</p>
<h3 id="3、当dict缩小的时候"><a href="#3、当dict缩小的时候" class="headerlink" title="3、当dict缩小的时候"></a>3、当dict缩小的时候</h3><p>假设在slot=16的是，已经遍历完了0110的索引，下一个就要遍历1110的索引，此时dict缩小到了slot=8 。此前已经遍历过的所有索引分别为 0000， 1000， 0100， 1100， 0010， 1010， 0110， 对应到slot=8的情况下，分别落到索引000，100，010，110。 </p>
<p>此时需要从110的所以开始遍历，但是由于此前在slot=16的时候已经遍历过的0110的索引值也是落到110的索引，所以会造成一部分的key被重复遍历。</p>
<p>原哈希表长度为x，缩小后长度为y，则最多会有x/y – 1个原bucket的节点会被重复迭代。比如由16缩小为8，则最多就有1个bucket节点会重复迭代，要是由32缩小为8，则最多会有3个。</p>
<p>但是，也有可能，正好不重复遍历，比如slot=16的时候遍历到1010，即将遍历0110的时候dict缩小的时候，就不会产生重复。</p>
<p>反向二进制算法保证了dict不会遗漏元素，同时在dict缩小的时候，保证了比较小的元素重复。</p>
<h3 id="4、正好进行rehash的时候"><a href="#4、正好进行rehash的时候" class="headerlink" title="4、正好进行rehash的时候"></a>4、正好进行rehash的时候</h3><p>当dict正好在进行rehash的时候，当前遍历的索引里边可能数据不全，因为有一部分已经rehash到新表中去了。所以为了不漏掉元素，采取的措施是同时遍历两个hash表的对应索引。</p>
<p>但是rehash的过程中，不管扩大还是缩小，两张表的索引都是不同的，如何对应呢。 方法就是先比较两张hash表的大小，先遍历较小的hash表，遍历完之后，找到大表中所有对应的索引值，全部依次遍历。</p>
<p>举个例子，暂且不管dict当前是在扩大还是缩小，两张hash表的大小肯定是不同的。假设一张表的slot=8，另一张表的slot=32， 两个mask分别为111和11111。 假设当前的hash值同111做与操作之后为010，那么小表中010的索引遍历之后，需要遍历大表的00010，01010， 10010和11010的索引，然后将两者的索引一块返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">v = (((v | m0) + 1) &amp; ~m0) | (v &amp; m0);</div></pre></td></tr></table></figure>
<p>那么如何保证大表对应的所有索引都能遍历到呢。代码中可以看到这么一条语句，分析一下。 v | m0 将v的低位全部置为1， (v | m0) + 1则是将v的高位加1，之后再 &amp; ~m0 将所有低位置0， v &amp; m0 就是将v的低位提取出来放到之前的数值之后。 这样就能够： 保持v的低位不变，高位持续加1，遍历所有扩展后的slot</p>
<p>那么高位什么时候停止加1呢，就是while终止的条件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">while (v &amp; (m0 ^ m1))</div></pre></td></tr></table></figure>
<p>由于m0和m1都是全为1的mask，假设m0=111， m1=11111， 那么m0 ^ m1 = 11000， 所以我们能看到当v的高位没有1了，其实就是说到头了，循环就会终止。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Redis的dictScan通过反向二进制位的遍历顺序，既能防止漏掉遍历元素，也能在必须要重复遍历元素的时候，减少重复元素的个数。 同时在处理rehash操作时的遍历的时候，通过各种位操作的结合，使得rehash过程中不会漏掉元素。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://harleylau.github.io/2017/08/02/Redis源码剖析-dict遍历算法/" data-id="cjgzvfyt70005ts68s4ex6wxb" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/">redis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码/">源码</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JWT/">JWT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tornado/">Tornado</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tornado/">tornado</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/websocket/">websocket</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/二维码/">二维码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/源码/">源码</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/JWT/" style="font-size: 10px;">JWT</a> <a href="/tags/Python/" style="font-size: 10px;">Python</a> <a href="/tags/Tornado/" style="font-size: 10px;">Tornado</a> <a href="/tags/redis/" style="font-size: 20px;">redis</a> <a href="/tags/tornado/" style="font-size: 15px;">tornado</a> <a href="/tags/websocket/" style="font-size: 10px;">websocket</a> <a href="/tags/二维码/" style="font-size: 10px;">二维码</a> <a href="/tags/源码/" style="font-size: 20px;">源码</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/05/09/Redis源码剖析-字符串t-string实现/">Redis源码剖析--字符串t_string实现</a>
          </li>
        
          <li>
            <a href="/2018/02/12/tornado-websocket实现二维码扫描/">tornado websocket实现二维码扫描</a>
          </li>
        
          <li>
            <a href="/2018/02/12/tornado之WebSocket/">tornado之WebSocket</a>
          </li>
        
          <li>
            <a href="/2017/09/12/Redis源码剖析-字符串对象/">Redis源码剖析--字符串对象</a>
          </li>
        
          <li>
            <a href="/2017/09/07/Redis源码剖析-对象Object/">Redis源码剖析--对象Object</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 Harley Liu<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>